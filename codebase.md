This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: fonts, public
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  ISSUE_TEMPLATE/
    1_bug_report.yml
    2_feature_request.yml
    3_question.yml
    config.yml
  workflows/
    ci.yml
  pull_request_template.md
.husky/
  commit-msg
  pre-commit
errors/
  index.js
infra/
  migrations/
    1632278997051_create-user-table.js
    1643395493467_create-activate-account-tokens-table.js
    1643506329419_create-session-table.js
    1649621949432_create-content-table.js
    1653426303599_reset-password-tokens.js
    1654104499933_alter-table-contents-add-deleted-at-checks.js
    1654703651489_create-table-events.js
    1655868441752_create-table-balance-operations.js
    1662569439391_create-table-email-confirmation-tokens.js
    1662663951003_alter-table-users-add-notifications.js
    1669088607994_create-index-on-contents-for-find-children-tree.js
    1669119602632_create-index-balance-operations.js
    1684412419408_alter-contents-table-add-root-id-array.js
    1688768453152_alter-table-users-add-description.js
    1693859094620_alter-table-users-add-rewarded-at.js
    1707850173496_create-function-get-content-credit-debit.js
    1711833444337_create-separate-balance-operations-tables.js
    1712454019816_alter-function-content-credit-debit.js
    1712744727715_drop-balance-operations.js
    1713103898124_alter-table-contents-add-firewall-status.js
    1715808011643_create-firewall-side-effect-functions.js
    1720619007506_alter-table-contents-add-type.js
    1721243449839_create-table-ad-tabcash-operations.js
    1725403837939_alter-table-users-username-lower-index.js
    1742688128056_alter-table-activate-account-tokens-add-column-email.js
  provisioning/
    modules/
      database/
        main.tf
        outputs.tf
        variables.tf
      state/
        main.tf
        outputs.tf
        variables.tf
      vpc/
        main.tf
        outputs.tf
        variables.tf
    production/
      main.tf
      outputs.tf
      variables.tf
    staging/
      main.tf
      outputs.tf
      variables.tf
  scripts/
    01-create-umami-database.sql
    config-umami.js
    seed-database.js
    wait-for-db-connection-ready.js
  stored-procedures/
    firewall-create-content-text-child.pgsql
    firewall-create-content-text-root.pgsql
    firewall-create-user.pgsql
  database.js
  docker-compose.development.yml
  email.js
  logger.js
  migrator.js
  rate-limit.js
  under-maintenance.js
  webserver.js
models/
  firewall/
    event-types.js
    find.js
    index.js
    review.js
    rules.js
  transactional/
    components/
      default-layout.jsx
      index.js
      link.jsx
      text.jsx
    emails/
      activation.jsx
      confirmation.jsx
      firewall.jsx
      notification.jsx
      recovery.jsx
    index.js
  activation.js
  advertisement.js
  analytics.js
  authentication.js
  authorization.js
  balance.js
  ban.js
  cache-control.js
  content.js
  controller.js
  email-confirmation.js
  event.js
  health.js
  ip.js
  notification.js
  pagination.js
  password.js
  prestige.js
  recovery.js
  remove-markdown.js
  reward.js
  rss.js
  session.js
  thumbnail.js
  umami.js
  user-features.js
  user.js
  validator.js
pages/
  [username]/
    [slug]/
      index.public.js
    classificados/
      [page]/
        index.public.js
    comentarios/
      [page]/
        index.public.js
    conteudos/
      [page]/
        index.public.js
    index.public.js
  api/
    v1/
      _responses/
        rate-limit-reached-sessions.public.js
        rate-limit-reached.public.js
      activation/
        index.public.js
      analytics/
        child-content-published/
          index.public.js
        root-content-published/
          index.public.js
        users-created/
          index.public.js
      contents/
        [username]/
          [slug]/
            children/
              index.public.js
            parent/
              index.public.js
            root/
              index.public.js
            tabcoins/
              index.public.js
            thumbnail/
              index.public.js
            index.public.js
          index.public.js
        rss/
          index.public.js
        index.public.js
      email-confirmation/
        index.public.js
      events/
        firewall/
          [id]/
            index.public.js
      migrations/
        index.public.js
      moderations/
        review_firewall/
          [id]/
            index.public.js
      recovery/
        index.public.js
      sessions/
        index.public.js
      sponsored-beta/
        index.public.js
      status/
        votes/
          index.public.js
        index.public.js
      user/
        index.public.js
      users/
        [username]/
          index.public.js
        index.public.js
  cadastro/
    ativar/
      [token].public.js
    confirmar/
      index.public.js
    recuperar/
      sucesso/
        index.public.js
      [token].public.js
      index.public.js
    index.public.js
  contato/
    index.public.js
  faq/
    index.public.js
  interface/
    components/
      AdBanner/
        index.js
      Analytics/
        index.js
      ButtonWithLoader/
        index.js
      CharacterCount/
        index.js
      Charts/
        index.js
      Confetti/
        index.js
      Content/
        index.js
      ContentList/
        index.js
      DefaultLayout/
        index.js
      EmptyState/
        index.js
      Footer/
        index.js
      Graph/
        index.js
      Head/
        index.js
      Header/
        index.js
      Link/
        index.js
      Markdown/
        index.js
      Pagination/
        index.js
      PastTime/
        index.js
      Progressbar/
        index.js
      ReadTime/
        index.js
      RecentTabNav/
        index.js
      SearchBox/
        index.js
      SkeletonLoader/
        index.js
      TabCashCount/
        index.js
      TabCoinBalanceTooltip/
        index.js
      TabCoinButtons/
        index.js
      TabCoinCount/
        index.js
      TabNewsUI/
        icons/
          index.js
        index.js
      ThemeProvider/
        index.js
      ThemeSelector/
        index.js
      Tooltip/
        index.js
      Turnstile/
        index.js
      UserHeader/
        index.js
      UserList/
        index.js
    hooks/
      useCollapse/
        index.js
      useMediaQuery/
        index.js
      useUser/
        index.js
    utils/
      email-suggestion.js
      error-message.js
      is-valid-json-string.js
      nd-json-stream.js
    index.js
  login/
    index.public.js
  moderacao/
    usuarios/
      [page]/
        index.public.js
  museu/
    evolucao-do-tabnews/
      index.public.js
    index.public.js
  pagina/
    [page]/
      index.public.js
  perfil/
    confirmar-email/
      [token].public.js
    index.public.js
  publicar/
    index.public.js
  recentes/
    classificados/
      [page]/
        index.public.js
    comentarios/
      [page]/
        index.public.js
    pagina/
      [page]/
        index.public.js
    todos/
      [page]/
        index.public.js
  status/
    index.public.js
  termos-de-uso/
    index.public.js
  _app.public.js
  _document.public.js
  404.public.js
  500.public.js
  index.public.js
queries/
  prestigeQueries.js
  rankingQueries.js
tests/
  integration/
    api/
      v1/
        _use-cases/
          registration-flow.test.js
        activation/
          patch.test.js
        contents/
          [username]/
            [slug]/
              children/
                get.test.js
              parent/
                get.test.js
              root/
                get.test.js
              tabcoins/
                post.test.js
              thumbnail/
                get.test.js
              get.test.js
              patch.test.js
            get.test.js
          rss/
            get.test.js
          firewall.post.test.js
          get.test.js
          options.test.js
          post.test.js
        email-confirmation/
          patch.test.js
        events/
          firewall/
            [id]/
              get.test.js
        migrations/
          get.test.js
          post.test.js
        moderations/
          review_firewall/
            [id]/
              post.test.js
        recovery/
          patch.test.js
          post.test.js
        sessions/
          delete.test.js
          get.test.js
          post.test.js
        sponsored-beta/
          get.test.js
        status/
          votes/
            get.test.js
          get.test.js
        swr/
          get.test.js
        user/
          get.test.js
          post.test.js
        users/
          [username]/
            delete.test.js
            get.test.js
            patch.test.js
          firewall.post.test.js
          get.test.js
          post.test.js
    infra/
      under-maintenance.test.js
    models/
      event.test.js
  unit/
    infra/
      email.test.js
      under-maintenance.test.js
    interface/
      components/
        Pagination/
          index.test.js
      utils/
        error-message.test.js
    models/
      transactional/
        __snapshots__/
          index.test.js.snap
        index.test.js
      controller.test.js
      prestige.test.js
      remove-markdown.test.js
      reward.test.js
  constants-for-tests.js
  orchestrator.js
  request-builder.js
  setup.js
.editorconfig
.gitignore
.gitpod.yml
.nvmrc
.prettierignore
commitlint.config.js
CONTRIBUTING.md
eslint.config.js
jsconfig.json
LICENSE
lint-staged.config.js
middleware.public.js
next.config.js
package.json
prettier.config.js
README.md
vercel.json
vitest.config.mjs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/ISSUE_TEMPLATE/1_bug_report.yml">
name: Reportar bug
description: Reporte um problema ou comportamento diferente do esperado.
labels: ['bug']
body:
  - type: markdown
    attributes:
      value: |
        Antes de abrir um novo issue, faça uma [pesquisa](https://github.com/filipedeschamps/tabnews.com.br/issues) para garantir que não está reportando um problema duplicado. Caso encontre um issue equivalente, contribua com informações adicionais, se necessário.
  - type: textarea
    attributes:
      label: Descrição
      description: Que tipo de problema você encontrou? Por favor, descreva-o de forma clara e adicione imagens, se aplicável.
      placeholder: |
        Eu encontrei um problema na página de ... quando eu estava tentando...
        O resultado foi esse:
        ![imagem](https://example.com/imagem)
    validations:
      required: true
  - type: textarea
    attributes:
      label: Passos para reproduzir o problema
      description: Quais são os passos necessários para que outra pessoa consiga encontrar o mesmo problema?
      placeholder: |
        1. Como usuário logado, acesse a página...
        2. Clique em...
        3. Faça...
        4. Volte para ... e veja o erro.
    validations:
      required: true
  - type: dropdown
    attributes:
      label: Navegadores testados
      description: Em quais navegadores você percebeu esse problema?
      multiple: true
      options:
        - Chrome
        - Firefox
        - Microsoft Edge
        - Safari
        - Outro
  - type: textarea
    attributes:
      label: Possível solução
      description: Você pensou em algo que pode resolver esse problema? Se sim, compartilhe abaixo.
      placeholder: |
        Ao invés de ... poderíamos mudar ... para...
        Aqui está um exemplo de como ficaria:
        ![imagem](https://example.com/imagem)
</file>

<file path=".github/ISSUE_TEMPLATE/2_feature_request.yml">
name: Sugerir novo recurso
description: Sugira um novo recurso, funcionalidade ou melhoria para o TabNews.
labels: ['novo recurso']
body:
  - type: markdown
    attributes:
      value: |
        Antes de abrir um novo issue, faça uma [pesquisa](https://github.com/filipedeschamps/tabnews.com.br/issues?q=is%3Aissue) para garantir que não está sugerindo algo duplicado. Caso encontre um issue equivalente, contribua com informações adicionais, se necessário.
  - type: textarea
    attributes:
      label: Descrição
      description: O que você deseja melhorar? Por favor, descreva a sua sugestão e qual necessidade você tem hoje que essa sugestão resolveria.
      placeholder: |
        Eu acho que a página ... ficaria melhor se ... porque tive dificuldade em...
    validations:
      required: true
  - type: textarea
    attributes:
      label: Sugestão de implementação
      description: Você pensou em como isso poderia ser implementado? Compartilhe imagens, código ou referências que você considera úteis para a implementação dessa sugestão.
      placeholder: |
        Poderíamos mudar ... para acrescentar ... Fiz alguns desenhos de como isso poderia ficar:
        ![imagem](https://example.com/imagem)
</file>

<file path=".github/ISSUE_TEMPLATE/3_question.yml">
name: Faça uma pergunta
description: Tem alguma dúvida sobre o repositório, código ou implementação de algo do TabNews? Faça uma pergunta.
labels: ['dúvida']
body:
  - type: markdown
    attributes:
      value: |
        Antes de abrir um novo issue, faça uma [pesquisa](https://github.com/filipedeschamps/tabnews.com.br/issues?q=is%3Aissue) para ver se a sua dúvida já foi respondida.
  - type: dropdown
    attributes:
      label: Assunto
      description: Qual é o assunto da sua dúvida?
      multiple: true
      options:
        - API
        - Código
        - Repositório
        - Contribuição
        - Outro
    validations:
      required: true
  - type: textarea
    attributes:
      label: Dúvida
      description: Qual é a sua dúvida? Seja claro e coloque as informações relevantes para que outras pessoas consigam te ajudar.
      placeholder: |
        Eu não consegui entender como faço para...
    validations:
      required: true
</file>

<file path=".github/ISSUE_TEMPLATE/config.yml">
blank_issues_enabled: false
</file>

<file path=".github/workflows/ci.yml">
name: CI

on: [pull_request]

concurrency:
  group: ci-${{ github.event.pull_request.title }}
  cancel-in-progress: true

jobs:
  tests:
    name: Tests
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4

      - name: Start containers
        run: npm run services:up

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - run: npm ci
      - run: npm run dev & npx vitest run

      - name: Stop containers
        if: always()
        run: npm run services:down

      - name: Check for uncommitted changes after tests
        run: |
          if [ -n "$(git status --porcelain)" ]; then
            git status --porcelain
            echo "Uncommitted changes found. Please review and commit these changes if necessary."
            exit 1
          else
            echo "No uncommitted changes found"
          fi
        shell: bash

  lint-styles:
    name: Lint Styles
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - run: npm ci
      - run: npm run lint

  lint-commits:
    name: Lint Commits
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - run: npm ci
      - run: npx commitlint --from ${{ github.event.pull_request.head.sha }}~${{ github.event.pull_request.commits }} --to ${{ github.event.pull_request.head.sha }} --verbose
</file>

<file path=".github/pull_request_template.md">
## Mudanças realizadas

<!-- Por favor, inclua uma descrição sobre o que foi modificado nesse PR. Inclua também qualquer motivação ou contexto relevante.  -->

<!-- Se o PR contém uma modificação da interface gráfica (UI), adicione fotos ou vídeos comparando o antes e depois. -->

<!-- Se o PR contém modificações de API, mencione os endpoints afetados. -->

<!-- Caso esse PR resolva algum issue, você pode descomentar a linha abaixo e substituir (issue) pelo número dele. -->
<!-- Resolve #(issue) -->

## Tipo de mudança

<!-- Descomente a linha abaixo que corresponde ao tipo de mudança realizada no PR. -->

<!-- - [x] Correção de bug -->
<!-- - [x] Nova funcionalidade -->
<!-- - [x] _**Breaking change**_ (a alteração causa uma quebra de compatibilidade na API ou em links públicos do site) -->
<!-- - [x] Atualização de documentação -->

## Checklist:

- [ ] As modificações não geram novos logs de erro ou aviso (_warning_).
- [ ] Eu adicionei testes que provam que a correção ou novo recurso funciona conforme esperado.
- [ ] Tanto os novos testes quanto os antigos estão passando localmente.
</file>

<file path=".husky/commit-msg">
npx --no -- commitlint --edit "${1}"
</file>

<file path=".husky/pre-commit">
npm run pre-commit
</file>

<file path="errors/index.js">
class BaseError extends Error {
  constructor({
    name,
    message,
    stack,
    cause,
    action,
    statusCode,
    errorId,
    requestId,
    context,
    errorLocationCode,
    key,
    type,
    databaseErrorCode,
  }) {
    super();
    this.name = name;
    this.message = message;
    this.cause = cause;
    this.action = action;
    this.statusCode = statusCode || 500;
    this.errorId = errorId || crypto.randomUUID();
    this.requestId = requestId;
    this.context = context;
    this.stack = stack;
    this.errorLocationCode = errorLocationCode;
    this.key = key;
    this.type = type;
    this.databaseErrorCode = databaseErrorCode;
  }
}

export class InternalServerError extends BaseError {
  constructor({ message, action, requestId, errorId, statusCode, stack, errorLocationCode }) {
    super({
      name: 'InternalServerError',
      message: message || 'Um erro interno não esperado aconteceu.',
      action: action || "Informe ao suporte o valor encontrado no campo 'error_id'.",
      statusCode: statusCode || 500,
      requestId: requestId,
      errorId: errorId,
      stack: stack,
      errorLocationCode: errorLocationCode,
    });
  }
}

export class NotFoundError extends BaseError {
  constructor({ message, action, requestId, errorId, stack, errorLocationCode, key }) {
    super({
      name: 'NotFoundError',
      message: message || 'Não foi possível encontrar este recurso no sistema.',
      action: action || 'Verifique se o caminho (PATH) está correto.',
      statusCode: 404,
      requestId: requestId,
      errorId: errorId,
      stack: stack,
      errorLocationCode: errorLocationCode,
      key: key,
    });
  }
}

export class ServiceError extends BaseError {
  constructor({ message, action, stack, context, statusCode, errorLocationCode, databaseErrorCode, cause }) {
    super({
      name: 'ServiceError',
      message: message || 'Serviço indisponível no momento.',
      action: action || 'Verifique se o serviço está disponível.',
      stack: stack,
      cause: cause,
      statusCode: statusCode || 503,
      context: context,
      errorLocationCode: errorLocationCode,
      databaseErrorCode: databaseErrorCode,
    });
  }
}

export class ValidationError extends BaseError {
  constructor({ message, action, stack, statusCode, context, errorLocationCode, key, type }) {
    super({
      name: 'ValidationError',
      message: message || 'Um erro de validação ocorreu.',
      action: action || 'Ajuste os dados enviados e tente novamente.',
      statusCode: statusCode || 400,
      stack: stack,
      context: context,
      errorLocationCode: errorLocationCode,
      key: key,
      type: type,
    });
  }
}

export class UnauthorizedError extends BaseError {
  constructor({ message, action, requestId, stack, errorLocationCode }) {
    super({
      name: 'UnauthorizedError',
      message: message || 'Usuário não autenticado.',
      action: action || 'Verifique se você está autenticado com uma sessão ativa e tente novamente.',
      requestId: requestId,
      statusCode: 401,
      stack: stack,
      errorLocationCode: errorLocationCode,
    });
  }
}

export class ForbiddenError extends BaseError {
  constructor({ message, action, requestId, stack, errorLocationCode }) {
    super({
      name: 'ForbiddenError',
      message: message || 'Você não possui permissão para executar esta ação.',
      action: action || 'Verifique se você possui permissão para executar esta ação.',
      requestId: requestId,
      statusCode: 403,
      stack: stack,
      errorLocationCode: errorLocationCode,
    });
  }
}

export class TooManyRequestsError extends BaseError {
  constructor({ message, action, context, stack, errorLocationCode }) {
    super({
      name: 'TooManyRequestsError',
      message: message || 'Você realizou muitas requisições recentemente.',
      action: action || 'Tente novamente mais tarde ou contate o suporte caso acredite que isso seja um erro.',
      statusCode: 429,
      context: context,
      stack: stack,
      errorLocationCode: errorLocationCode,
    });
  }
}

export class UnprocessableEntityError extends BaseError {
  constructor({ message, action, stack, errorLocationCode }) {
    super({
      name: 'UnprocessableEntityError',
      message: message || 'Não foi possível realizar esta operação.',
      action: action || 'Os dados enviados estão corretos, porém não foi possível realizar esta operação.',
      statusCode: 422,
      stack: stack,
      errorLocationCode: errorLocationCode,
    });
  }
}

export class MethodNotAllowedError extends BaseError {
  constructor({ message, action, requestId, errorId, stack, errorLocationCode }) {
    super({
      name: 'MethodNotAllowedError',
      message: message || 'Método não permitido para este recurso.',
      action: action || 'Verifique se o método HTTP utilizado é válido para este recurso.',
      statusCode: 405,
      requestId: requestId,
      errorId: errorId,
      stack: stack,
      errorLocationCode: errorLocationCode,
    });
  }
}
</file>

<file path="infra/migrations/1632278997051_create-user-table.js">
exports.up = (pgm) => {
  pgm.createTable('users', {
    id: {
      type: 'uuid',
      default: pgm.func('gen_random_uuid()'),
      notNull: true,
      primaryKey: true,
    },

    // For comparison, GitHub uses a maximum of 39 characters
    username: {
      type: 'varchar(30)',
      notNull: true,
      unique: true,
    },

    // Why 254 in length? https://stackoverflow.com/a/1199238
    email: {
      type: 'varchar(254)',
      notNull: true,
      unique: true,
    },

    // Why 60 varchar? https://forums.phpfreaks.com/topic/293405-recommended-sql-datatype-for-bcrypt-hash/#comment-1500831
    password: {
      type: 'varchar(60)',
      notNull: true,
    },

    features: {
      type: 'varchar[]',
      notNull: true,
      default: `{}`,
    },

    // Why "with timezone"? https://stackoverflow.com/a/20713587
    created_at: {
      type: 'timestamp with time zone',
      notNull: true,
      default: pgm.func("(now() at time zone 'utc')"),
    },

    updated_at: {
      type: 'timestamp with time zone',
      notNull: true,
      default: pgm.func("(now() at time zone 'utc')"),
    },
  });
};

exports.down = (pgm) => {
  pgm.dropTable('users');
};
</file>

<file path="infra/migrations/1643395493467_create-activate-account-tokens-table.js">
exports.up = (pgm) => {
  pgm.createTable('activate_account_tokens', {
    id: {
      type: 'uuid',
      default: pgm.func('gen_random_uuid()'),
      notNull: true,
      primaryKey: true,
    },

    user_id: {
      type: 'uuid',
      notNull: true,
    },

    used: {
      type: 'boolean',
      notNull: true,
      default: false,
    },

    expires_at: {
      type: 'timestamp with time zone',
      notNull: true,
    },

    created_at: {
      type: 'timestamp with time zone',
      notNull: true,
      default: pgm.func("(now() at time zone 'utc')"),
    },

    updated_at: {
      type: 'timestamp with time zone',
      notNull: true,
      default: pgm.func("(now() at time zone 'utc')"),
    },
  });
};

exports.down = (pgm) => {
  pgm.dropTable('activate_account_tokens');
};
</file>

<file path="infra/migrations/1643506329419_create-session-table.js">
exports.up = (pgm) => {
  pgm.createTable('sessions', {
    id: {
      type: 'uuid',
      default: pgm.func('gen_random_uuid()'),
      notNull: true,
      primaryKey: true,
    },

    token: {
      type: 'varchar(96)',
      notNull: true,
    },

    user_id: {
      type: 'uuid',
      notNull: true,
    },

    expires_at: {
      type: 'timestamp with time zone',
      notNull: true,
    },

    created_at: {
      type: 'timestamp with time zone',
      notNull: true,
      default: pgm.func("(now() at time zone 'utc')"),
    },

    updated_at: {
      type: 'timestamp with time zone',
      notNull: true,
      default: pgm.func("(now() at time zone 'utc')"),
    },
  });
};

exports.down = (pgm) => {
  pgm.dropTable('sessions');
};
</file>

<file path="infra/migrations/1649621949432_create-content-table.js">
exports.up = async (pgm) => {
  await pgm.createTable('contents', {
    id: {
      type: 'uuid',
      default: pgm.func('gen_random_uuid()'),
      notNull: true,
      primaryKey: true,
      unique: true,
    },

    parent_id: {
      type: 'uuid',
      notNull: false,
    },

    owner_id: {
      type: 'uuid',
      notNull: true,
    },

    slug: {
      type: 'varchar',
      check: 'length(slug) <= 256',
      notNull: true,
    },

    title: {
      type: 'varchar',
      check: 'length(title) <= 256',
      notNull: false,
    },

    body: {
      type: 'text',
      check: 'length(body) <= 20000',
      notNull: true,
    },

    status: {
      type: 'varchar',
      default: 'draft',
      notNull: true,
      check: "status IN ('draft', 'published')",
    },

    source_url: {
      type: 'varchar',
      check: 'length(source_url) <= 2000',
      notNull: false,
    },

    published_at: {
      type: 'timestamp with time zone',
      notNull: false,
    },

    created_at: {
      type: 'timestamp with time zone',
      notNull: true,
      default: pgm.func("(now() at time zone 'utc')"),
    },

    updated_at: {
      type: 'timestamp with time zone',
      notNull: true,
      default: pgm.func("(now() at time zone 'utc')"),
    },
  });

  await pgm.addConstraint('contents', 'contents_uniqueness_fkey', 'UNIQUE ("owner_id", "slug")');
};

exports.down = async (pgm) => {
  await pgm.dropConstraint('contents', 'contents_uniqueness_fkey');
  await pgm.dropTable('contents');
};
</file>

<file path="infra/migrations/1653426303599_reset-password-tokens.js">
exports.up = (pgm) => {
  pgm.createTable('reset_password_tokens', {
    id: {
      type: 'uuid',
      default: pgm.func('gen_random_uuid()'),
      notNull: true,
      primaryKey: true,
    },

    user_id: {
      type: 'uuid',
      notNull: true,
    },

    used: {
      type: 'boolean',
      notNull: true,
      default: false,
    },

    expires_at: {
      type: 'timestamp with time zone',
      notNull: true,
    },

    created_at: {
      type: 'timestamp with time zone',
      notNull: true,
      default: pgm.func("(now() at time zone 'utc')"),
    },

    updated_at: {
      type: 'timestamp with time zone',
      notNull: true,
      default: pgm.func("(now() at time zone 'utc')"),
    },
  });
};

exports.down = (pgm) => {
  pgm.dropTable('reset_password_tokens');
};
</file>

<file path="infra/migrations/1654104499933_alter-table-contents-add-deleted-at-checks.js">
exports.up = async (pgm) => {
  await pgm.addColumns('contents', {
    deleted_at: {
      type: 'timestamp with time zone',
      notNull: false,
    },
  });

  await pgm.dropConstraint('contents', 'contents_status_check');
  pgm.addConstraint('contents', 'contents_status_check', "CHECK (status IN ('draft', 'published', 'deleted'))");

  await pgm.dropConstraint('contents', 'contents_uniqueness_fkey');
  await pgm.createIndex('contents', ['owner_id', 'slug', '(deleted_at IS NULL)'], {
    name: 'contents_owner_id_slug_deleted_at_unique_index',
    unique: true,
    where: 'deleted_at IS NULL',
  });
};

exports.down = false;
</file>

<file path="infra/migrations/1654703651489_create-table-events.js">
exports.shorthands = undefined;

exports.up = (pgm) => {
  pgm.createTable('events', {
    id: {
      type: 'uuid',
      default: pgm.func('gen_random_uuid()'),
      notNull: true,
      primaryKey: true,
    },

    type: {
      type: 'text',
      notNull: true,
    },

    originator_user_id: {
      type: 'uuid',
      notNull: false,
    },

    originator_ip: {
      type: 'inet',
      notNull: false,
    },

    metadata: {
      type: 'jsonb',
      notNull: false,
    },

    created_at: {
      type: 'timestamp with time zone',
      notNull: true,
      default: pgm.func("(now() at time zone 'utc')"),
    },
  });
};

exports.down = false;
</file>

<file path="infra/migrations/1655868441752_create-table-balance-operations.js">
exports.up = async (pgm) => {
  await pgm.createTable('balance_operations', {
    id: {
      type: 'uuid',
      default: pgm.func('gen_random_uuid()'),
      notNull: true,
      primaryKey: true,
    },

    sequence: {
      type: 'serial',
      notNull: true,
    },

    balance_type: {
      type: 'text',
      notNull: true,
    },

    recipient_id: {
      type: 'uuid',
      notNull: true,
    },

    amount: {
      type: 'integer',
      notNull: true,
    },

    originator_type: {
      type: 'text',
      notNull: true,
    },

    originator_id: {
      type: 'uuid',
      notNull: true,
    },

    created_at: {
      type: 'timestamp with time zone',
      notNull: true,
      default: pgm.func("(now() at time zone 'utc')"),
    },
  });

  await pgm.createFunction(
    'get_current_balance',
    [
      {
        name: 'balance_type_input',
        mode: 'IN',
        type: 'text',
      },
      {
        name: 'recipient_id_input',
        mode: 'IN',
        type: 'uuid',
      },
    ],
    {
      returns: 'integer',
      language: 'plpgsql',
      replace: true,
    },
    `
    DECLARE
      total_balance integer;
    BEGIN
      total_balance := (
        SELECT
          COALESCE(sum(amount), 0)
        FROM
          balance_operations
        WHERE
          balance_type = balance_type_input
          AND recipient_id = recipient_id_input
      );

      RETURN total_balance;
    END;
  `,
  );
};

exports.down = false;
</file>

<file path="infra/migrations/1662569439391_create-table-email-confirmation-tokens.js">
exports.up = (pgm) => {
  pgm.createTable('email_confirmation_tokens', {
    id: {
      type: 'uuid',
      default: pgm.func('gen_random_uuid()'),
      notNull: true,
      primaryKey: true,
    },

    user_id: {
      type: 'uuid',
      notNull: true,
    },

    // Why 254 in length? https://stackoverflow.com/a/1199238
    email: {
      type: 'varchar(254)',
      notNull: true,
      unique: false,
    },

    used: {
      type: 'boolean',
      notNull: true,
      default: false,
    },

    expires_at: {
      type: 'timestamp with time zone',
      notNull: true,
    },

    created_at: {
      type: 'timestamp with time zone',
      notNull: true,
      default: pgm.func("(now() at time zone 'utc')"),
    },

    updated_at: {
      type: 'timestamp with time zone',
      notNull: true,
      default: pgm.func("(now() at time zone 'utc')"),
    },
  });
};

exports.down = false;
</file>

<file path="infra/migrations/1662663951003_alter-table-users-add-notifications.js">
exports.up = async (pgm) => {
  await pgm.addColumns('users', {
    notifications: {
      type: 'boolean',
      notNull: true,
      default: true,
    },
  });
};

exports.down = false;
</file>

<file path="infra/migrations/1669088607994_create-index-on-contents-for-find-children-tree.js">
exports.shorthands = undefined;

exports.up = async (pgm) => {
  await pgm.createIndex('contents', ['id', 'parent_id'], {
    name: 'contents_published_parent_and_children_idx',
    where: "contents.status = 'published'",
    unique: true,
  });

  await pgm.createIndex('users', ['id', 'username'], {
    name: 'users_id_username_idx',
    unique: true,
  });
};

exports.down = async (pgm) => {
  await pgm.dropIndex('contents', ['id', 'username'], {
    name: 'contents_published_parent_and_children_idx',
    unique: true,
  });

  await pgm.dropIndex('users', ['id', 'username'], {
    name: 'users_id_username_idx',
    unique: true,
  });
};
</file>

<file path="infra/migrations/1669119602632_create-index-balance-operations.js">
exports.up = async (pgm) => {
  await pgm.createIndex('balance_operations', ['balance_type', 'recipient_id']);
};

exports.down = false;
</file>

<file path="infra/migrations/1684412419408_alter-contents-table-add-root-id-array.js">
exports.up = async (pgm) => {
  await pgm.addColumns('contents', {
    path: {
      type: 'uuid[]',
      notNull: true,
      default: '{}',
    },
  });

  await pgm.createIndex('contents', 'path', {
    name: 'contents_path_idx',
    method: 'gin',
  });
};

exports.down = false;
</file>

<file path="infra/migrations/1688768453152_alter-table-users-add-description.js">
exports.up = async (pgm) => {
  await pgm.addColumns('users', {
    description: {
      type: 'text',
      check: 'length(description) <= 5000',
      notNull: true,
      default: '',
    },
  });
};

exports.down = false;
</file>

<file path="infra/migrations/1693859094620_alter-table-users-add-rewarded-at.js">
exports.up = (pgm) => {
  pgm.addColumns('users', {
    rewarded_at: {
      type: 'timestamp with time zone',
      notNull: true,
      default: pgm.func("(now() at time zone 'utc')"),
    },
  });
};

exports.down = (pgm) => {
  pgm.dropColumns('users', ['rewarded_at']);
};
</file>

<file path="infra/migrations/1707850173496_create-function-get-content-credit-debit.js">
exports.up = async (pgm) => {
  await pgm.createFunction(
    'get_content_balance_credit_debit',
    [
      {
        name: 'content_id_input',
        mode: 'IN',
        type: 'uuid',
      },
    ],
    {
      returns: 'TABLE (total_balance BIGINT, total_credit BIGINT, total_debit BIGINT) ROWS 1',
      language: 'plpgsql',
      replace: true,
    },
    `
    BEGIN
      RETURN QUERY
        SELECT
          COALESCE(SUM(amount), 0) AS total_balance,
          COALESCE(SUM(CASE WHEN balance_type = 'content:tabcoin:credit' THEN amount END), 0) AS total_credit,
          COALESCE(SUM(CASE WHEN balance_type = 'content:tabcoin:debit' THEN amount END), 0) AS total_debit
        FROM
          balance_operations
        WHERE
          recipient_id = content_id_input;
    END;
  `,
  );

  await pgm.createFunction(
    'get_current_balance',
    [
      {
        name: 'balance_type_input',
        mode: 'IN',
        type: 'text',
      },
      {
        name: 'recipient_id_input',
        mode: 'IN',
        type: 'uuid',
      },
    ],
    {
      returns: 'integer',
      language: 'plpgsql',
      replace: true,
    },
    `
    DECLARE
      total_balance integer;
    BEGIN
      SELECT COALESCE(SUM(amount), 0)
      INTO total_balance
      FROM balance_operations
      WHERE
        (CASE
            WHEN balance_type_input = 'content:tabcoin' THEN true
            ELSE balance_type = balance_type_input 
        END)
        AND recipient_id = recipient_id_input;

      RETURN total_balance;
    END;`,
  );

  await pgm.createIndex('balance_operations', ['recipient_id', 'balance_type'], { ifNotExists: true });

  await pgm.dropIndex('balance_operations', ['balance_type', 'recipient_id'], { ifExists: true });
};

exports.down = async (pgm) => {
  await pgm.dropFunction(
    'get_content_balance_credit_debit',
    [
      {
        name: 'content_id_input',
        mode: 'IN',
        type: 'uuid',
      },
    ],
    { ifExists: true },
  );

  await pgm.createFunction(
    'get_current_balance',
    [
      {
        name: 'balance_type_input',
        mode: 'IN',
        type: 'text',
      },
      {
        name: 'recipient_id_input',
        mode: 'IN',
        type: 'uuid',
      },
    ],
    {
      returns: 'integer',
      language: 'plpgsql',
      replace: true,
    },
    `
    DECLARE
      total_balance integer;
    BEGIN
      total_balance := (
        SELECT
          COALESCE(sum(amount), 0)
        FROM
          balance_operations
        WHERE
          balance_type = balance_type_input
          AND recipient_id = recipient_id_input
      );
      RETURN total_balance;
    END;
  `,
  );

  await pgm.dropIndex('balance_operations', ['recipient_id', 'balance_type'], { ifExists: true });

  await pgm.createIndex('balance_operations', ['balance_type', 'recipient_id'], { ifNotExists: true });
};
</file>

<file path="infra/migrations/1711833444337_create-separate-balance-operations-tables.js">
exports.up = (pgm) => {
  pgm.createTable('content_tabcoin_operations', {
    id: {
      type: 'uuid',
      default: pgm.func('gen_random_uuid()'),
      notNull: true,
      primaryKey: true,
    },

    sequence: {
      type: 'serial',
      notNull: true,
    },

    balance_type: {
      type: 'text',
      notNull: true,
    },

    recipient_id: {
      type: 'uuid',
      notNull: true,
    },

    amount: {
      type: 'integer',
      notNull: true,
    },

    originator_type: {
      type: 'text',
      notNull: true,
    },

    originator_id: {
      type: 'uuid',
      notNull: true,
    },

    created_at: {
      type: 'timestamp with time zone',
      notNull: true,
      default: pgm.func("(now() at time zone 'utc')"),
    },
  });

  pgm.createTable('user_tabcoin_operations', {
    id: {
      type: 'uuid',
      default: pgm.func('gen_random_uuid()'),
      notNull: true,
      primaryKey: true,
    },

    sequence: {
      type: 'serial',
      notNull: true,
    },

    recipient_id: {
      type: 'uuid',
      notNull: true,
    },

    amount: {
      type: 'integer',
      notNull: true,
    },

    originator_type: {
      type: 'text',
      notNull: true,
    },

    originator_id: {
      type: 'uuid',
      notNull: true,
    },

    created_at: {
      type: 'timestamp with time zone',
      notNull: true,
      default: pgm.func("(now() at time zone 'utc')"),
    },
  });

  pgm.createTable('user_tabcash_operations', {
    id: {
      type: 'uuid',
      default: pgm.func('gen_random_uuid()'),
      notNull: true,
      primaryKey: true,
    },

    sequence: {
      type: 'serial',
      notNull: true,
    },

    recipient_id: {
      type: 'uuid',
      notNull: true,
    },

    amount: {
      type: 'integer',
      notNull: true,
    },

    originator_type: {
      type: 'text',
      notNull: true,
    },

    originator_id: {
      type: 'uuid',
      notNull: true,
    },

    created_at: {
      type: 'timestamp with time zone',
      notNull: true,
      default: pgm.func("(now() at time zone 'utc')"),
    },
  });

  pgm.createFunction(
    'get_content_current_tabcoins',
    [
      {
        name: 'recipient_id_input',
        mode: 'IN',
        type: 'uuid',
      },
    ],
    {
      returns: 'integer',
      language: 'plpgsql',
      replace: true,
    },
    `
    DECLARE
      total_tabcoins integer;
    BEGIN
      SELECT COALESCE(SUM(amount), 0)
      INTO total_tabcoins
      FROM content_tabcoin_operations
      WHERE
        recipient_id = recipient_id_input;

      RETURN total_tabcoins;
    END;
  `,
  );

  pgm.createFunction(
    'get_user_current_tabcoins',
    [
      {
        name: 'recipient_id_input',
        mode: 'IN',
        type: 'uuid',
      },
    ],
    {
      returns: 'integer',
      language: 'plpgsql',
      replace: true,
    },
    `
    DECLARE
      total_tabcoins integer;
    BEGIN
      SELECT COALESCE(SUM(amount), 0)
      INTO total_tabcoins
      FROM user_tabcoin_operations
      WHERE
        recipient_id = recipient_id_input;

      RETURN total_tabcoins;
    END;
  `,
  );

  pgm.createFunction(
    'get_user_current_tabcash',
    [
      {
        name: 'recipient_id_input',
        mode: 'IN',
        type: 'uuid',
      },
    ],
    {
      returns: 'integer',
      language: 'plpgsql',
      replace: true,
    },
    `
    DECLARE
    total_tabcash integer;
    BEGIN
      SELECT COALESCE(SUM(amount), 0)
      INTO total_tabcash
      FROM user_tabcash_operations
      WHERE
        recipient_id = recipient_id_input;

      RETURN total_tabcash;
    END;
  `,
  );

  pgm.createIndex('content_tabcoin_operations', ['recipient_id', 'balance_type']);
  pgm.createIndex('user_tabcoin_operations', ['recipient_id']);
  pgm.createIndex('user_tabcash_operations', ['recipient_id']);
};

exports.down = (pgm) => {
  // Do not drop the created tables to avoid accidentally losing data.

  pgm.dropFunction(
    'get_content_current_tabcoins',
    [
      {
        name: 'recipient_id_input',
        mode: 'IN',
        type: 'uuid',
      },
    ],
    { ifExists: true },
  );

  pgm.dropFunction(
    'get_user_current_tabcoins',
    [
      {
        name: 'recipient_id_input',
        mode: 'IN',
        type: 'uuid',
      },
    ],
    { ifExists: true },
  );

  pgm.dropFunction(
    'get_user_current_tabcash',
    [
      {
        name: 'recipient_id_input',
        mode: 'IN',
        type: 'uuid',
      },
    ],
    { ifExists: true },
  );
};
</file>

<file path="infra/migrations/1712454019816_alter-function-content-credit-debit.js">
exports.up = (pgm) => {
  pgm.createFunction(
    'get_content_balance_credit_debit',
    [
      {
        name: 'content_id_input',
        mode: 'IN',
        type: 'uuid',
      },
    ],
    {
      returns: 'TABLE (total_balance BIGINT, total_credit BIGINT, total_debit BIGINT) ROWS 1',
      language: 'plpgsql',
      replace: true,
    },
    `
    BEGIN
      RETURN QUERY
        SELECT
          COALESCE(SUM(amount), 0) AS total_balance,
          COALESCE(SUM(CASE WHEN balance_type = 'credit' THEN amount END), 0) AS total_credit,
          COALESCE(SUM(CASE WHEN balance_type = 'debit' THEN amount END), 0) AS total_debit
        FROM
          content_tabcoin_operations
        WHERE
          recipient_id = content_id_input;
    END;
  `,
  );
};

exports.down = (pgm) => {
  pgm.createFunction(
    'get_content_balance_credit_debit',
    [
      {
        name: 'content_id_input',
        mode: 'IN',
        type: 'uuid',
      },
    ],
    {
      returns: 'TABLE (total_balance BIGINT, total_credit BIGINT, total_debit BIGINT) ROWS 1',
      language: 'plpgsql',
      replace: true,
    },
    `
    BEGIN
      RETURN QUERY
        SELECT
          COALESCE(SUM(amount), 0) AS total_balance,
          COALESCE(SUM(CASE WHEN balance_type = 'content:tabcoin:credit' THEN amount END), 0) AS total_credit,
          COALESCE(SUM(CASE WHEN balance_type = 'content:tabcoin:debit' THEN amount END), 0) AS total_debit
        FROM
          balance_operations
        WHERE
          recipient_id = content_id_input;
    END;
  `,
  );
};
</file>

<file path="infra/migrations/1712744727715_drop-balance-operations.js">
exports.up = (pgm) => {
  pgm.dropTable('balance_operations');

  pgm.dropFunction(
    'get_current_balance',
    [
      {
        name: 'balance_type_input',
        mode: 'IN',
        type: 'text',
      },
      {
        name: 'recipient_id_input',
        mode: 'IN',
        type: 'uuid',
      },
    ],
    { ifExists: true },
  );
};

exports.down = (pgm) => {
  pgm.createTable('balance_operations', {
    id: {
      type: 'uuid',
      default: pgm.func('gen_random_uuid()'),
      notNull: true,
      primaryKey: true,
    },

    sequence: {
      type: 'serial',
      notNull: true,
    },

    balance_type: {
      type: 'text',
      notNull: true,
    },

    recipient_id: {
      type: 'uuid',
      notNull: true,
    },

    amount: {
      type: 'integer',
      notNull: true,
    },

    originator_type: {
      type: 'text',
      notNull: true,
    },

    originator_id: {
      type: 'uuid',
      notNull: true,
    },

    created_at: {
      type: 'timestamp with time zone',
      notNull: true,
      default: pgm.func("(now() at time zone 'utc')"),
    },
  });

  pgm.createFunction(
    'get_current_balance',
    [
      {
        name: 'balance_type_input',
        mode: 'IN',
        type: 'text',
      },
      {
        name: 'recipient_id_input',
        mode: 'IN',
        type: 'uuid',
      },
    ],
    {
      returns: 'integer',
      language: 'plpgsql',
      replace: true,
    },
    `
    DECLARE
      total_balance integer;
    BEGIN
      SELECT COALESCE(SUM(amount), 0)
      INTO total_balance
      FROM balance_operations
      WHERE
        (CASE
            WHEN balance_type_input = 'content:tabcoin' THEN true
            ELSE balance_type = balance_type_input 
        END)
        AND recipient_id = recipient_id_input;

      RETURN total_balance;
    END;`,
  );

  pgm.createIndex('balance_operations', ['recipient_id', 'balance_type']);
};
</file>

<file path="infra/migrations/1713103898124_alter-table-contents-add-firewall-status.js">
exports.up = (pgm) => {
  pgm.dropConstraint('contents', 'contents_status_check');
  pgm.addConstraint(
    'contents',
    'contents_status_check',
    "CHECK (status IN ('draft', 'published', 'deleted', 'firewall'))",
  );
};

exports.down = (pgm) => {
  pgm.dropConstraint('contents', 'contents_status_check');
  pgm.addConstraint('contents', 'contents_status_check', "CHECK (status IN ('draft', 'published', 'deleted'))");
};
</file>

<file path="infra/migrations/1715808011643_create-firewall-side-effect-functions.js">
exports.up = (pgm) => {
  pgm.dropFunction(
    'firewall_create_content_text_child_side_effect',
    [
      {
        name: 'client_ip_input',
        mode: 'IN',
        type: 'inet',
      },
    ],
    { ifExists: true },
  );

  pgm.dropFunction(
    'firewall_create_content_text_root_side_effect',
    [
      {
        name: 'client_ip_input',
        mode: 'IN',
        type: 'inet',
      },
    ],
    { ifExists: true },
  );

  pgm.dropFunction(
    'firewall_create_user_side_effect',
    [
      {
        name: 'client_ip_input',
        mode: 'IN',
        type: 'inet',
      },
    ],
    { ifExists: true },
  );

  pgm.createFunction(
    'firewall_create_content_text_child_side_effect',
    [
      {
        name: 'client_ip_input',
        mode: 'IN',
        type: 'inet',
      },
    ],
    {
      returns:
        'TABLE (id uuid, published_at timestamp, status_before_update varchar, status varchar, owner_id uuid, tabcoins integer)',
      language: 'plpgsql',
      replace: true,
    },
    `
  DECLARE
    contents_to_update record;
  BEGIN
    FOR contents_to_update IN (
      SELECT
        metadata->>'id' as id
      FROM
        events
      WHERE
        type = 'create:content:text_child'
        AND originator_ip = client_ip_input
        AND created_at > NOW() - INTERVAL '10 minutes'
    )
    LOOP
      UPDATE
        contents
      SET
        status = 'firewall'
      WHERE
        contents.id = contents_to_update.id::uuid
      RETURNING
        contents.id,
        contents.published_at,
        contents.status,
        contents.owner_id,
        get_content_current_tabcoins(contents_to_update.id::uuid),
        (SELECT contents.status FROM contents WHERE contents.id = contents_to_update.id::uuid)
      INTO
        id,
        published_at,
        status,
        owner_id,
        tabcoins,
        status_before_update;

      IF FOUND THEN
        RETURN NEXT;
      END IF;
    END LOOP;
  END;
  `,
  );

  pgm.createFunction(
    'firewall_create_content_text_root_side_effect',
    [
      {
        name: 'client_ip_input',
        mode: 'IN',
        type: 'inet',
      },
    ],
    {
      returns:
        'TABLE (id uuid, title varchar, published_at timestamp, status_before_update varchar, status varchar, owner_id uuid, tabcoins integer)',
      language: 'plpgsql',
      replace: true,
    },
    `
  DECLARE
    contents_to_update record;
  BEGIN
    FOR contents_to_update IN (
      SELECT
        metadata->>'id' as id
      FROM
        events
      WHERE
        type = 'create:content:text_root'
        AND originator_ip = client_ip_input
        AND created_at > NOW() - INTERVAL '10 minutes'
    )
    LOOP
      UPDATE
        contents
      SET
        status = 'firewall'
      WHERE
        contents.id = contents_to_update.id::uuid
      RETURNING
        contents.id,
        contents.title,
        contents.published_at,
        contents.status,
        contents.owner_id,
        get_content_current_tabcoins(contents_to_update.id::uuid),
        (SELECT contents.status FROM contents WHERE contents.id = contents_to_update.id::uuid)
      INTO
        id,
        title,
        published_at,
        status,
        owner_id,
        tabcoins,
        status_before_update;

      IF FOUND THEN
        RETURN NEXT;
      END IF;
    END LOOP;
  END;
  `,
  );

  pgm.createFunction(
    'firewall_create_user_side_effect',
    [
      {
        name: 'client_ip_input',
        mode: 'IN',
        type: 'inet',
      },
    ],
    {
      returns: 'TABLE (id uuid, username varchar, email varchar)',
      language: 'plpgsql',
      replace: true,
    },
    `
    DECLARE
      users_to_block record;
      features_to_remove text[] := array['read:activation_token', 'read:recovery_token', 'create:session', 'read:session'];
      feature text;
    BEGIN
      FOR users_to_block IN (
        SELECT
          metadata->>'id' as id
        FROM
          events
        WHERE
          type = 'create:user'
          AND originator_ip = client_ip_input
          AND created_at > NOW() - INTERVAL '30 minutes'
      )
      LOOP
        id := users_to_block.id;

        FOREACH feature IN ARRAY features_to_remove
        LOOP
          UPDATE
            users
          SET
            features = array_remove(features, feature)
          WHERE
            users.id = users_to_block.id::uuid
          RETURNING
            users.username,
            users.email
          INTO
            username,
            email;
        END LOOP;

        RETURN NEXT;
      END LOOP;
    END;
    `,
  );
};

exports.down = false;
</file>

<file path="infra/migrations/1720619007506_alter-table-contents-add-type.js">
exports.up = (pgm) => {
  pgm.createType('content_types_enum', ['content', 'pitch', 'ad']);

  pgm.addColumns('contents', {
    type: {
      type: 'content_types_enum',
      notNull: true,
      default: 'content',
    },
  });
};

exports.down = false;
</file>

<file path="infra/migrations/1721243449839_create-table-ad-tabcash-operations.js">
exports.up = (pgm) => {
  pgm.createType('ad_balance_type_enum', ['budget', 'daily_debit']);

  pgm.createType('originator_type_enum', ['event', 'user']);

  pgm.createTable('ad_tabcash_operations', {
    id: {
      type: 'uuid',
      default: pgm.func('gen_random_uuid()'),
      notNull: true,
      primaryKey: true,
    },

    sequence: {
      type: 'serial',
      notNull: true,
    },

    balance_type: {
      type: 'ad_balance_type_enum',
      notNull: true,
    },

    recipient_id: {
      type: 'uuid',
      notNull: true,
    },

    amount: {
      type: 'integer',
      notNull: true,
    },

    originator_type: {
      type: 'originator_type_enum',
      notNull: true,
    },

    originator_id: {
      type: 'uuid',
      notNull: true,
    },

    created_at: {
      type: 'timestamp with time zone',
      notNull: true,
      default: pgm.func("(now() at time zone 'utc')"),
    },
  });

  pgm.createFunction(
    'get_ad_current_tabcash',
    [
      {
        name: 'recipient_id_input',
        mode: 'IN',
        type: 'uuid',
      },
    ],
    {
      returns: 'integer',
      language: 'plpgsql',
      replace: true,
    },
    `
    DECLARE
    total_tabcash integer;
    BEGIN
      SELECT COALESCE(SUM(amount), 0)
      INTO total_tabcash
      FROM ad_tabcash_operations
      WHERE
        recipient_id = recipient_id_input;

      RETURN total_tabcash;
    END;
  `,
  );

  pgm.createIndex('ad_tabcash_operations', ['recipient_id', 'balance_type']);
};

exports.down = false;
</file>

<file path="infra/migrations/1725403837939_alter-table-users-username-lower-index.js">
exports.up = (pgm) => {
  pgm.dropConstraint('users', 'users_username_key');

  pgm.createIndex('users', 'LOWER(username)', {
    unique: true,
    name: 'users_username_lower_idx',
  });
};

exports.down = (pgm) => {
  pgm.dropIndex('users', 'LOWER(username)', {
    name: 'users_username_lower_idx',
  });

  pgm.addConstraint('users', 'users_username_key', {
    unique: ['username'],
  });
};
</file>

<file path="infra/migrations/1742688128056_alter-table-activate-account-tokens-add-column-email.js">
exports.up = (pgm) => {
  pgm.addColumns('activate_account_tokens', {
    // Why 254 in length? https://stackoverflow.com/a/1199238
    email: {
      type: 'varchar(254)',
      notNull: false,
      unique: false,
    },
  });
};

exports.down = false;
</file>

<file path="infra/provisioning/modules/database/main.tf">
resource "random_password" "postgres_password" {
  length           = 99
  special          = true
  override_special = "-+=_^~,."
}

resource "random_string" "postgres_username" {
  length  = 62
  special = false
}

resource "random_integer" "postgres_port" {
  min = 1024
  max = 49151
}

resource "random_integer" "postgres_random_identifier_suffix" {
  min = 0
  max = 999999999999
}

data "aws_availability_zones" "available" {
  state = "available"
}

resource "aws_subnet" "postgres_subnet" {
  count                   = 2
  vpc_id                  = var.vpc_id
  cidr_block              = cidrsubnet(var.vpc_cidr_block, 8, count.index)
  availability_zone       = data.aws_availability_zones.available.names[count.index]
  map_public_ip_on_launch = true

  tags = {
    Name        = "${var.environment}-postgres-subnet-${count.index}"
    Environment = var.environment
  }
}

resource "aws_db_subnet_group" "postgres_subnet_group" {
  name       = "${var.environment}-postgres-subnet-group"
  subnet_ids = aws_subnet.postgres_subnet.*.id

  tags = {
    Name        = "${var.environment}-postgres-subnet-group"
    Environment = var.environment
  }
}

resource "aws_route_table_association" "postgres_route_table_association" {
  count          = length(aws_subnet.postgres_subnet)
  subnet_id      = aws_subnet.postgres_subnet[count.index].id
  route_table_id = var.route_table_id
}

resource "aws_security_group" "postgres_security_group" {
  name                   = "${var.environment}-postgres-security-group"
  vpc_id                 = var.vpc_id
  revoke_rules_on_delete = true

  ingress {
    from_port        = random_integer.postgres_port.result
    to_port          = random_integer.postgres_port.result
    protocol         = "tcp"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  egress {
    from_port        = 0
    to_port          = 0
    protocol         = "-1"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  lifecycle {
    create_before_destroy = true
  }

  tags = {
    Name        = "${var.environment}-postgres-security-group"
    Environment = var.environment
  }
}

resource "aws_db_parameter_group" "parameter_group" {
  name   = "${var.environment}-parameter-group"
  family = "postgres14"

  parameter {
    name  = "idle_session_timeout"
    value = "0"
  }

  parameter {
    name  = "log_min_duration_statement"
    value = "2000"
  }

  tags = {
    Name        = "${var.environment}-parameter-group"
    Environment = var.environment
  }
}

resource "aws_db_instance" "postgres" {
  identifier        = "${var.environment}-postgres-${random_integer.postgres_random_identifier_suffix.result}"
  storage_type      = "gp2"
  allocated_storage = var.allocated_storage
  engine            = "postgres"
  engine_version    = var.engine_version
  instance_class    = var.instance_class

  username                    = "u${random_string.postgres_username.result}" # has to start with a letter
  password                    = random_password.postgres_password.result
  db_name                     = "tabnews"
  port                        = random_integer.postgres_port.result
  publicly_accessible         = true
  multi_az                    = false
  max_allocated_storage       = var.max_allocated_storage
  allow_major_version_upgrade = true
  auto_minor_version_upgrade  = true

  db_subnet_group_name   = aws_db_subnet_group.postgres_subnet_group.name
  vpc_security_group_ids = [aws_security_group.postgres_security_group.id]

  apply_immediately         = true
  backup_retention_period   = var.backup_retention_period
  backup_window             = "04:00-05:00"
  maintenance_window        = "wed:06:00-wed:07:00"
  skip_final_snapshot       = var.skip_final_snapshot
  final_snapshot_identifier = "${var.environment}-postgres-final-snapshot-${random_integer.postgres_random_identifier_suffix.result}"
  copy_tags_to_snapshot     = true
  deletion_protection       = var.deletion_protection
  delete_automated_backups  = var.delete_automated_backups

  parameter_group_name = aws_db_parameter_group.parameter_group.name

  tags = {
    Name        = "${var.environment}-postgres"
    Environment = var.environment
  }

}
</file>

<file path="infra/provisioning/modules/database/outputs.tf">
output "db_name" {
  value = aws_db_instance.postgres.db_name
}

output "username" {
  value = aws_db_instance.postgres.username
}

output "password" {
  value     = aws_db_instance.postgres.password
  sensitive = true
}

output "port" {
  value = aws_db_instance.postgres.port
}

output "address" {
  value = aws_db_instance.postgres.address
}
</file>

<file path="infra/provisioning/modules/database/variables.tf">
variable "environment" {
  type = string
}

variable "vpc_id" {
  type = string
}

variable "vpc_cidr_block" {
  type = string
}

variable "route_table_id" {
  type = string
}

variable "allocated_storage" {
  type = number
}

variable "max_allocated_storage" {
  type = number
}

variable "engine_version" {
  type = string
}

variable "instance_class" {
  type = string
}

variable "backup_retention_period" {
  type = number
}

variable "skip_final_snapshot" {
  type = bool
}

variable "deletion_protection" {
  type = bool
}

variable "delete_automated_backups" {
  type = bool
}
</file>

<file path="infra/provisioning/modules/state/main.tf">
resource "random_string" "s3_bucket_postfix" {
  length  = 40
  special = false
  lower   = true
  upper   = false
}

resource "aws_s3_bucket" "terraform_state" {
  bucket        = "${var.environment}-tfstate-${random_string.s3_bucket_postfix.result}"
  force_destroy = true

  tags = {
    Name        = "${var.environment}-terraform-state"
    Environment = var.environment
  }
}

resource "aws_s3_bucket_acl" "acl" {
  bucket = aws_s3_bucket.terraform_state.id
  acl    = "private"
}

resource "aws_s3_bucket_versioning" "versioning" {
  bucket = aws_s3_bucket.terraform_state.id

  versioning_configuration {
    status = "Enabled"
  }
}

resource "aws_s3_bucket_public_access_block" "public_access" {
  bucket = aws_s3_bucket.terraform_state.id

  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}

resource "aws_kms_key" "s3_key" {
  description             = "${var.environment}-s3-key"
  deletion_window_in_days = 10
  enable_key_rotation     = true

  tags = {
    Name        = "${var.environment}-s3-key"
    Environment = var.environment
  }
}

resource "aws_kms_alias" "kms_s3_key_alias" {
  name          = "alias/${var.environment}-terraform-state"
  target_key_id = aws_kms_key.s3_key.key_id
}

resource "aws_s3_bucket_server_side_encryption_configuration" "encryption" {
  bucket = aws_s3_bucket.terraform_state.id

  rule {
    apply_server_side_encryption_by_default {
      kms_master_key_id = aws_kms_key.s3_key.arn
      sse_algorithm     = "aws:kms"
    }
  }
}
</file>

<file path="infra/provisioning/modules/state/outputs.tf">
output "s3_bucket" {
  value = aws_s3_bucket.terraform_state.bucket
}

output "kms_s3_key_alias_name" {
  value = aws_kms_alias.kms_s3_key_alias.name
}
</file>

<file path="infra/provisioning/modules/state/variables.tf">
variable "environment" {
  type = string
}
</file>

<file path="infra/provisioning/modules/vpc/main.tf">
resource "aws_vpc" "vpc" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_support   = true
  enable_dns_hostnames = true

  tags = {
    Name        = "${var.environment}-vpc"
    Environment = var.environment
  }
}

resource "aws_internet_gateway" "internet_gateway" {
  vpc_id = aws_vpc.vpc.id

  tags = {
    Name        = "${var.environment}-igw"
    Environment = var.environment
  }
}

resource "aws_route_table" "route_table" {
  vpc_id = aws_vpc.vpc.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.internet_gateway.id
  }

  tags = {
    Name        = "${var.environment}-rt"
    Environment = var.environment
  }
}
</file>

<file path="infra/provisioning/modules/vpc/outputs.tf">
output "vpc_id" {
  value = aws_vpc.vpc.id
}

output "vpc_cidr_block" {
  value = aws_vpc.vpc.cidr_block
}

output "route_table_id" {
  value = aws_route_table.route_table.id
}
</file>

<file path="infra/provisioning/modules/vpc/variables.tf">
variable "environment" {
  type = string
}
</file>

<file path="infra/provisioning/production/main.tf">
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "4.2.0"
    }
  }

  backend "s3" {
    profile    = "tabnews"
    region     = "sa-east-1"
    key        = "terraform.tfstate"
    encrypt    = true
    kms_key_id = "alias/production-terraform-state"
  }
}

provider "aws" {
  region  = "sa-east-1"
  profile = "tabnews"
}

module "state" {
  source      = "../modules/state"
  environment = var.environment
}

module "vpc" {
  source      = "../modules/vpc"
  environment = var.environment
}

module "database" {
  source         = "../modules/database"
  environment    = var.environment
  vpc_id         = module.vpc.vpc_id
  vpc_cidr_block = module.vpc.vpc_cidr_block
  route_table_id = module.vpc.route_table_id

  engine_version           = "14.3"
  instance_class           = "db.t4g.medium"
  allocated_storage        = 20
  max_allocated_storage    = 100
  backup_retention_period  = 7
  skip_final_snapshot      = false
  deletion_protection      = true
  delete_automated_backups = false
}
</file>

<file path="infra/provisioning/production/outputs.tf">
output "database_db_name" {
  value = module.database.db_name
}

output "database_username" {
  value = module.database.username
}

output "database_password" {
  value     = module.database.password
  sensitive = true
}

output "database_port" {
  value = module.database.port
}

output "database_address" {
  value = module.database.address
}
</file>

<file path="infra/provisioning/production/variables.tf">
variable "region" {
  type    = string
  default = "sa-east-1"

}
variable "environment" {
  type    = string
  default = "production"
}
</file>

<file path="infra/provisioning/staging/main.tf">
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "4.2.0"
    }
  }

  backend "s3" {
    profile    = "tabnews"
    region     = "us-east-1"
    key        = "terraform.tfstate"
    encrypt    = true
    kms_key_id = "alias/staging-terraform-state"
  }
}

provider "aws" {
  region  = "us-east-1"
  profile = "tabnews"
}

module "state" {
  source      = "../modules/state"
  environment = var.environment
}

module "vpc" {
  source      = "../modules/vpc"
  environment = var.environment
}

module "database" {
  source         = "../modules/database"
  environment    = var.environment
  vpc_id         = module.vpc.vpc_id
  vpc_cidr_block = module.vpc.vpc_cidr_block
  route_table_id = module.vpc.route_table_id

  engine_version           = "14.3"
  instance_class           = "db.t4g.micro"
  allocated_storage        = 20
  max_allocated_storage    = 21
  backup_retention_period  = 0
  skip_final_snapshot      = true
  deletion_protection      = false
  delete_automated_backups = true
}
</file>

<file path="infra/provisioning/staging/outputs.tf">
output "database_db_name" {
  value = module.database.db_name
}

output "database_username" {
  value = module.database.username
}

output "database_password" {
  value     = module.database.password
  sensitive = true
}

output "database_port" {
  value = module.database.port
}

output "database_address" {
  value = module.database.address
}
</file>

<file path="infra/provisioning/staging/variables.tf">
variable "region" {
  type    = string
  default = "us-east-1"

}
variable "environment" {
  type    = string
  default = "staging"
}
</file>

<file path="infra/scripts/01-create-umami-database.sql">
CREATE DATABASE umami;
</file>

<file path="infra/scripts/config-umami.js">
/* eslint-disable no-console */
const { Client } = require('pg');

const endpoint = process.env.NEXT_PUBLIC_UMAMI_ENDPOINT;
const websiteDomain = `${process.env.NEXT_PUBLIC_WEBSERVER_HOST}:${process.env.NEXT_PUBLIC_WEBSERVER_PORT}`;
const websiteId = process.env.NEXT_PUBLIC_UMAMI_WEBSITE_ID;
const connectionString = `postgres://${process.env.POSTGRES_USER}:${process.env.POSTGRES_PASSWORD}@${process.env.POSTGRES_HOST}:${process.env.POSTGRES_PORT}/${process.env.UMAMI_DB}`;
const username = process.env.UMAMI_API_CLIENT_USERNAME || 'admin';
const password = process.env.UMAMI_API_CLIENT_PASSWORD || 'umami';

const client = new Client({
  connectionString,
  connectionTimeoutMillis: 5000,
  idleTimeoutMillis: 30000,
  allowExitOnIdle: false,
});

configUmami();

async function configUmami() {
  console.log('\n> Waiting for Umami Server to start...');
  console.log('> Endpoint:', endpoint);

  await waitForServer();

  console.log('> Creating Umami configuration...');

  const token = await fetch(`${endpoint}/api/auth/login`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      username,
      password,
    }),
  })
    .then((res) => res.json())
    .then((data) => data.token);

  console.log('> Token:', token);

  const websites = await fetch(`${endpoint}/api/websites`, {
    headers: {
      Authorization: `Bearer ${token}`,
    },
  })
    .then((res) => res.json())
    .then((data) => data.data);

  let existDevWebisite;

  if (websites.length) {
    existDevWebisite = websites.some((site) => site.id === websiteId);
  }

  await client.connect();

  if (!existDevWebisite) {
    const website = await fetch(`${endpoint}/api/websites`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({
        name: 'TabNews Dev',
        domain: websiteDomain,
      }),
    }).then((res) => res.json());

    await client.query('UPDATE website SET website_id = $1 WHERE website_id = $2;', [websiteId, website.id]);
  }

  await client.end();

  console.log('> Umami configuration created!');
}

async function waitForServer(attempts = 5) {
  try {
    return await fetch(`${endpoint}/api/heartbeat`);
  } catch (error) {
    if (attempts > 1) {
      console.log('> Umami is not ready, waiting...');
      await new Promise((resolve) => setTimeout(resolve, 1000));
      return waitForServer(attempts - 1);
    }

    console.error('🔴 Umami is not ready, exiting...');
    process.exit(1);
  }
}
</file>

<file path="infra/scripts/seed-database.js">
/* eslint-disable no-console */
const fs = require('node:fs');
const { join, resolve } = require('node:path');
const { Client } = require('pg');

const client = new Client({
  connectionString: process.env.DATABASE_URL,
  connectionTimeoutMillis: 5000,
  idleTimeoutMillis: 30000,
  allowExitOnIdle: false,
});

seedDatabase();

async function seedDatabase() {
  console.log('> Seeding database...');

  await client.connect();
  await seedDevelopmentUsers();
  await createFirewallFunctions();
  await client.end();

  console.log('\n> Database seeded!');
}

async function seedDevelopmentUsers() {
  await insertUser('admin', 'admin@admin.com', '$2a$04$v0hvAu/y6pJ17LzeCfcKG.rDStO9x5ficm2HTLZIfeDBG8oR/uQXi', [
    'create:session',
    'read:session',
    'create:content',
    'create:content:text_root',
    'create:content:text_child',
    'update:content',
    'update:user',
    'update:user:others',
    'ban:user',
    'read:migration',
    'create:migration',
    'update:content:others',
    'create:recovery_token:username',
    'read:votes:others',
    'read:user:list',
    'read:firewall',
    'review:firewall',
  ]);
  await insertUser('user', 'user@user.com', '$2a$04$v0hvAu/y6pJ17LzeCfcKG.rDStO9x5ficm2HTLZIfeDBG8oR/uQXi', [
    'create:session',
    'read:session',
    'create:content',
    'create:content:text_root',
    'create:content:text_child',
    'update:content',
    'update:user',
  ]);

  console.log('------------------------------');
  console.log('> You can now Login to TabNews using the following credentials:');
  console.log('> "admin@admin.com" + "password"');
  console.log('> "user@user.com" + "password"');
  console.log('------------------------------');

  async function insertUser(username, email, passwordHash, features) {
    try {
      const query = {
        text: 'INSERT INTO users (username, email, password, features) VALUES($1, $2, $3, $4) RETURNING *;',
        values: [username, email, passwordHash, features],
      };

      await client.query(query);
    } catch (error) {
      // Probably there's a better way to do this
      if (!error.detail.includes('already exists')) {
        throw error;
      }
    }
  }
}

async function createFirewallFunctions() {
  console.log('\n> Creating Firewall functions...');
  const proceduresPath = join(resolve('.'), 'infra', 'stored-procedures');
  const procedures = fs.readdirSync(proceduresPath);

  for (const procedureFile of procedures) {
    const procedureQuery = fs.readFileSync(`${proceduresPath}/${procedureFile}`, 'utf8');
    await client.query(procedureQuery);
  }
  console.log('> Firewall functions created!');
}
</file>

<file path="infra/scripts/wait-for-db-connection-ready.js">
/* eslint-disable no-console */
const retry = require('async-retry');
const { exec } = require('node:child_process');

/**
 * Check Postgres database connection status
 * This is a function that'll execute health check pg_isready command until postgres is accepting connection
 *
 * References: https://www.postgresql.org/docs/current/app-pg-isready.html
 */
const healthCheckDB = async () => {
  return await retry(
    async (bail, tries) => {
      if (tries > 25) {
        console.log(
          `> Trying to connect to Database #${tries}. Are you running the postgres container? Run npm run services:up to start database service`,
        );
      }

      return await new Promise((resolve, reject) => {
        exec(`docker exec postgres-dev pg_isready`, (error, stdout) => {
          const healthCheckStatus = stdout;
          console.log('health check postgres: ', healthCheckStatus);

          if (healthCheckStatus?.indexOf('accepting connections') != -1) {
            resolve();
            return;
          }

          const reason = 'Failed to connect to database. A new attempt will be made in 3 seconds ...';
          console.log(reason);

          reject(reason);
        });
      });
    },
    {
      forever: true,
      minTimeout: 3000,
      maxTimeout: 3000,
      factor: 1.1,
    },
  );
};

(async () => {
  await healthCheckDB();
})();
</file>

<file path="infra/stored-procedures/firewall-create-content-text-child.pgsql">
CREATE OR REPLACE FUNCTION firewall_create_content_text_child(clientIp inet) RETURNS boolean AS $$
DECLARE
  contents_count integer;
BEGIN
  contents_count := (
    SELECT
      COUNT(*)
    FROM
      events
    WHERE
      originator_ip = clientIp
      AND type = 'create:content:text_child'
      AND created_at > NOW() - INTERVAL '5 seconds'
  );

  IF contents_count >= 2 THEN
    RETURN false;
  ELSE
    RETURN true;
  END IF;

END;
$$ LANGUAGE plpgsql;
</file>

<file path="infra/stored-procedures/firewall-create-content-text-root.pgsql">
CREATE OR REPLACE FUNCTION firewall_create_content_text_root(clientIp inet) RETURNS boolean AS $$
DECLARE
  contents_count integer;
BEGIN
  contents_count := (
    SELECT
      COUNT(*)
    FROM
      events
    WHERE
      originator_ip = clientIp
      AND type = 'create:content:text_root'
      AND created_at > NOW() - INTERVAL '5 seconds'
  );

  IF contents_count >= 2 THEN
    RETURN false;
  ELSE
    RETURN true;
  END IF;

END;
$$ LANGUAGE plpgsql;
</file>

<file path="infra/stored-procedures/firewall-create-user.pgsql">
CREATE OR REPLACE FUNCTION firewall_create_user(clientIp inet) RETURNS boolean AS $$
DECLARE
  users_count integer;
BEGIN
  users_count := (
    SELECT
      COUNT(*)
    FROM
      events
    WHERE
      originator_ip = clientIp
      AND type = 'create:user'
      AND created_at > NOW() - INTERVAL '5 seconds'
  );

  IF users_count >= 2 THEN
    RETURN false;
  ELSE
    RETURN true;
  END IF;

END;
$$ LANGUAGE plpgsql;
</file>

<file path="infra/database.js">
import retry from 'async-retry';
import { Client, Pool } from 'pg';
import snakeize from 'snakeize';

import { ServiceError } from 'errors';
import logger from 'infra/logger.js';
import webserver from 'infra/webserver.js';

const configurations = {
  user: process.env.POSTGRES_USER,
  host: process.env.POSTGRES_HOST,
  database: process.env.POSTGRES_DB,
  password: process.env.POSTGRES_PASSWORD,
  port: process.env.POSTGRES_PORT,
  connectionTimeoutMillis: 10_000,
  idleTimeoutMillis: 30000,
  max: 3,
  ssl: {
    rejectUnauthorized: false,
  },
  allowExitOnIdle: true,
};

if (!webserver.isServerlessRuntime) {
  configurations.max = 30;

  // https://github.com/filipedeschamps/tabnews.com.br/issues/84
  delete configurations.ssl;
}

const cache = {
  pool: null,
  maxConnections: null,
  reservedConnections: null,
  openedConnections: null,
  openedConnectionsLastUpdate: null,
  poolQueryCount: 0,
};

async function query(query, options = {}) {
  let client;
  cache.poolQueryCount += 1;

  try {
    client = options.transaction ? options.transaction : await tryToGetNewClientFromPool();
    return await client.query(query);
  } catch (error) {
    throw parseQueryErrorAndLog(error, query);
  } finally {
    if (client && !options.transaction) {
      const tooManyConnections = await checkForTooManyConnections(client);

      client.release(tooManyConnections && webserver.isServerlessRuntime);
    }
  }
}

async function tryToGetNewClientFromPool() {
  const clientFromPool = await retry(newClientFromPool, {
    retries: webserver.isBuildTime ? 12 : 1,
    minTimeout: 150,
    maxTimeout: 5000,
    factor: 2,
    onRetry: (error, attempt) => {
      const pool = cache.pool
        ? {
            totalCount: cache.pool.totalCount,
            idleCount: cache.pool.idleCount,
            waitingCount: cache.pool.waitingCount,
          }
        : null;
      const errorObject = new ServiceError({
        message: error.message,
        stack: error.stack,
        cause: error.cause,
        context: {
          attempt,
          databaseCache: {
            ...cache,
            pool,
          },
        },
        errorLocationCode: 'INFRA:DATABASE:GET_NEW_CLIENT_FROM_POOL',
      });
      logger.error(errorObject);
    },
  });

  return clientFromPool;

  async function newClientFromPool() {
    if (!cache.pool) {
      cache.pool = new Pool(configurations);
    }

    return await cache.pool.connect();
  }
}

async function checkForTooManyConnections(client) {
  if (webserver.isBuildTime || cache.pool?.waitingCount) return false;

  const currentTime = new Date().getTime();
  const openedConnectionsMaxAge = 5000;
  const maxConnectionsTolerance = 0.8;

  try {
    if (cache.maxConnections === null || cache.reservedConnections === null) {
      const [maxConnections, reservedConnections] = await getConnectionLimits();
      cache.maxConnections = maxConnections;
      cache.reservedConnections = reservedConnections;
    }

    if (cache.openedConnections === null || currentTime - cache.openedConnectionsLastUpdate > openedConnectionsMaxAge) {
      const openedConnections = await getOpenedConnections();
      cache.openedConnections = openedConnections;
      cache.openedConnectionsLastUpdate = currentTime;
    }
  } catch (error) {
    if (error.code === 'ECONNRESET') {
      return true;
    }
    throw error;
  }

  if (cache.openedConnections > (cache.maxConnections - cache.reservedConnections) * maxConnectionsTolerance) {
    return true;
  }

  return false;

  async function getConnectionLimits() {
    const [maxConnectionsResult, reservedConnectionResult] = await client.query(
      'SHOW max_connections; SHOW superuser_reserved_connections;',
    );
    return [
      maxConnectionsResult.rows[0].max_connections,
      reservedConnectionResult.rows[0].superuser_reserved_connections,
    ];
  }

  async function getOpenedConnections() {
    const openConnectionsResult = await client.query({
      text: 'SELECT numbackends as opened_connections FROM pg_stat_database where datname = $1',
      values: [process.env.POSTGRES_DB],
    });
    return openConnectionsResult.rows[0].opened_connections;
  }
}

async function getNewClient() {
  try {
    const client = await tryToGetNewClient();
    return client;
  } catch (error) {
    const errorObject = new ServiceError({
      message: error.message,
      errorLocationCode: 'INFRA:DATABASE:GET_NEW_CONNECTED_CLIENT',
      stack: new Error().stack,
    });
    logger.error(snakeize(errorObject));
    throw errorObject;
  }
}

async function tryToGetNewClient() {
  const client = await retry(newClient, {
    retries: 50,
    minTimeout: 0,
    factor: 2,
  });

  return client;

  // You need to close the client when you are done with it
  // using the client.end() method.
  async function newClient() {
    const client = new Client(configurations);
    await client.connect();
    return client;
  }
}

const UNIQUE_CONSTRAINT_VIOLATION = '23505';
const SERIALIZATION_FAILURE = '40001';
const UNDEFINED_FUNCTION = '42883';

function parseQueryErrorAndLog(error, query) {
  const expectedErrorsCode = [UNIQUE_CONSTRAINT_VIOLATION, SERIALIZATION_FAILURE];

  if (!webserver.isServerlessRuntime) {
    expectedErrorsCode.push(UNDEFINED_FUNCTION);
  }

  const pool = cache.pool
    ? {
        totalCount: cache.pool.totalCount,
        idleCount: cache.pool.idleCount,
        waitingCount: cache.pool.waitingCount,
      }
    : null;

  const errorToReturn = new ServiceError({
    message: error.message,
    context: {
      query: query.text,
      databaseCache: { ...cache, pool },
    },
    errorLocationCode: 'INFRA:DATABASE:QUERY',
    databaseErrorCode: error.code,
  });

  if (!expectedErrorsCode.includes(error.code)) {
    logger.error(snakeize(errorToReturn));
  }

  return errorToReturn;
}

async function transaction() {
  return await tryToGetNewClientFromPool();
}

export default Object.freeze({
  query,
  getNewClient,
  transaction,
  errorCodes: {
    UNIQUE_CONSTRAINT_VIOLATION,
    SERIALIZATION_FAILURE,
    UNDEFINED_FUNCTION,
  },
});
</file>

<file path="infra/docker-compose.development.yml">
name: 'tabnews'
services:
  postgres_dev:
    container_name: 'postgres-dev'
    image: 'postgres:14.7-alpine'
    env_file:
      - ../.env
    ports:
      - '${POSTGRES_PORT}:5432'
    volumes:
      - postgres_data:/data/postgres
      - ./scripts:/docker-entrypoint-initdb.d
    restart: unless-stopped
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}']
      interval: 5s
      timeout: 5s
      retries: 5
  mailcatcher:
    container_name: mailcatcher
    image: sj26/mailcatcher
    expose:
      - '${EMAIL_SMTP_PORT}'
      - '${EMAIL_HTTP_PORT}'
    ports:
      - '${EMAIL_SMTP_PORT}:1025'
      - '${EMAIL_HTTP_PORT}:1080'
  umami:
    image: ghcr.io/umami-software/umami:postgresql-latest
    ports:
      - '${UMAMI_PORT}:3000'
    environment:
      DATABASE_URL: postgresql://$POSTGRES_USER:$POSTGRES_PASSWORD@postgres_dev:5432/$UMAMI_DB
    depends_on:
      postgres_dev:
        condition: service_healthy
    init: true
    restart: unless-stopped
volumes:
  postgres_data:
</file>

<file path="infra/email.js">
import { waitUntil } from '@vercel/functions';
import retry from 'async-retry';
import nodemailer from 'nodemailer';
import { Resend } from 'resend';

import { ServiceError } from 'errors';
import logger from 'infra/logger.js';
import webserver from 'infra/webserver.js';

const retriesPerService = parseInt(process.env.RETRIES_PER_EMAIL_SERVICE) || 1;
const timeoutInSeconds = process.env.EMAIL_ATTEMPT_TIMEOUT_IN_SECONDS || 40;

const transporterConfigs = [];
let configNumber = '';

while (process.env['EMAIL_USER' + configNumber]) {
  transporterConfigs.push({
    host: process.env['EMAIL_SMTP_HOST' + configNumber],
    port: process.env['EMAIL_SMTP_PORT' + configNumber],
    secure: webserver.isServerlessRuntime,
    auth: {
      user: process.env['EMAIL_USER' + configNumber],
      pass: process.env['EMAIL_PASSWORD' + configNumber],
    },
  });

  configNumber = transporterConfigs.length + 1;
}

const transporters = transporterConfigs.map((config) => {
  if (config.auth.user === 'resend') {
    const resend = new Resend(config.auth.pass);

    return {
      sendMail: async (mailOptions) => {
        const { data, error } = await resend.emails.send(mailOptions);

        if (error) {
          throw error;
        }

        return data;
      },
    };
  }

  return nodemailer.createTransport(config);
});

const retries = (retriesPerService + 1) * transporters.length - 1;

// Intentionally async for future compatibility (e.g., switching to a queue system)
// eslint-disable-next-line require-await
async function triggerSend(params) {
  waitUntil(
    send(params).catch(() => {
      // The error has already been logged in the send function
    }),
  );
}

async function send({ from, to, subject, html, text }) {
  const mailOptions = {
    from: from,
    to: to,
    subject: subject,
    html: html,
    text: text,
  };

  try {
    await retry(tryToSendEmail, {
      retries,
      minTimeout: 0,
      maxTimeout: 0,
      factor: 0,
      randomize: false,
      onRetry: logError,
    });
  } catch (error) {
    logError(error, retries + 1);
    throw error;
  }

  async function tryToSendEmail(bail, attempt) {
    const configIndex = (attempt - 1) % transporters.length;
    const transporter = transporters[configIndex];

    await Promise.race([
      transporter.sendMail(mailOptions),
      new Promise((_, reject) =>
        setTimeout(
          () => reject(new Error(`Timeout: Email sending took longer than ${timeoutInSeconds} second(s)`)),
          timeoutInSeconds * 1000,
        ),
      ),
    ]);
  }

  function logError(error, attempt) {
    const configIndex = (attempt - 1) % transporters.length;

    const errorObject = new ServiceError({
      message: error.message,
      action: 'Verifique se o serviço de emails está disponível.',
      stack: error.stack,
      context: {
        attempt,
        emailSmtpHost: transporterConfigs[configIndex].host,
        from: mailOptions.from,
        to: mailOptions.to,
        subject: mailOptions.subject,
      },
      errorLocationCode: 'INFRA:EMAIl:SEND',
    });
    logger.error(errorObject);
  }
}

export default Object.freeze({
  send,
  triggerSend,
});
</file>

<file path="infra/logger.js">
import { getLogger } from '@tabnews/infra';

export default getLogger({
  nestedKey: 'payload',
  redact: {
    paths: [
      'password',
      'email',
      'context.user.password',
      'context.user.email',
      'context.user.description',
      'context.session.token',
    ],
    remove: true,
  },
});
</file>

<file path="infra/migrator.js">
import migrationRunner from 'node-pg-migrate';
import { join, resolve } from 'node:path';

import database from 'infra/database.js';
import logger from 'infra/logger.js';

const defaultConfigurations = {
  dir: join(resolve('.'), 'infra', 'migrations'),
  direction: 'up',
  migrationsTable: 'pgmigrations',
  verbose: true,
  log: (log) => {
    logger.info({
      migration: log,
    });
  },
};

async function listPendingMigrations() {
  const databaseClient = await database.getNewClient();

  try {
    const pendingMigrations = await migrationRunner({
      ...defaultConfigurations,
      dbClient: databaseClient,
      dryRun: true,
    });

    return pendingMigrations;
  } finally {
    await databaseClient.end();
  }
}

async function runPendingMigrations() {
  const databaseClient = await database.getNewClient();

  try {
    const migratedMigrations = await migrationRunner({
      ...defaultConfigurations,
      dbClient: databaseClient,
      dryRun: false,
    });

    return migratedMigrations;
  } finally {
    await databaseClient.end();
  }
}

const migrator = {
  listPendingMigrations,
  runPendingMigrations,
};

export default migrator;
</file>

<file path="infra/rate-limit.js">
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

import { ServiceError } from 'errors';
import webserver from 'infra/webserver.js';
import ip from 'models/ip.js';

async function check(request) {
  if (!process.env.UPSTASH_REDIS_REST_URL || !process.env.UPSTASH_REDIS_REST_TOKEN) {
    if (!webserver.isServerlessRuntime) {
      return { success: true };
    }

    throw new ServiceError({
      message: 'Variáveis de ambiente UPSTASH_REDIS_REST_URL ou UPSTASH_REDIS_REST_TOKEN não encontradas.',
      action:
        'Configure as variáveis de ambiente UPSTASH_REDIS_REST_URL e UPSTASH_REDIS_REST_TOKEN para habilitar o serviço de rate-limiting.',
      context: {
        upstashRedisRestUrl: process.env.UPSTASH_REDIS_REST_URL ? true : false,
        upstashRedisRestToken: process.env.UPSTASH_REDIS_REST_TOKEN ? true : false,
      },
      errorLocationCode: 'MIDDLEWARE:RATE_LIMIT:CHECK:ENV_MISSING',
    });
  }

  const realIp = ip.extractFromRequest(request);
  const method = request.method;
  const path = request.nextUrl.pathname;
  const limit = getLimit(method, path, realIp);
  if (!limit) return { success: true };

  let timeout;

  try {
    const generalRateLimit = new Ratelimit({
      redis: Redis.fromEnv(),
      limiter: Ratelimit.slidingWindow(limit.requests, limit.window),
    });

    const timeoutPromise = new Promise((_, reject) => {
      timeout = setTimeout(() => {
        reject({ message: 'Upstash não respondeu dentro de 4s.' });
      }, 4000);
    });

    return await Promise.race([generalRateLimit.limit(limit.identifier), timeoutPromise]);
  } catch (error) {
    throw new ServiceError({
      message: error.message,
      action: 'Verifique se o serviço Upstash está disponível.',
      stack: error.stack,
      context: {
        ip,
        method,
        path,
      },
      errorLocationCode: 'MIDDLEWARE:RATE_LIMIT:CHECK',
    });
  } finally {
    clearTimeout(timeout);
  }
}

function getLimit(method, path, ip) {
  const defaultLimits = {
    rateLimitPaths: [],
    general: {
      requests: 1000,
      window: '5 m',
    },
    'PATCH /api/v1/activation': {
      requests: 50,
      window: '30 m',
    },
    'POST /api/v1/contents': {
      requests: 50,
      window: '30 m',
    },
    'POST /api/v1/recovery': {
      requests: 50,
      window: '30 m',
    },
    'PATCH /api/v1/recovery': {
      requests: 50,
      window: '30 m',
    },
    'DELETE /api/v1/sessions': {
      requests: 50,
      window: '30 m',
    },
    'POST /api/v1/sessions': {
      requests: 50,
      window: '30 m',
    },
    'POST /api/v1/users': {
      requests: 50,
      window: '30 m',
    },
  };

  const configurationFromEnvironment = process.env.RATE_LIMITS ? JSON.parse(process.env.RATE_LIMITS) : {};
  const configuration = { ...defaultLimits, ...configurationFromEnvironment };

  if (!configuration.rateLimitPaths.find((rateLimitPath) => path?.startsWith(rateLimitPath))) {
    return;
  }

  const limitKey = configuration[`${method} ${path}`] ? `${method} ${path}` : 'general';

  const limit = {
    requests: configuration[limitKey].requests,
    window: configuration[limitKey].window,
    identifier: limitKey === 'general' ? `${ip}` : `${ip}:${method}:${path}`,
  };

  return limit;
}

export default Object.freeze({
  check,
});
</file>

<file path="infra/under-maintenance.js">
import logger from 'infra/logger';
import webserver from 'infra/webserver';

let underMaintenance;

try {
  underMaintenance = JSON.parse(process.env.UNDER_MAINTENANCE || '{}');
} catch (error) {
  if (webserver.isBuildTime) {
    logger.error('Error parsing UNDER_MAINTENANCE', { error });
  }
  underMaintenance = {};
}

const methodsAndPaths = underMaintenance.methodsAndPaths || [];
const message = underMaintenance.message || 'Funcionalidade em manutenção.';
const action = underMaintenance.action || 'Tente novamente mais tarde.';
const statusCode = underMaintenance.statusCode || 503;

function check(request) {
  if (methodsAndPaths.length === 0) return;

  const method = request.method;
  const path = request.nextUrl.pathname;

  const isUnderMaintenance = methodsAndPaths.some((methodAndPath) =>
    new RegExp(methodAndPath).test(`${method} ${path}`),
  );

  if (isUnderMaintenance) {
    return {
      status: statusCode,
      body: JSON.stringify({
        message,
        action,
        error_location_code: 'INFRA:UNDER_MAINTENANCE:CHECK:IS_UNDER_MAINTENANCE',
      }),
    };
  }
}

export default Object.freeze({
  check,
});
</file>

<file path="infra/webserver.js">
const isServerlessRuntime = !!process.env.NEXT_PUBLIC_VERCEL_ENV;

const isBuildTime = process.env.NEXT_PHASE === 'phase-production-build';

const isProduction = process.env.NEXT_PUBLIC_VERCEL_ENV === 'production';

const host = isProduction
  ? `https://${process.env.NEXT_PUBLIC_WEBSERVER_HOST}`
  : isServerlessRuntime
    ? `https://${process.env.NEXT_PUBLIC_VERCEL_URL}`
    : `http://${process.env.NEXT_PUBLIC_WEBSERVER_HOST}:${process.env.NEXT_PUBLIC_WEBSERVER_PORT}`;

export default Object.freeze({
  host,
  isBuildTime,
  isProduction,
  isServerlessRuntime,
});
</file>

<file path="models/firewall/event-types.js">
const firewall = ['firewall:block_contents:text_child', 'firewall:block_contents:text_root', 'firewall:block_users'];

const review = [
  'moderation:block_users',
  'moderation:block_contents:text_root',
  'moderation:block_contents:text_child',
  'moderation:unblock_users',
  'moderation:unblock_contents:text_root',
  'moderation:unblock_contents:text_child',
];

const reviewByAction = {
  confirm: {
    'firewall:block_users': 'moderation:block_users',
    'firewall:block_contents:text_root': 'moderation:block_contents:text_root',
    'firewall:block_contents:text_child': 'moderation:block_contents:text_child',
  },
  undo: {
    'firewall:block_users': 'moderation:unblock_users',
    'firewall:block_contents:text_root': 'moderation:unblock_contents:text_root',
    'firewall:block_contents:text_child': 'moderation:unblock_contents:text_child',
  },
};

export default Object.freeze({
  firewall,
  review,
  reviewByAction,
});
</file>

<file path="models/firewall/find.js">
import { NotFoundError } from 'errors';
import database from 'infra/database';
import content from 'models/content';
import user from 'models/user';

import eventTypes from './event-types';

async function findByEventId(eventId) {
  const relatedEvents = await findAllRelatedEvents(eventId);
  const foundRequestedEvent = relatedEvents.find((event) => event.id === eventId);

  if (!foundRequestedEvent || !eventTypes.firewall.includes(foundRequestedEvent.type)) {
    throw new NotFoundError({
      message: `O id "${eventId}" não foi encontrado no sistema.`,
      action: 'Verifique se o "id" está digitado corretamente.',
      stack: new Error().stack,
      errorLocationCode: 'MODEL:FIREWALL:FIND_BY_EVENT_ID:NOT_FOUND',
      key: 'id',
    });
  }

  const affectedData = await getAffectedData(relatedEvents);

  return {
    affected: affectedData,
    events: relatedEvents,
  };
}

async function getAffectedData(events) {
  const usersIds = new Set();
  const contentsIds = new Set();
  const affectedData = {};

  for (const event of events) {
    event.metadata.users?.forEach((userId) => usersIds.add(userId));
    event.metadata.contents?.forEach((contentId) => contentsIds.add(contentId));
  }

  if (contentsIds.size) {
    affectedData.contents = await content.findAll({
      where: {
        id: Array.from(contentsIds),
      },
    });

    for (const content of affectedData.contents) {
      usersIds.add(content.owner_id);
    }
  }

  affectedData.users = await user.findAll({
    where: {
      id: Array.from(usersIds),
    },
  });

  return affectedData;
}

async function findAllRelatedEvents(id) {
  const query = {
    text: `
    WITH RECURSIVE related_events AS (
      SELECT
        id,
        jsonb_array_elements_text(metadata->'contents') AS content_id,
        jsonb_array_elements_text(metadata->'users') AS user_id
      FROM
        events
      WHERE
        id = $1

    UNION

      SELECT
        e.id,
        jsonb_array_elements_text(e.metadata->'contents') AS content_id,
        jsonb_array_elements_text(e.metadata->'users') AS user_id
      FROM
        events e
      INNER JOIN related_events ON
        e.metadata->'contents' ? related_events.content_id OR
        e.metadata->'users' ? related_events.user_id
    )

    SELECT DISTINCT
      events.*
    FROM
      events
    INNER JOIN related_events ON
      events.id = related_events.id
    ;`,
    values: [id],
  };

  const results = await database.query(query);
  return results.rows;
}

export default Object.freeze({
  findAllRelatedEvents,
  findByEventId,
});
</file>

<file path="models/firewall/index.js">
import find from './find';
import review from './review';
import rules from './rules';

export default Object.freeze({
  ...find,
  ...review,
  ...rules,
});
</file>

<file path="models/firewall/review.js">
import { NotFoundError, ValidationError } from 'errors';
import database from 'infra/database';
import balance from 'models/balance';
import content from 'models/content';
import event from 'models/event';
import user from 'models/user';

import eventTypes from './event-types';
import firewallFind from './find';

const reviewFunctions = {
  'moderation:block_users': confirmBlockUsers,
  'moderation:block_contents:text_root': confirmBlockContents,
  'moderation:block_contents:text_child': confirmBlockContents,
  'moderation:unblock_users': unblockUsers,
  'moderation:unblock_contents:text_root': unblockContents,
  'moderation:unblock_contents:text_child': unblockContents,
};

async function reviewEvent({ action, eventId, originatorIp, originatorUserId }) {
  const relatedEvents = await validateAndGetRelatedEventsToReview(eventId);

  const users = new Set();
  const contents = new Set();

  for (const firewallEvent of relatedEvents) {
    firewallEvent.metadata.users?.forEach((userId) => users.add(userId));
    firewallEvent.metadata.contents?.forEach((contentId) => contents.add(contentId));
  }

  const metadata = {
    related_events: relatedEvents.map((e) => e.id),
    users: users.size ? Array.from(users) : undefined,
    contents: contents.size ? Array.from(contents) : undefined,
  };

  const eventType = eventTypes.reviewByAction[action][relatedEvents[0].type];

  const transaction = await database.transaction();

  try {
    await transaction.query('BEGIN');

    const createdEvent = await event.create(
      {
        type: eventType,
        originator_user_id: originatorUserId,
        originator_ip: originatorIp,
        metadata,
      },
      {
        transaction,
      },
    );

    const events = [...relatedEvents, createdEvent];

    const affected = await reviewFunctions[eventType]({
      transaction,
      event: createdEvent,
    });

    await transaction.query('COMMIT');

    return {
      affected,
      events,
    };
  } catch (error) {
    await transaction.query('ROLLBACK');
    throw error;
  } finally {
    await transaction.release();
  }
}

async function validateAndGetRelatedEventsToReview(eventId) {
  const relatedEvents = await firewallFind.findAllRelatedEvents(eventId);

  if (!relatedEvents.length) {
    throw new NotFoundError({
      message: `O id "${eventId}" não foi encontrado no sistema.`,
      action: 'Verifique se o "id" está digitado corretamente.',
      stack: new Error().stack,
      errorLocationCode: 'MODEL:FIREWALL:VALIDATE_AND_GET_FIREWALL_EVENT_TO_REVIEW:NOT_FOUND',
      key: 'id',
    });
  }

  const reviewingEvent = relatedEvents.find((e) => eventTypes.review.includes(e.type));

  if (reviewingEvent) {
    throw new ValidationError({
      message: 'Você está tentando analisar um evento que já foi analisado.',
      action: 'Utilize um "id" que aponte para um evento de firewall que ainda não foi analisado.',
      stack: new Error().stack,
      errorLocationCode: 'MODEL:FIREWALL:VALIDATE_AND_GET_FIREWALL_EVENT_TO_REVIEW:EVENT_ALREADY_REVIEWED',
      key: 'id',
    });
  }

  return relatedEvents;
}

async function confirmBlockUsers(options) {
  const affectedUsers = await user.addFeatures(options.event.metadata.users, ['nuked'], {
    ...options,
    withBalance: true,
    ignoreUpdatedAt: true,
  });
  return {
    users: affectedUsers,
  };
}

async function confirmBlockContents(options) {
  const affectedContents = await content.confirmFirewallStatus(options.event.metadata.contents, options);

  const usersIds = new Set();

  for (const content of affectedContents) {
    usersIds.add(content.owner_id);
  }

  let affectedUsers = [];

  if (usersIds.size) {
    affectedUsers = await user.findAll(
      {
        where: {
          id: Array.from(usersIds),
        },
      },
      options,
    );
  }

  return {
    contents: affectedContents,
    users: affectedUsers,
  };
}

async function unblockUsers(options) {
  const users = await user.findAll(
    {
      where: {
        id: options.event.metadata.users,
      },
    },
    options,
  );
  const inactiveUsers = [];
  const activeUsers = [];

  for (const userData of users) {
    if (userData.features.length === 0 || (userData.features.length === 1 && userData.features[0] === 'nuked')) {
      inactiveUsers.push(userData.id);
    } else {
      activeUsers.push(userData.id);
    }
  }

  const affectedUsers = [];

  const updateOptions = {
    ...options,
    withBalance: true,
    ignoreUpdatedAt: true,
  };

  if (activeUsers.length) {
    const updatedUsers = await user.addFeatures(activeUsers, ['create:session', 'read:session'], updateOptions);
    affectedUsers.push(...updatedUsers);
  }
  if (inactiveUsers.length) {
    const updatedUsers = await user.addFeatures(inactiveUsers, ['read:activation_token'], updateOptions);
    affectedUsers.push(...updatedUsers);
  }

  return {
    users: affectedUsers,
  };
}

async function unblockContents(options) {
  const affectedContents = await content.undoFirewallStatus(options.event.metadata.contents, options);

  const balanceOperations = await balance.findAllByOriginatorId(options.event.metadata.related_events, options);

  for (const operation of balanceOperations) {
    await balance.undo(operation, options);
  }

  const usersIds = new Set();

  for (const content of affectedContents) {
    usersIds.add(content.owner_id);
  }

  let affectedUsers = [];

  if (usersIds.size) {
    affectedUsers = await user.findAll(
      {
        where: {
          id: Array.from(usersIds),
        },
      },
      options,
    );
  }

  return {
    contents: affectedContents,
    users: affectedUsers,
  };
}

export default Object.freeze({
  reviewEvent,
});
</file>

<file path="models/firewall/rules.js">
import { TooManyRequestsError } from 'errors';
import database from 'infra/database.js';
import content from 'models/content';
import event from 'models/event.js';
import notification from 'models/notification';

const rules = {
  'create:user': createUserRule,
  'create:content:text_root': createContentTextRootRule,
  'create:content:text_child': createContentTextChildRule,
};

function canRequest(ruleId) {
  return async function (request, response, next) {
    try {
      await rules[ruleId](request.context);
      return next();
    } catch (error) {
      // Pass if database's stored procedure is not yet deployed
      if (error.databaseErrorCode === database.errorCodes.UNDEFINED_FUNCTION) {
        return next();
      }

      throw error;
    }
  };
}

async function createUserRule(context) {
  const results = await database.query({
    text: 'select firewall_create_user($1)',
    values: [context.clientIp],
  });

  const pass = results.rows[0].firewall_create_user;

  if (!pass) {
    await createUserRuleSideEffect(context);

    throw new TooManyRequestsError({
      message:
        'Identificamos a criação de muitos usuários em um curto período, então usuários criados recentemente podem ter sido desativados.',
    });
  }
}

async function createUserRuleSideEffect(context) {
  const results = await database.query({
    text: 'select * from firewall_create_user_side_effect($1)',
    values: [context.clientIp],
  });

  const affectedUsersIds = results.rows.map((user) => user.id);

  const createdEvent = await event.create({
    type: 'firewall:block_users',
    originator_user_id: context.user.id,
    originator_ip: context.clientIp,
    metadata: {
      from_rule: 'create:user',
      users: affectedUsersIds,
    },
  });

  await sendUserNotification(results.rows, createdEvent);
}

function sendUserNotification(userRows, event) {
  const notifications = [];

  for (const user of userRows) {
    notifications.push(
      notification.sendUserDisabled({
        eventId: event.id,
        user: user,
      }),
    );
  }

  return Promise.allSettled(notifications);
}

async function createContentTextRootRule(context) {
  const results = await database.query({
    text: 'select firewall_create_content_text_root($1)',
    values: [context.clientIp],
  });

  const pass = results.rows[0].firewall_create_content_text_root;

  if (!pass) {
    await createContentTextRootRuleSideEffect(context);

    throw new TooManyRequestsError({
      message:
        'Identificamos a criação de muitas publicações em um curto período, então publicações criadas recentemente podem ter sido removidas.',
    });
  }
}

async function createContentTextRootRuleSideEffect(context) {
  const results = await database.query({
    text: 'select * from firewall_create_content_text_root_side_effect($1)',
    values: [context.clientIp],
  });

  const affectedContentsIds = results.rows.map((row) => row.id);

  const createdEvent = await event.create({
    type: 'firewall:block_contents:text_root',
    originator_user_id: context.user.id,
    originator_ip: context.clientIp,
    metadata: {
      from_rule: 'create:content:text_root',
      contents: affectedContentsIds,
    },
  });

  await Promise.allSettled([
    undoContentsTabcoins(results.rows, createdEvent),
    sendContentTextNotification(results.rows, createdEvent),
  ]);
}

async function createContentTextChildRule(context) {
  const results = await database.query({
    text: 'select firewall_create_content_text_child($1)',
    values: [context.clientIp],
  });

  const pass = results.rows[0].firewall_create_content_text_child;

  if (!pass) {
    await createContentTextChildRuleSideEffect(context);

    throw new TooManyRequestsError({
      message:
        'Identificamos a criação de muitos comentários em um curto período, então comentários criados recentemente podem ter sido removidos.',
    });
  }
}

async function createContentTextChildRuleSideEffect(context) {
  const results = await database.query({
    text: 'select * from firewall_create_content_text_child_side_effect($1)',
    values: [context.clientIp],
  });

  const affectedContentsIds = results.rows.map((row) => row.id);

  const createdEvent = await event.create({
    type: 'firewall:block_contents:text_child',
    originator_user_id: context.user.id,
    originator_ip: context.clientIp,
    metadata: {
      from_rule: 'create:content:text_child',
      contents: affectedContentsIds,
    },
  });

  await Promise.allSettled([
    undoContentsTabcoins(results.rows, createdEvent),
    sendContentTextNotification(results.rows, createdEvent),
  ]);
}

async function undoContentsTabcoins(contentRows, createdEvent) {
  for (const contentObject of contentRows) {
    await content.creditOrDebitTabCoins(
      {
        ...contentObject,
        status: contentObject.status_before_update,
      },
      contentObject,
      {
        eventId: createdEvent.id,
      },
    );
  }
}

function sendContentTextNotification(contentRows, event) {
  const usersToNotify = {};

  for (const content of contentRows) {
    if (content.owner_id !== event.originator_user_id) {
      if (usersToNotify[content.owner_id]) {
        usersToNotify[content.owner_id].push(content);
      } else {
        usersToNotify[content.owner_id] = [content];
      }
    }
  }

  const notifications = [];

  for (const [userId, contents] of Object.entries(usersToNotify)) {
    notifications.push(
      notification.sendContentDeletedToUser({
        contents: contents,
        eventId: event.id,
        userId: userId,
      }),
    );
  }

  return Promise.allSettled(notifications);
}

export default Object.freeze({
  canRequest,
});
</file>

<file path="models/transactional/components/default-layout.jsx">
import { Body, Container, Head, Heading, Html, Img, Preview, Text } from '@react-email/components';

export const DefaultLayoutText = ({ username, content }) => {
  return `Olá, ${username}!

${content}

Atenciosamente, 
Equipe TabNews 
Rua Antônio da Veiga, 495, Blumenau, SC, 89012-500`;
};

export const DefaultLayout = ({ username, previewText, children }) => (
  <Html>
    <Head />
    <Preview>{previewText}</Preview>
    <Body style={main}>
      <Container style={container}>
        <Heading style={h1}>Olá, {username}!</Heading>

        {children}

        <Text style={footer}>
          Atenciosamente, <br />
          Equipe TabNews <br />
          Rua Antônio da Veiga, 495, Blumenau, SC, 89012-500
        </Text>
        <Img src="https://www.tabnews.com.br/favicon.png" width="32" height="32" alt="TabNews" />
      </Container>
    </Body>
  </Html>
);

const main = {
  backgroundColor: '#ffffff',
  fontFamily:
    "-apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif",
};

const container = {
  paddingLeft: '12px',
  paddingRight: '12px',
  margin: '0 auto',
};

const h1 = {
  color: '#333',
  fontSize: '24px',
  fontWeight: 'bold',
  margin: '40px 0',
  padding: '0',
};

const footer = {
  color: '#898989',
  fontSize: '12px',
  lineHeight: '22px',
  marginTop: '24px',
  marginBottom: '4px',
};
</file>

<file path="models/transactional/components/index.js">
export { DefaultLayout, DefaultLayoutText } from './default-layout';
export { Link, LinkText } from './link';
export { Text } from './text';
</file>

<file path="models/transactional/components/link.jsx">
import { Link as ReactEmailLink } from '@react-email/components';

import { Text } from './text';

export const Link = ({ children, style, ...props }) => {
  return (
    <ReactEmailLink style={{ ...linkStyle, ...style }} {...props}>
      {children}
    </ReactEmailLink>
  );
};

export const LinkText = ({ children, style }) => {
  return (
    <div style={style}>
      <Text style={textStyle}>
        Se você não conseguir clicar no link, copie e cole o endereço abaixo no seu navegador:
      </Text>

      <code style={linkTextStyle}>{children}</code>
    </div>
  );
};

const linkStyle = {
  color: '#2754C5',
  fontSize: '14px',
  textDecoration: 'underline',
  display: 'block',
};

const textStyle = {
  margin: '24px 0',
};

const linkTextStyle = {
  backgroundColor: '#f3f3f3',
  color: '#333',
  display: 'block',
  fontSize: '14px',
  padding: '12px',
  borderRadius: '8px',
  wordBreak: 'break-all',
};
</file>

<file path="models/transactional/components/text.jsx">
import { Text as ReactEmailText } from '@react-email/components';

export const Text = ({ children, style }) => {
  return <ReactEmailText style={{ ...defaultStyle, ...style }}>{children}</ReactEmailText>;
};

const defaultStyle = {
  color: '#333',
  fontSize: '14px',
};
</file>

<file path="models/transactional/emails/activation.jsx">
import { DefaultLayout, DefaultLayoutText, Link, LinkText, Text } from '../components';

export const ActivationEmailText = ({ username, activationLink }) => {
  const content = `Clique no link abaixo para ativar seu cadastro no TabNews:

${activationLink}

Caso você não tenha feito esta requisição, ignore esse email.`;

  return DefaultLayoutText({ username, content });
};

export const ActivationEmailHtml = ({ username, activationLink }) => (
  <DefaultLayout username={username} previewText="Ative seu cadastro no TabNews">
    <Link href={activationLink}>Clique aqui para ativar seu cadastro no TabNews.</Link>

    <LinkText>{activationLink}</LinkText>

    <Text style={text}>Caso você não tenha feito esta requisição, ignore esse email.</Text>
  </DefaultLayout>
);

ActivationEmailHtml.PreviewProps = {
  username: 'User',
  activationLink: 'https://tabnews.com.br/cadastro/ativar/TOKEN_ID',
};

export default ActivationEmailHtml;

const text = {
  margin: '24px 0',
};
</file>

<file path="models/transactional/emails/confirmation.jsx">
import { DefaultLayout, DefaultLayoutText, Link, LinkText, Text } from '../components';

export const ConfirmationEmailText = ({ username, confirmationLink }) => {
  const content = `Uma alteração de email foi solicitada.

Clique no link abaixo para confirmar esta alteração:

${confirmationLink}
  
Caso você não tenha feito esta requisição, ignore esse email.`;

  return DefaultLayoutText({ username, content });
};

export const ConfirmationEmailHtml = ({ username, confirmationLink }) => (
  <DefaultLayout username={username} previewText="Alteração de email no TabNews">
    <Text style={text}>Uma alteração de email foi solicitada.</Text>

    <Link href={confirmationLink}>Clique aqui para confirmar esta alteração.</Link>

    <LinkText>{confirmationLink}</LinkText>

    <Text style={text}>Caso você não tenha feito esta requisição, ignore esse email.</Text>
  </DefaultLayout>
);

ConfirmationEmailHtml.PreviewProps = {
  username: 'User',
  confirmationLink: 'https://tabnews.com.br/perfil/confirmar-email/TOKEN_ID',
};

export default ConfirmationEmailHtml;

const text = {
  margin: '24px 0',
};
</file>

<file path="models/transactional/emails/firewall.jsx">
import { DefaultLayout, DefaultLayoutText, Text } from '../components';

export const FirewallEmailText = ({ username, sideEffectLine, eventId }) => {
  const content = `${sideEffectLine} Caso acredite que isso seja um erro, responda este e-mail para que possamos avaliar a situação.

Identificador do evento: ${eventId}`;

  return DefaultLayoutText({ username, content });
};

export const FirewallEmailHtml = ({ username, sideEffectLine, eventId }) => (
  <DefaultLayout username={username} previewText="Atividade suspeita detectada no TabNews">
    <Text style={text}>{sideEffectLine}</Text>

    <Text style={text}>
      Caso acredite que isso seja um erro, responda este e-mail para que possamos avaliar a situação.
    </Text>

    <Text>Identificador do evento:</Text>

    <code style={code}>{eventId}</code>
  </DefaultLayout>
);

FirewallEmailHtml.PreviewProps = {
  username: 'User',
  sideEffectLine:
    'Identificamos a criação de muitas publicações em um curto período, então a sua publicação "Título da publicação" foi removida.',
  eventId: 'c7854f84-f7b4-468c-9805-a96d7ac4853a',
};

export default FirewallEmailHtml;

const text = {
  margin: '24px 0',
};

const code = {
  backgroundColor: '#f3f3f3',
  color: '#333',
  display: 'block',
  fontSize: '14px',
  padding: '12px',
  borderRadius: '8px',
  wordBreak: 'break-all',
};
</file>

<file path="models/transactional/emails/notification.jsx">
import { DefaultLayout, DefaultLayoutText, Link, LinkText, Text } from '../components';

export const NotificationEmailText = ({ username, bodyReplyLine, contentLink }) => {
  const content = `${bodyReplyLine} Para ler a resposta, utilize o link abaixo:

${contentLink}`;

  return DefaultLayoutText({ username, content });
};

export const NotificationEmailHtml = ({ username, bodyReplyLine, contentLink }) => (
  <DefaultLayout username={username} previewText="Nova resposta no TabNews">
    <Text style={text}>{bodyReplyLine}</Text>

    <Link href={contentLink}>Clique aqui para ler a resposta.</Link>

    <LinkText>{contentLink}</LinkText>
  </DefaultLayout>
);

NotificationEmailHtml.PreviewProps = {
  username: 'User',
  bodyReplyLine: '"User2" respondeu à sua publicação "Título publicação".',
  contentLink: 'https://tabnews.com.br/user2/titulo-publicacao',
};

export default NotificationEmailHtml;

const text = {
  margin: '24px 0',
};
</file>

<file path="models/transactional/emails/recovery.jsx">
import { DefaultLayout, DefaultLayoutText, Link, LinkText, Text } from '../components';

export const RecoveryEmailText = ({ username, recoveryLink }) => {
  const content = `Uma recuperação de senha foi solicitada. Caso você não tenha feito a solicitação, ignore esse email.

Caso você tenha feito essa solicitação, clique no link abaixo para definir uma nova senha:

${recoveryLink}`;

  return DefaultLayoutText({ username, content });
};

export const RecoveryEmailHtml = ({ username, recoveryLink }) => (
  <DefaultLayout username={username} previewText="Recuperação de senha no TabNews">
    <Text style={text}>Uma recuperação de senha foi solicitada.</Text>

    <Link href={recoveryLink}>Clique aqui para definir uma nova senha.</Link>

    <LinkText>{recoveryLink}</LinkText>

    <Text style={text}>Caso você não tenha feito esta requisição, ignore esse email.</Text>
  </DefaultLayout>
);

RecoveryEmailHtml.PreviewProps = {
  username: 'User',
  recoveryLink: 'https://tabnews.com.br/perfil/confirmar-email/TOKEN_ID',
};

export default RecoveryEmailHtml;

const text = {
  margin: '24px 0',
};
</file>

<file path="models/transactional/index.js">
import { render } from '@react-email/render';

import { ActivationEmailHtml, ActivationEmailText } from './emails/activation';
import { ConfirmationEmailHtml, ConfirmationEmailText } from './emails/confirmation';
import { FirewallEmailHtml, FirewallEmailText } from './emails/firewall';
import { NotificationEmailHtml, NotificationEmailText } from './emails/notification';
import { RecoveryEmailHtml, RecoveryEmailText } from './emails/recovery';

export const ActivationEmail = (props) => ({
  html: render(ActivationEmailHtml(props)),
  text: ActivationEmailText(props),
});

export const ConfirmationEmail = (props) => ({
  html: render(ConfirmationEmailHtml(props)),
  text: ConfirmationEmailText(props),
});

export const FirewallEmail = (props) => ({
  html: render(FirewallEmailHtml(props)),
  text: FirewallEmailText(props),
});

export const NotificationEmail = (props) => ({
  html: render(NotificationEmailHtml(props)),
  text: NotificationEmailText(props),
});

export const RecoveryEmail = (props) => ({
  html: render(RecoveryEmailHtml(props)),
  text: RecoveryEmailText(props),
});
</file>

<file path="models/activation.js">
import { ForbiddenError, NotFoundError } from 'errors';
import database from 'infra/database.js';
import email from 'infra/email.js';
import webserver from 'infra/webserver.js';
import authorization from 'models/authorization.js';
import { ActivationEmail } from 'models/transactional';
import user from 'models/user.js';

async function createAndSendActivationEmail(user) {
  const tokenObject = await create(user);
  await sendEmailToUser(user, tokenObject.id);
}

async function create(user) {
  const query = {
    text: `INSERT INTO activate_account_tokens (user_id, expires_at, email)
           VALUES($1, now() + interval '15 minutes', $2) RETURNING *;`,
    values: [user.id, user.email],
  };

  const results = await database.query(query);
  return results.rows[0];
}

async function sendEmailToUser(user, tokenId) {
  const activationPageEndpoint = getActivationPageEndpoint(tokenId);

  const { html, text } = ActivationEmail({
    username: user.username,
    activationLink: activationPageEndpoint,
  });

  await email.triggerSend({
    from: 'TabNews <contato@tabnews.com.br>',
    to: user.email,
    subject: 'Ative seu cadastro no TabNews',
    html,
    text,
  });
}

function getActivationApiEndpoint() {
  return `${webserver.host}/api/v1/activation`;
}

function getActivationPageEndpoint(tokenId) {
  return tokenId ? `${webserver.host}/cadastro/ativar/${tokenId}` : `${webserver.host}/cadastro/ativar`;
}

async function findOneTokenByUserId(userId) {
  const query = {
    text: 'SELECT * FROM activate_account_tokens WHERE user_id = $1 LIMIT 1;',
    values: [userId],
  };

  const results = await database.query(query);

  if (results.rowCount === 0) {
    throw new NotFoundError({
      message: `O token relacionado ao userId "${userId}" não foi encontrado no sistema.`,
      action: 'Verifique se o "id" do usuário está digitado corretamente.',
      stack: new Error().stack,
    });
  }

  return results.rows[0];
}

async function activateUserUsingTokenId(tokenId) {
  let tokenObject = await findOneTokenById(tokenId);
  if (!tokenObject.used) {
    const transaction = await database.transaction();

    try {
      await transaction.query('BEGIN');

      tokenObject = await findOneValidTokenById(tokenId, { transaction });

      await activateUserByUserId(tokenObject.user_id, { transaction });
      tokenObject = await markTokenAsUsed(tokenObject.id, { transaction });

      await transaction.query('COMMIT');
      await transaction.release();
    } catch (error) {
      await transaction.query('ROLLBACK');
      await transaction.release();
      throw error;
    }
  }
  return tokenObject;
}

async function activateUserByUserId(userId, options = {}) {
  const userToActivate = await user.findOneById(userId, options);

  if (!authorization.can(userToActivate, 'read:activation_token')) {
    throw new ForbiddenError({
      message: `Você não pode mais ler tokens de ativação.`,
      action: 'Verifique se você já está logado ou tentando ativar novamente o seu ou outro usuário que já está ativo.',
      stack: new Error().stack,
      errorLocationCode: 'MODEL:ACTIVATION:ACTIVATE_USER_BY_USER_ID:FEATURE_NOT_FOUND',
    });
  }

  await user.removeFeatures(userToActivate.id, ['read:activation_token'], options);
  return await user.addFeatures(
    userToActivate.id,
    [
      'create:session',
      'read:session',
      'create:content',
      'create:content:text_root',
      'create:content:text_child',
      'update:content',
      'update:user',
    ],
    options,
  );
}

async function findOneTokenById(tokenId) {
  const query = {
    text: `SELECT * FROM activate_account_tokens
        WHERE id = $1
        LIMIT 1;`,
    values: [tokenId],
  };

  const results = await database.query(query);

  if (results.rowCount === 0) {
    throw new NotFoundError({
      message: `O token de ativação utilizado não foi encontrado no sistema.`,
      action: 'Certifique-se que está sendo enviado o token corretamente.',
      stack: new Error().stack,
    });
  }

  return results.rows[0];
}

async function findOneValidTokenById(tokenId, options = {}) {
  const query = {
    text: `SELECT * FROM activate_account_tokens
        WHERE id = $1
        AND used = false
        AND expires_at >= now()
        LIMIT 1;`,
    values: [tokenId],
  };

  const results = await database.query(query, options);

  if (results.rowCount === 0) {
    throw new NotFoundError({
      message: `O token de ativação utilizado não foi encontrado no sistema ou expirou.`,
      action: 'Faça login novamente para receber um novo token por email.',
      stack: new Error().stack,
      errorLocationCode: 'MODEL:ACTIVATION:FIND_ONE_VALID_TOKEN_BY_ID:NOT_FOUND',
      key: 'token_id',
    });
  }

  return results.rows[0];
}

async function markTokenAsUsed(tokenId, options = {}) {
  const query = {
    text: `UPDATE activate_account_tokens
            SET used = true,
            updated_at = (now() at time zone 'utc')
            WHERE id = $1
            RETURNING *;`,
    values: [tokenId],
  };

  const results = await database.query(query, options);

  return results.rows[0];
}

async function update(tokenId, tokenBody) {
  const currentToken = await findOneTokenById(tokenId);
  const updatedToken = { ...currentToken, ...tokenBody };

  const query = {
    text: `UPDATE activate_account_tokens SET
            user_id = $2,
            used = $3,
            expires_at = $4,
            created_at = $5,
            updated_at = $6
            WHERE id = $1
            RETURNING *;`,
    values: [
      tokenId,
      updatedToken.user_id,
      updatedToken.used,
      updatedToken.expires_at,
      updatedToken.created_at,
      updatedToken.updated_at,
    ],
  };

  const results = await database.query(query);

  return results.rows[0];
}

export default Object.freeze({
  create,
  createAndSendActivationEmail,
  findOneTokenByUserId,
  getActivationApiEndpoint,
  getActivationPageEndpoint,
  activateUserUsingTokenId,
  update,
});
</file>

<file path="models/advertisement.js">
import database from 'infra/database';

async function getRandom(limit, options = {}) {
  const { ignoreId, ownerId, tryOtherOwners } = options;

  const query = {
    values: [limit],
  };

  let where = "type = 'ad' AND status = 'published'";

  if (ownerId) {
    where += ` AND c.owner_id = '${ownerId}'`;
  }

  if (ignoreId) {
    where += ` AND c.id != '${ignoreId}'`;
  }

  query.text = `
    SELECT
      c.id,
      c.slug,
      c.title,
      c.source_url,
      u.username as owner_username,
      'markdown' as ad_type
    FROM contents c
    INNER JOIN users u ON c.owner_id = u.id
    WHERE ${where}
    ORDER BY RANDOM()
    LIMIT $1;
  `;

  const results = await database.query(query);

  if (!results.rows.length && ownerId && tryOtherOwners) {
    return getRandom(limit, { ignoreId });
  }

  return results.rows;
}

export default Object.freeze({
  getRandom,
});
</file>

<file path="models/analytics.js">
import crypto from 'node:crypto';

import database from 'infra/database.js';
import umami from 'models/umami';

async function getChildContentsPublished() {
  const results = await database.query(`
  WITH range_values AS (
    SELECT date_trunc('day', NOW() - INTERVAL '2 MONTHS') as minval,
           date_trunc('day', NOW()) as maxval
  ),

  day_range AS (
    SELECT generate_series(minval, maxval, '1 day'::interval) as date
    FROM range_values
  ),

  daily_counts AS (
    SELECT date_trunc('day', created_at) as date,
           count(*) as ct
    FROM contents WHERE parent_id is not null
    GROUP BY 1
  )

  SELECT TO_CHAR(day_range.date :: DATE, 'dd/mm') as date,
         daily_counts.ct::INTEGER as respostas
  FROM day_range
  LEFT OUTER JOIN daily_counts on day_range.date = daily_counts.date
  ORDER BY day_range.date;
  `);

  return results.rows.map((row) => {
    return {
      date: row.date,
      respostas: row.respostas || 0,
    };
  });
}

async function getRootContentsPublished() {
  const results = await database.query(`
  WITH range_values AS (
    SELECT date_trunc('day', NOW() - INTERVAL '2 MONTHS') as minval,
           date_trunc('day', NOW()) as maxval
  ),

  day_range AS (
    SELECT generate_series(minval, maxval, '1 day'::interval) as date
    FROM range_values
  ),

  daily_counts AS (
    SELECT date_trunc('day', created_at) as date,
           count(*) as ct
    FROM contents WHERE parent_id is null
    GROUP BY 1
  )

  SELECT TO_CHAR(day_range.date :: DATE, 'dd/mm') as date,
         daily_counts.ct::INTEGER as conteudos
  FROM day_range
  LEFT OUTER JOIN daily_counts on day_range.date = daily_counts.date
  ORDER BY day_range.date;
  `);

  return results.rows.map((row) => {
    return {
      date: row.date,
      conteudos: row.conteudos || 0,
    };
  });
}

async function getUsersCreated() {
  const results = await database.query(`
  WITH range_values AS (
    SELECT date_trunc('day', NOW() - INTERVAL '2 MONTHS') as minval,
           date_trunc('day', NOW()) as maxval
  ),

  day_range AS (
    SELECT generate_series(minval, maxval, '1 day'::interval) as date
    FROM range_values
  ),

  daily_counts AS (
    SELECT date_trunc('day', created_at) as date,
           count(*) as ct
    FROM users
    GROUP BY 1
  )

  SELECT TO_CHAR(day_range.date :: DATE, 'dd/mm') as date,
         daily_counts.ct::INTEGER as cadastros
  FROM day_range
  LEFT OUTER JOIN daily_counts on day_range.date = daily_counts.date
  ORDER BY day_range.date;
  `);

  return results.rows.map((row) => {
    return {
      date: row.date,
      cadastros: row.cadastros || 0,
    };
  });
}

async function getVotesGraph({ limit = 300, showUsernames = false } = {}) {
  const results = await database.query({
    text: `
      SELECT
        id,
        originator_user_id as from,
        metadata->>'content_owner_id' as to,
        metadata->>'transaction_type' as transaction_type,
        originator_ip as ip,
        created_at
      FROM events
      WHERE
        type = 'update:content:tabcoins'
      ORDER BY created_at DESC
      LIMIT $1;
    `,
    values: [limit],
  });

  const usersMap = new Map();
  const ipNodesMap = new Map();
  const votesMap = new Map();

  // Since `votesMap` will maintain the insertion order, this allows moderators
  // to filter by user nodes that participated in the most recent ratings.
  // For public data, the result must be inverted to make it
  // difficult to identify the users represented by each node.
  if (!showUsernames) {
    results.rows.reverse();
  }

  results.rows.forEach((row) => {
    const from = usersMap.get(row.from)?.id || hash(row.from, row.id);
    const to = usersMap.get(row.to)?.id || hash(row.to, row.id);

    usersMap.set(row.from, {
      id: from,
      group: 'users',
      votes: (usersMap.get(row.from)?.votes || 0) + 1,
    });

    usersMap.set(row.to, {
      id: to,
      group: 'users',
      votes: (usersMap.get(row.to)?.votes || 0) + 1,
    });

    if (ipNodesMap.has(row.ip)) {
      ipNodesMap.get(row.ip).add(row.from);
    } else {
      ipNodesMap.set(row.ip, new Set([row.from]));
    }

    const fromToKey = `${row.transaction_type}-${from}-${to}`;
    votesMap.set(fromToKey, {
      id: fromToKey,
      from,
      to,
      type: row.transaction_type,
      value: (votesMap.get(fromToKey)?.value || 0) + 1,
    });
  });

  let ipId = 0;
  const sharedIps = [];
  const ipEdges = [];

  Array.from(ipNodesMap.values()).forEach((users) => {
    if (users.size === 1) return;

    ipId += 1;

    users.forEach((user) => {
      const from = usersMap.get(user).id;

      usersMap.set(user, {
        id: from,
        group: 'users',
        shared: true,
        votes: usersMap.get(user).votes,
      });

      ipEdges.push({ id: `net-${from}-${ipId}`, from, to: ipId, type: 'network' });
    });

    sharedIps.push({ id: ipId, group: 'IPs' });
  });

  const usersData = await database.query({
    text: `
    SELECT${showUsernames ? ` username,` : ''}
      'nuked' = ANY(features) as nuked,
      id as key
    FROM users
    WHERE
      id = ANY($1)
      ${showUsernames ? '' : `AND 'nuked' = ANY(features)`}
    ;`,
    values: [[...usersMap.keys()]],
  });

  usersData.rows.forEach((row) => {
    const user = usersMap.get(row.key);

    usersMap.set(row.key, {
      id: user.id,
      group: row.nuked ? 'nuked' : 'users',
      username: showUsernames && row.username,
      votes: user.votes,
    });
  });

  return {
    nodes: [...usersMap.values(), ...sharedIps],
    edges: [...votesMap.values(), ...ipEdges],
  };
}

async function getVotesTaken() {
  const results = await database.query(`
  WITH range_values AS (
    SELECT date_trunc('day', NOW() - INTERVAL '2 MONTHS') as minval,
           date_trunc('day', NOW()) as maxval
  ),

  day_range AS (
    SELECT generate_series(minval, maxval, '1 day'::interval) as date
    FROM range_values
  ),

  daily_counts AS (
    SELECT date_trunc('day', created_at) as date,
           count(*) as ct
    FROM events
    WHERE type = 'update:content:tabcoins'
    GROUP BY 1
  )

  SELECT TO_CHAR(day_range.date :: DATE, 'dd/mm') as date,
         daily_counts.ct::INTEGER as votos
  FROM day_range
  LEFT OUTER JOIN daily_counts on day_range.date = daily_counts.date
  ORDER BY day_range.date;
  `);

  return results.rows.map((row) => {
    return {
      date: row.date,
      votos: row.votos || 0,
    };
  });
}

async function getStatsByPath(path) {
  return await umami.getStatsByPath(path);
}

export default Object.freeze({
  getChildContentsPublished,
  getRootContentsPublished,
  getStatsByPath,
  getUsersCreated,
  getVotesGraph,
  getVotesTaken,
});

function hash(key, salt) {
  if (!salt) throw new Error('Necessário "salt" para gerar "hash"');

  const hash = crypto.createHash('md5');
  hash.update(key + salt);

  return hash.digest('base64').slice(0, 7);
}
</file>

<file path="models/authentication.js">
import { ForbiddenError, UnauthorizedError } from 'errors';
import authorization from 'models/authorization.js';
import password from 'models/password.js';
import session from 'models/session.js';
import user from 'models/user.js';
import validator from 'models/validator.js';

async function hashPassword(unhashedPassword) {
  return await password.hash(unhashedPassword);
}

async function comparePasswords(providedPassword, passwordHash) {
  const passwordMatches = await password.compare(providedPassword, passwordHash);

  if (!passwordMatches) {
    throw new UnauthorizedError({
      message: `A senha informada não confere com a senha do usuário.`,
      action: `Verifique se a senha informada está correta e tente novamente.`,
      errorLocationCode: 'MODEL:AUTHENTICATION:COMPARE_PASSWORDS:PASSWORD_MISMATCH',
    });
  }
}

async function injectAnonymousOrUser(request, response, next, options = {}) {
  if (request.cookies?.session_id) {
    const cleanCookies = validator(request.cookies, {
      session_id: 'required',
    });
    request.cookies.session_id = cleanCookies.session_id;

    await injectAuthenticatedUser(request, response, options);
    return next();
  } else {
    injectAnonymousUser(request);
    return next();
  }

  async function injectAuthenticatedUser(request, response, options = {}) {
    const sessionObject = await session.findOneValidFromRequest(request, response);
    const userObject = await user.findOneById(sessionObject.user_id, options);

    if (!authorization.can(userObject, 'read:session')) {
      throw new ForbiddenError({
        message: `Você não possui permissão para executar esta ação.`,
        action: `Verifique se este usuário já ativou a sua conta e recebeu a feature "read:session".`,
        errorLocationCode: 'MODEL:AUTHENTICATION:INJECT_AUTHENTICATED_USER:USER_CANT_READ_SESSION',
      });
    }

    request.context = {
      ...request.context,
      user: userObject,
      session: sessionObject,
    };
  }

  function injectAnonymousUser(request) {
    const anonymousUser = user.createAnonymous();
    request.context = {
      ...request.context,
      user: anonymousUser,
    };
  }
}

async function createSessionAndSetCookies(userId, response) {
  const sessionObject = await session.create(userId);
  session.setSessionIdCookieInResponse(sessionObject.token, response);
  return sessionObject;
}

export default Object.freeze({
  hashPassword,
  comparePasswords,
  injectAnonymousOrUser,
  createSessionAndSetCookies,
});
</file>

<file path="models/authorization.js">
import { ForbiddenError, ValidationError } from 'errors';
import availableFeatures from 'models/user-features';
import validator from 'models/validator.js';

function can(user, feature, resource) {
  validateUser(user);
  validateFeature(feature);

  if (!user.features.includes(feature)) return false;

  switch (feature) {
    case 'update:user':
      return resource?.id && user.id === resource.id;

    case 'update:content':
      return (resource?.owner_id && user.id === resource.owner_id) || user.features.includes('update:content:others');
  }

  if (!resource) return true;

  return false;
}

function filterInput(user, feature, input, target) {
  validateUser(user);
  validateFeature(feature);
  validateInput(input);

  let filteredInputValues = {};

  if (feature === 'create:session' && can(user, feature)) {
    filteredInputValues = {
      email: input.email,
      password: input.password,
    };
  }

  if (feature === 'create:user' && can(user, feature)) {
    filteredInputValues = {
      username: input.username,
      email: input.email,
      password: input.password,
    };
  }

  if (feature === 'update:user' && can(user, feature, target)) {
    filteredInputValues = {
      username: input.username,
      email: input.email,
      password: input.password,
      description: input.description,
      notifications: input.notifications,
    };
  }

  if (feature === 'update:user:others' && can(user, feature)) {
    filteredInputValues = {
      description: input.description,
    };
  }

  if (feature === 'ban:user' && can(user, feature)) {
    filteredInputValues = {
      ban_type: input.ban_type,
    };
  }

  if (feature === 'read:activation_token' && can(user, feature)) {
    filteredInputValues = {
      tokenId: input.token_id,
    };
  }

  if (feature === 'create:content:text_root' && can(user, feature)) {
    filteredInputValues = {
      slug: input.slug,
      title: input.title,
      body: input.body,
      status: input.status,
      type: input.type,
      source_url: input.source_url,
    };
  }

  if (feature === 'create:content:text_child' && can(user, feature)) {
    filteredInputValues = {
      parent_id: input.parent_id,
      slug: input.slug,
      title: input.title,
      body: input.body,
      status: input.status,
      source_url: input.source_url,
    };
  }

  if (feature === 'update:content' && can(user, feature, target)) {
    filteredInputValues = {
      parent_id: input.parent_id,
      slug: input.slug,
      title: input.title,
      body: input.body,
      status: input.status,
      source_url: input.source_url,
    };
  }

  // Force the clean up of "undefined" values
  return JSON.parse(JSON.stringify(filteredInputValues));
}

function filterOutput(user, feature, output) {
  validateUser(user);
  validateFeature(feature);
  validateOutput(output);

  let filteredOutputValues = {};

  if (feature === 'read:session' && can(user, feature)) {
    if (user.id && output.user_id && user.id === output.user_id) {
      filteredOutputValues = {
        id: output.id,
        expires_at: output.expires_at,
        created_at: output.created_at,
        updated_at: output.updated_at,
      };
    }
  }

  if (feature === 'create:session' && can(user, feature)) {
    if (user.id && output.user_id && user.id === output.user_id) {
      filteredOutputValues = {
        id: output.id,
        token: output.token,
        expires_at: output.expires_at,
        created_at: output.created_at,
        updated_at: output.updated_at,
      };
    }
  }

  if (feature === 'read:user') {
    filteredOutputValues = {
      id: output.id,
      username: output.username,
      description: output.description,
      features: output.features,
      tabcoins: output.tabcoins,
      tabcash: output.tabcash,
      created_at: output.created_at,
      updated_at: output.updated_at,
    };
  }

  if (feature === 'read:user:self') {
    if (user.id && output.id && user.id === output.id) {
      filteredOutputValues = {
        id: output.id,
        username: output.username,
        email: output.email,
        description: output.description,
        notifications: output.notifications,
        features: output.features,
        tabcoins: output.tabcoins,
        tabcash: output.tabcash,
        created_at: output.created_at,
        updated_at: output.updated_at,
      };
    }
  }

  if (feature === 'read:user:list') {
    filteredOutputValues = output.map((user) => ({
      id: user.id,
      username: user.username,
      description: user.description,
      features: user.features,
      tabcoins: user.tabcoins,
      tabcash: user.tabcash,
      created_at: user.created_at,
      updated_at: user.updated_at,
    }));
  }

  if (feature === 'read:activation_token') {
    filteredOutputValues = {
      id: output.id,
      used: output.used,
      expires_at: output.expires_at,
      created_at: output.created_at,
      updated_at: output.updated_at,
    };
  }

  if (feature === 'read:content') {
    const clonedOutput = { ...output };
    if (output.status !== 'published' && user.id !== output.owner_id) {
      delete clonedOutput.title;
      delete clonedOutput.body;
      delete clonedOutput.slug;
      delete clonedOutput.source_url;
      delete clonedOutput.owner_id;
      delete clonedOutput.owner_username;
      delete clonedOutput.tabcoins;
      delete clonedOutput.tabcoins_credit;
      delete clonedOutput.tabcoins_debit;
    }

    filteredOutputValues = validator(clonedOutput, {
      content: 'required',
    });
  }

  if (feature === 'read:firewall' && can(user, feature)) {
    filteredOutputValues = validator(output, {
      firewall_event: 'required',
    });
    filteredOutputValues.events.forEach((event) => delete event.originator_ip);
  }

  if (feature === 'read:content:tabcoins') {
    filteredOutputValues = validator(output, {
      tabcoins: 'required',
      tabcoins_credit: 'required',
      tabcoins_debit: 'required',
    });
  }

  if (feature === 'read:content:list') {
    filteredOutputValues = output.map((content) => {
      return validator(content, {
        content: 'required',
      });
    });
  }

  if (feature === 'read:recovery_token') {
    filteredOutputValues = validator(
      {
        used: output.used,
        expires_at: output.expires_at,
        created_at: output.created_at,
        updated_at: output.updated_at,
      },
      {
        used: 'required',
        expires_at: 'required',
        created_at: 'required',
        updated_at: 'required',
      },
    );
  }

  if (feature === 'read:email_confirmation_token') {
    filteredOutputValues = validator(output, {
      id: 'required',
      used: 'required',
      expires_at: 'required',
      created_at: 'required',
      updated_at: 'required',
    });
  }

  if (feature === 'read:ad:list') {
    filteredOutputValues = validator(
      {
        ad_list: output,
      },
      {
        ad_list: 'required',
      },
    ).ad_list;
  }

  // Force the clean up of "undefined" values
  return JSON.parse(JSON.stringify(filteredOutputValues));
}

function validateUser(user) {
  if (!user) {
    throw new ValidationError({
      message: `Nenhum "user" foi especificado para a ação de autorização.`,
      action: `Contate o suporte informado o campo "errorId".`,
    });
  }

  if (!user.features || !Array.isArray(user.features)) {
    throw new ValidationError({
      message: `"user" não possui "features" ou não é um array.`,
      action: `Contate o suporte informado o campo "errorId".`,
    });
  }
}

function validateFeature(feature) {
  if (!feature) {
    throw new ValidationError({
      message: `Nenhuma "feature" foi especificada para a ação de autorização.`,
      action: `Contate o suporte informado o campo "errorId".`,
    });
  }

  if (!availableFeatures.has(feature)) {
    throw new ValidationError({
      message: `A feature utilizada não está disponível na lista de features existentes.`,
      action: `Contate o suporte informado o campo "errorId".`,
      context: {
        feature: feature,
      },
    });
  }
}

function validateInput(input) {
  if (!input) {
    throw new ValidationError({
      message: `Nenhum "input" foi especificado para a ação de filtro.`,
      action: `Contate o suporte informado o campo "errorId".`,
    });
  }
}

function validateOutput(output) {
  if (!output) {
    throw new ValidationError({
      message: `Nenhum "output" foi especificado para a ação de filtro.`,
      action: `Contate o suporte informado o campo "errorId".`,
    });
  }
}

function canRequest(feature) {
  return function (request, response, next) {
    const userTryingToRequest = request.context.user;

    if (!userTryingToRequest.features.includes(feature)) {
      throw new ForbiddenError({
        message: `Usuário não pode executar esta operação.`,
        action: `Verifique se este usuário possui a feature "${feature}".`,
        errorLocationCode: 'MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND',
      });
    }

    return next();
  };
}

export default Object.freeze({
  can,
  canRequest,
  filterOutput,
  filterInput,
});
</file>

<file path="models/balance.js">
import { UnprocessableEntityError } from 'errors';
import database from 'infra/database.js';

const tableNameMap = {
  'user:tabcoin': 'user_tabcoin_operations',
  'user:tabcash': 'user_tabcash_operations',
  'ad:budget': 'ad_tabcash_operations',
  default: 'content_tabcoin_operations',
};

const balanceTypeMap = {
  'content:tabcoin:credit': 'credit',
  'content:tabcoin:debit': 'debit',
  'content:tabcoin:initial': 'initial',
  'ad:budget': 'budget',
};

const sqlFunctionMap = {
  'user:tabcoin': 'get_user_current_tabcoins',
  'user:tabcash': 'get_user_current_tabcash',
  'ad:budget': 'get_ad_current_tabcash',
  default: 'get_content_current_tabcoins',
};

async function findAllByOriginatorId(originatorId, options) {
  const where = Array.isArray(originatorId) ? 'WHERE originator_id = ANY($1)' : 'WHERE originator_id = $1';
  const query = {
    text: `
      SELECT * FROM (
        SELECT id, recipient_id, amount, originator_type, originator_id,
          'user:tabcoin' AS balance_type
        FROM user_tabcoin_operations
        ${where}
      UNION ALL
        SELECT id, recipient_id, amount, originator_type, originator_id,
          'user:tabcash' AS balance_type
        FROM user_tabcash_operations
        ${where}
      UNION ALL
        SELECT id, recipient_id, amount, originator_type, originator_id,
          CONCAT('content:tabcoin:', balance_type) AS balance_type
        FROM content_tabcoin_operations
        ${where}
      ) AS all_operations;
    `,
    values: [originatorId],
  };

  const results = await database.query(query, options);
  return results.rows;
}

async function create({ balanceType, recipientId, amount, originatorType, originatorId }, options = {}) {
  const tableName = tableNameMap[balanceType] || tableNameMap.default;
  const hasBalanceTypeColum = !balanceType.startsWith('user:');
  const totalBalanceFunction = sqlFunctionMap[balanceType] || sqlFunctionMap.default;

  const returning = options.withBalance ? `*, ${totalBalanceFunction}($1) as total` : '*';

  const query = {
    text: `
      INSERT INTO ${tableName}
        (recipient_id, amount, originator_type, originator_id${hasBalanceTypeColum ? ', balance_type' : ''})
      VALUES
        ($1, $2, $3, $4${hasBalanceTypeColum ? ', $5' : ''})
      RETURNING ${returning};
      `,
    values: [recipientId, amount, originatorType, originatorId],
  };

  if (hasBalanceTypeColum) {
    const parsedBalanceType = balanceTypeMap[balanceType] || balanceType;

    query.values.push(parsedBalanceType);
  }

  const results = await database.query(query, options);
  return results.rows[0];
}

async function getContentTabcoinsCreditDebit({ recipientId }, options = {}) {
  const query = {
    text: 'SELECT * FROM get_content_balance_credit_debit($1);',
    values: [recipientId],
  };

  const results = await database.query(query, options);
  return {
    tabcoins: results.rows[0].total_balance,
    tabcoins_credit: results.rows[0].total_credit,
    tabcoins_debit: results.rows[0].total_debit,
  };
}

async function rateContent({ contentId, contentOwnerId, fromUserId, transactionType }, options = {}) {
  const tabCoinsToDebitFromUser = -2;
  const tabCashToCreditToUser = 1;
  const tabCoinsToTransactToContentOwner = transactionType === 'credit' ? 1 : -1;
  const tabCoinsToTransactToContent = transactionType === 'credit' ? 1 : -1;
  const originatorType = 'event';
  const originatorId = options.eventId;

  const query = {
    text: `
      WITH users_tabcoin_inserts AS (
        INSERT INTO user_tabcoin_operations
          (recipient_id, amount, originator_type, originator_id)
        VALUES
          ($1, $2, $8, $9),
          ($6, $7, $8, $9)
        RETURNING
          *
      ),
      users_tabcash_insert AS (
        INSERT INTO user_tabcash_operations
          (recipient_id, amount, originator_type, originator_id)
        VALUES
          ($1, $3, $8, $9)
      ),
      content_insert AS (
        INSERT INTO content_tabcoin_operations
          (balance_type, recipient_id, amount, originator_type, originator_id)
        VALUES
          ($10, $4, $5, 'user', $1)
        RETURNING
          *
      )
      SELECT
        get_user_current_tabcoins($1) AS user_current_tabcoin_balance,
        tabcoins_count.total_balance as content_current_tabcoin_balance,
        tabcoins_count.total_credit as content_current_tabcoin_credit,
        tabcoins_count.total_debit as content_current_tabcoin_debit 
      FROM
        users_tabcoin_inserts,
        content_insert,
        get_content_balance_credit_debit(content_insert.recipient_id) tabcoins_count
      LIMIT
        1
    ;`,
    values: [
      fromUserId, // $1
      tabCoinsToDebitFromUser, // $2
      tabCashToCreditToUser, // $3

      contentId, // $4
      tabCoinsToTransactToContent, // $5

      contentOwnerId, // $6
      tabCoinsToTransactToContentOwner, // $7

      originatorType, // $8
      originatorId, // $9

      transactionType, // $10
    ],
  };

  const results = await database.query(query, options);
  const currentBalances = results.rows[0];

  if (currentBalances.user_current_tabcoin_balance < 0) {
    throw new UnprocessableEntityError({
      message: `Não foi possível adicionar TabCoins nesta publicação.`,
      action: `Você precisa de pelo menos ${Math.abs(tabCoinsToDebitFromUser)} TabCoins para realizar esta ação.`,
      errorLocationCode: 'MODEL:BALANCE:RATE_CONTENT:NOT_ENOUGH',
    });
  }

  return {
    tabcoins: currentBalances.content_current_tabcoin_balance,
    tabcoins_credit: currentBalances.content_current_tabcoin_credit,
    tabcoins_debit: currentBalances.content_current_tabcoin_debit,
  };
}

async function undo(balanceOperation, options) {
  const invertedBalanceOperation = {
    balanceType: balanceOperation.balance_type,
    recipientId: balanceOperation.recipient_id,
    amount: balanceOperation.amount * -1,
    originatorType: 'event',
    originatorId: options.event.id,
  };

  const newBalanceOperation = await create(invertedBalanceOperation, options);
  return newBalanceOperation;
}

export default Object.freeze({
  findAllByOriginatorId,
  create,
  getContentTabcoinsCreditDebit,
  rateContent,
  undo,
});
</file>

<file path="models/ban.js">
import database from 'infra/database.js';
import balance from 'models/balance.js';
import session from 'models/session.js';
import user from 'models/user.js';

async function nuke(userId, options = {}) {
  await user.removeFeatures(userId, null, options);
  await session.expireAllFromUserId(userId, options);
  await unpublishAllContent(userId, options);
  await undoAllRatingOperations(userId, options);
  const nukedUser = await user.addFeatures(userId, ['nuked'], options);
  return nukedUser;

  async function unpublishAllContent(userId, options = {}) {
    const query = {
      text: `
        UPDATE
          contents
        SET
          status = 'deleted',
          deleted_at = (NOW() AT TIME ZONE 'utc')
        WHERE
          owner_id = $1
          AND status != 'deleted'
      ;`,
      values: [userId],
    };

    await database.query(query, options);
  }

  async function undoAllRatingOperations(userId, options = {}) {
    const userEvents = await getAllRatingEventsFromUser(userId, options);

    for (const userEvent of userEvents) {
      const eventBalanceOperations = await balance.findAllByOriginatorId(userEvent.id, options);

      for (const eventBalanceOperation of eventBalanceOperations) {
        await balance.undo(eventBalanceOperation, options);
      }
    }

    const userBalanceOperations = await balance.findAllByOriginatorId(userId, options);

    for (const userBalanceOperation of userBalanceOperations) {
      await balance.undo(userBalanceOperation, options);
    }

    async function getAllRatingEventsFromUser(userId, options = {}) {
      const query = {
        text: `
          SELECT
            *
          FROM
            events
          WHERE
            originator_user_id = $1
            AND created_at > NOW() - INTERVAL '2 weeks'
            AND type = 'update:content:tabcoins'
          ORDER BY
            created_at ASC
        ;`,
        values: [userId],
      };

      const results = await database.query(query, options);

      return results.rows;
    }
  }
}

export default Object.freeze({
  nuke,
});
</file>

<file path="models/cache-control.js">
import { InternalServerError } from 'errors';

function setCacheControl(res, cacheControl) {
  const cacheControlHeader = res.getHeaders()['cache-control'];

  if (cacheControlHeader?.toLowerCase() === cacheControl.toLowerCase()) return;

  res.setHeader('Cache-Control', cacheControl);

  const setHeader = res.setHeader;

  res.setHeader = (name, value) => {
    if (name.toLowerCase() === 'cache-control') {
      throw new InternalServerError({
        message: `Header Cache-Control já foi definido.`,
        errorLocationCode: 'MODEL:CACHE_CONTROL:DIFFERENT_CACHE_CONTROL_ALREADY_DEFINED',
      });
    }
    return setHeader(name, value);
  };
}

function noCache(_, res, next) {
  setCacheControl(res, 'no-cache, no-store, max-age=0, must-revalidate');
  if (next) return next();
}

function swrMaxAge(maxAge = 10) {
  if (!Number.isInteger(maxAge)) throw new TypeError('maxAge must be an integer.');

  return (_, res, next) => {
    setCacheControl(res, `public, s-maxage=${maxAge.toString()}, stale-while-revalidate`);
    if (next) return next();
  };
}

export default Object.freeze({
  noCache,
  swrMaxAge,
});
</file>

<file path="models/content.js">
import { truncate } from '@tabnews/helpers';
import { randomUUID as uuidV4 } from 'node:crypto';
import slug from 'slug';

import { ForbiddenError, UnprocessableEntityError, ValidationError } from 'errors';
import database from 'infra/database.js';
import balance from 'models/balance.js';
import pagination from 'models/pagination.js';
import prestige from 'models/prestige';
import user from 'models/user.js';
import validator from 'models/validator.js';
import queries from 'queries/rankingQueries';

async function findAll(values = {}, options = {}) {
  values = validateValues(values);
  await replaceOwnerUsernameWithOwnerId(values);

  const query = {
    values: [],
  };

  if (!values.count) {
    const offset = (values.page - 1) * values.per_page;
    query.values = [values.limit || values.per_page, offset];
  }

  if (options.strategy === 'relevant_global') {
    query.text = queries.rankedContent;
    if (values.count) {
      query.values = [1, 0];
    }

    const relevantResults = await database.query(query, { transaction: options.transaction });

    return relevantResults.rows;
  }

  const selectClause = buildSelectClause(values);
  const whereClause = buildWhereClause(values.where);
  const orderByClause = buildOrderByClause(values);

  query.text = `
      WITH content_window AS (
      SELECT
        COUNT(*) OVER()::INTEGER as total_rows,
        id
      FROM contents
      ${whereClause}
      ${orderByClause}

      ${values.count ? 'LIMIT 1' : 'LIMIT $1 OFFSET $2'}
      )
      ${selectClause}
      ${orderByClause}
      ;`;

  if (values.where) {
    Object.keys(values.where).forEach((key) => {
      if (key === '$not_null') return;

      query.values.push(values.where[key]);
    });
  }
  const results = await database.query(query, { transaction: options.transaction });

  return results.rows;

  async function replaceOwnerUsernameWithOwnerId(values) {
    if (values.where?.owner_username) {
      const userOwner = await user.findOneByUsername(values.where.owner_username);
      values.where.owner_id = userOwner.id;
      delete values.where.owner_username;
    }
  }

  function validateValues(values) {
    const cleanValues = validator(values, {
      page: 'optional',
      per_page: 'optional',
      order: 'optional',
      where: 'optional',
      count: 'optional',
      $not_null: 'optional',
      limit: 'optional',
      attributes: 'optional',
    });

    return cleanValues;
  }

  function buildSelectClause(values) {
    if (values.count) {
      return `
        SELECT
          total_rows
        FROM
          content_window
        `;
    }

    return `
      SELECT
        contents.id,
        contents.owner_id,
        contents.parent_id,
        contents.slug,
        contents.title,
        ${!values.attributes?.exclude?.includes('body') ? 'contents.body,' : ''}
        contents.status,
        contents.type,
        contents.source_url,
        contents.created_at,
        contents.updated_at,
        contents.published_at,
        contents.deleted_at,
        contents.path,
        users.username as owner_username,
        content_window.total_rows,
        tabcoins_count.total_balance as tabcoins,
        tabcoins_count.total_credit as tabcoins_credit,
        tabcoins_count.total_debit as tabcoins_debit,
        (
          SELECT COUNT(*)
          FROM contents as children
          WHERE children.path @> ARRAY[contents.id]
           AND children.status = 'published'
        ) as children_deep_count
      FROM
        contents
      INNER JOIN
        content_window ON contents.id = content_window.id
      INNER JOIN
        users ON contents.owner_id = users.id
      LEFT JOIN LATERAL get_content_balance_credit_debit(contents.id) tabcoins_count ON true
    `;
  }

  function buildWhereClause(columns) {
    if (!columns) {
      return '';
    }

    let globalIndex = query.values.length;
    return Object.entries(columns).reduce((accumulator, column, index) => {
      if (index === 0) {
        return `WHERE ${getColumnDeclaration(column)}`;
      } else {
        return `${accumulator} AND ${getColumnDeclaration(column)}`;
      }

      function getColumnDeclaration(column) {
        const columnName = column[0];
        const columnValue = column[1];

        if (columnValue === null) {
          globalIndex += 1;
          return `contents.${columnName} IS NOT DISTINCT FROM $${globalIndex}`;
        }

        if (columnName === '$not_null') {
          const $notNullQuery = columnValue
            .map((notColumnName) => {
              return `contents.${notColumnName} IS NOT NULL`;
            })
            .join(' AND ');

          return `(${$notNullQuery})`;
        }

        globalIndex += 1;

        if (Array.isArray(columnValue)) {
          return `contents.${columnName}  = ANY ($${globalIndex})`;
        }

        return `contents.${columnName} = $${globalIndex}`;
      }
    }, '');
  }

  function buildOrderByClause({ order, count }) {
    if (!order || count) {
      return '';
    }

    return `ORDER BY contents.${order}`;
  }
}

async function findOne(values, options = {}) {
  values.limit = 1;
  const rows = await findAll(values, options);
  return rows[0];
}

async function findWithStrategy(options = {}) {
  const strategies = {
    new: getNew,
    old: getOld,
    relevant: getRelevant,
  };

  return await strategies[options.strategy](options);

  async function getNew(options = {}) {
    const results = {};

    options.order = 'published_at DESC';
    results.rows = await findAll(options);
    options.total_rows = results.rows[0]?.total_rows;
    results.pagination = await getPagination(options);

    return results;
  }

  async function getOld(options = {}) {
    const results = {};

    options.order = 'published_at ASC';
    results.rows = await findAll(options);
    options.total_rows = results.rows[0]?.total_rows;
    results.pagination = await getPagination(options);

    return results;
  }

  async function getRelevant(values = {}) {
    const results = {};
    const options = {};

    if (!values.where?.owner_username && values.where?.parent_id === null) {
      options.strategy = 'relevant_global';
    }
    values.order = 'published_at DESC';

    const contentList = await findAll(values, options);

    if (options.strategy === 'relevant_global') {
      results.rows = contentList;
    } else {
      results.rows = rankContentListByRelevance(contentList);
    }

    values.total_rows = results.rows[0]?.total_rows;
    results.pagination = await getPagination(values, options);

    return results;
  }
}

async function getPagination(values, options) {
  values.count = true;
  values.total_rows = values.total_rows ?? (await findAll(values, options))[0]?.total_rows ?? 0;
  return pagination.get(values);
}

async function create(postedContent, options = {}) {
  populateSlug(postedContent);
  populateStatus(postedContent);
  const validContent = validateCreateSchema(postedContent);

  checkRootContentTitle(validContent);

  populatePublishedAtValue(null, validContent);

  const newContent = await runInsertQuery(validContent, {
    transaction: options.transaction,
  });

  throwIfSpecifiedParentDoesNotExist(postedContent, newContent);

  await creditOrDebitTabCoins(null, newContent, {
    eventId: options.eventId,
    transaction: options.transaction,
  });

  await updateTabCashBalance(null, newContent, {
    eventId: options.eventId,
    transaction: options.transaction,
  });

  const tabcoinsCount = await balance.getContentTabcoinsCreditDebit(
    {
      recipientId: newContent.id,
    },
    {
      transaction: options.transaction,
    },
  );
  newContent.tabcoins = tabcoinsCount.tabcoins;
  newContent.tabcoins_credit = tabcoinsCount.tabcoins_credit;
  newContent.tabcoins_debit = tabcoinsCount.tabcoins_debit;

  return newContent;

  async function runInsertQuery(content, options) {
    const query = {
      text: `
      WITH
        parent AS (
          SELECT
            owner_id,
            CASE 
              WHEN id IS NULL THEN ARRAY[]::uuid[]
              ELSE ARRAY_APPEND(path, id)
            END AS child_path
          FROM (SELECT 1) AS dummy
          LEFT JOIN contents
          ON id = $2
        ),
        inserted_content as (
          INSERT INTO
            contents (id, parent_id, owner_id, slug, title, body, status, source_url, published_at, type, path)
            SELECT $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, parent.child_path
            FROM parent
            RETURNING *
        )
      SELECT
        inserted_content.id,
        inserted_content.owner_id,
        inserted_content.parent_id,
        inserted_content.slug,
        inserted_content.title,
        inserted_content.body,
        inserted_content.status,
        inserted_content.type,
        inserted_content.source_url,
        inserted_content.created_at,
        inserted_content.updated_at,
        inserted_content.published_at,
        inserted_content.deleted_at,
        inserted_content.path,
        users.username as owner_username,
        parent.owner_id as parent_owner_id
      FROM
        inserted_content
      INNER JOIN
        users ON inserted_content.owner_id = users.id
      LEFT JOIN
        parent ON true
      ;`,
      values: [
        content.id,
        content.parent_id,
        content.owner_id,
        content.slug,
        content.title,
        content.body,
        content.status,
        content.source_url,
        content.published_at,
        content.type,
      ],
    };

    try {
      const results = await database.query(query, { transaction: options.transaction });
      return results.rows[0];
    } catch (error) {
      throw parseQueryErrorToCustomError(error);
    }
  }
}

function populateSlug(postedContent) {
  if (!postedContent.slug) {
    postedContent.slug = getSlug(postedContent.title) || uuidV4();
  }
}

slug.extend({
  '%': ' por cento',
  '>': '-',
  '<': '-',
  '@': '-',
  '.': '-',
  ',': '-',
  '&': ' e ',
  _: '-',
  '/': '-',
});

function getSlug(title) {
  if (!title) {
    return;
  }

  const generatedSlug = slug(truncate(title, 160), {
    trim: true,
  });

  return generatedSlug;
}

function populateStatus(postedContent) {
  postedContent.status = postedContent.status || 'draft';
}

function throwIfSpecifiedParentDoesNotExist(postedContent, newContent) {
  const existingParentId = newContent.path.at(-1);

  if (postedContent.parent_id && postedContent.parent_id !== existingParentId) {
    throw new ValidationError({
      message: `Você está tentando criar um comentário em um conteúdo que não existe.`,
      action: `Utilize um "parent_id" que aponte para um conteúdo existente.`,
      stack: new Error().stack,
      errorLocationCode: 'MODEL:CONTENT:CHECK_IF_PARENT_ID_EXISTS:NOT_FOUND',
      statusCode: 400,
      key: 'parent_id',
    });
  }
}

function parseQueryErrorToCustomError(error) {
  if (error.databaseErrorCode === database.errorCodes.UNIQUE_CONSTRAINT_VIOLATION) {
    return new ValidationError({
      message: `O conteúdo enviado parece ser duplicado.`,
      action: `Utilize um "title" ou "slug" com começo diferente.`,
      stack: new Error().stack,
      errorLocationCode: 'MODEL:CONTENT:CHECK_FOR_CONTENT_UNIQUENESS:ALREADY_EXISTS',
      statusCode: 400,
      key: 'slug',
    });
  }

  return error;
}

function validateCreateSchema(content) {
  const cleanValues = validator(content, {
    id: 'required',
    parent_id: 'optional',
    owner_id: 'required',
    slug: 'required',
    title: 'optional',
    body: 'required',
    status: 'required',
    content_type: 'optional',
    source_url: 'optional',
  });

  if (cleanValues.status === 'deleted' || cleanValues.status === 'firewall') {
    throw new ValidationError({
      message: `Não é possível criar um novo conteúdo diretamente com status "${cleanValues.status}".`,
      key: 'status',
      type: 'any.only',
      errorLocationCode: 'MODEL:CONTENT:VALIDATE_CREATE_SCHEMA:INVALID_STATUS',
    });
  }

  return cleanValues;
}

function checkRootContentTitle(content) {
  if (!content.parent_id && !content.title) {
    throw new ValidationError({
      message: `"title" é um campo obrigatório.`,
      stack: new Error().stack,
      errorLocationCode: 'MODEL:CONTENT:CHECK_ROOT_CONTENT_TITLE:MISSING_TITLE',
      statusCode: 400,
      key: 'title',
    });
  }
}

function populatePublishedAtValue(oldContent, newContent) {
  if (oldContent && oldContent.published_at) {
    newContent.published_at = oldContent.published_at;
    return;
  }

  if (oldContent && !oldContent.published_at && newContent.status === 'published') {
    newContent.published_at = new Date();
    return;
  }

  if (!oldContent && newContent.status === 'published') {
    newContent.published_at = new Date();
    return;
  }
}

async function creditOrDebitTabCoins(oldContent, newContent, options = {}) {
  let contentEarnings = 0;
  let userEarnings = 0;

  // We should not credit or debit if the content has never been published before
  // and is not published now, example: "draft" -> "deleted"
  // or if it was deleted and is catch by firewall: "deleted" -> "firewall".
  if (
    oldContent &&
    ((!oldContent.published_at && newContent.status !== 'published') ||
      ['deleted', 'firewall'].includes(oldContent.status))
  ) {
    return;
  }

  // We should debit if the content was once "published", but now it is not.
  // 1) If content `tabcoins` is positive, we need to debit all tabcoins earning by the user.
  // 2) If content `tabcoins` is negative, we should debit the original tabcoin gained from the
  // creation of the content represented by `initialTabcoins`.
  if (oldContent?.published_at && newContent.status !== 'published') {
    let amountToDebit;

    const userEarningsByContent = await prestige.getByContentId(oldContent.id, { transaction: options.transaction });

    if (oldContent.tabcoins > 0) {
      amountToDebit = -userEarningsByContent.totalTabcoins;
    } else {
      amountToDebit = -userEarningsByContent.initialTabcoins;
    }

    if (!amountToDebit) return;

    await balance.create(
      {
        balanceType: 'user:tabcoin',
        recipientId: newContent.owner_id,
        amount: amountToDebit,
        originatorType: options.eventId ? 'event' : 'content',
        originatorId: options.eventId ? options.eventId : newContent.id,
      },
      {
        transaction: options.transaction,
      },
    );
    return;
  }

  if (
    // We should credit if the content is being created directly with "published" status.
    (!oldContent && newContent.published_at) ||
    // We should credit if the content already existed and is now being published for the first time.
    (oldContent && !oldContent.published_at && newContent.status === 'published')
  ) {
    contentEarnings = 1;
    userEarnings = await prestige.getByUserId(newContent.owner_id, {
      isRoot: !newContent.parent_id,
      transaction: options.transaction,
    });

    if (userEarnings < 0) {
      throw new ForbiddenError({
        message: 'Não é possível publicar porque há outras publicações mal avaliadas que ainda não foram excluídas.',
        action: 'Exclua seus conteúdos mais recentes que estiverem classificados como não relevantes.',
        errorLocationCode: 'MODEL:CONTENT:CREDIT_OR_DEBIT_TABCOINS:NEGATIVE_USER_EARNINGS',
      });
    }

    // We should not credit TabCoins to the user if the "type" is not "content".
    if (newContent.type !== 'content') {
      userEarnings = 0;
    }

    // We should not credit if the content has little or no value.
    if (newContent.body.split(/[a-z]{5,}/i, 6).length < 6) return;

    if (newContent.parent_id) {
      let parentOwnerId = newContent.parent_owner_id;

      if (parentOwnerId === undefined) {
        const queryParent = {
          text: `SELECT owner_id FROM contents WHERE id = $1;`,
          values: [newContent.parent_id],
        };
        const parentQueryResult = await database.query(queryParent, options);
        const parentContent = parentQueryResult.rows[0];
        parentOwnerId = parentContent.owner_id;
      }

      // We should not credit if the parent content is from the same user.
      if (parentOwnerId === newContent.owner_id) return;
    }
  }

  if (userEarnings > 0) {
    await balance.create(
      {
        balanceType: 'user:tabcoin',
        recipientId: newContent.owner_id,
        amount: userEarnings,
        originatorType: options.eventId ? 'event' : 'content',
        originatorId: options.eventId ? options.eventId : newContent.id,
      },
      {
        transaction: options.transaction,
      },
    );
  }

  if (contentEarnings > 0) {
    await balance.create(
      {
        balanceType: 'content:tabcoin:initial',
        recipientId: newContent.id,
        amount: contentEarnings,
        originatorType: 'user',
        originatorId: newContent.owner_id,
      },
      {
        transaction: options.transaction,
      },
    );
  }
}

async function updateTabCashBalance(oldContent, newContent, options = {}) {
  if (newContent.type === 'content') {
    return;
  }

  const initialTabCash = 100;

  const userBalance = await balance.create(
    {
      balanceType: 'user:tabcash',
      recipientId: newContent.owner_id,
      amount: -initialTabCash,
      originatorType: options.eventId ? 'event' : 'content',
      originatorId: options.eventId ? options.eventId : newContent.id,
    },
    {
      transaction: options.transaction,
      withBalance: true,
    },
  );

  if (userBalance.total < 0) {
    throw new UnprocessableEntityError({
      message: `Não foi possível criar a publicação.`,
      action: `Você precisa de pelo menos ${Math.abs(initialTabCash)} TabCash para realizar esta ação.`,
      errorLocationCode: 'MODEL:CONTENT:UPDATE_TABCASH:NOT_ENOUGH',
    });
  }

  const contentBalance = await balance.create(
    {
      balanceType: 'ad:budget',
      recipientId: newContent.id,
      amount: initialTabCash,
      originatorType: 'user',
      originatorId: newContent.owner_id,
    },
    {
      transaction: options.transaction,
      withBalance: true,
    },
  );

  newContent.tabcash = contentBalance.total;
}

async function update(contentId, postedContent, options = {}) {
  const validPostedContent = validateUpdateSchema(postedContent);

  const oldContent =
    options.oldContent ??
    (await findOne(
      {
        where: {
          id: contentId,
        },
      },
      options,
    ));

  const newContent = { ...oldContent, ...validPostedContent };

  throwIfContentIsAlreadyDeleted(oldContent);
  throwIfContentPublishedIsChangedToDraft(oldContent, newContent);
  checkRootContentTitle(newContent);

  populatePublishedAtValue(oldContent, newContent);
  populateDeletedAtValue(newContent);

  const updatedContent = await runUpdateQuery(newContent, options);

  if (!options.skipBalanceOperations) {
    await creditOrDebitTabCoins(oldContent, updatedContent, {
      eventId: options.eventId,
      transaction: options.transaction,
    });
  }

  const tabcoinsCount = await balance.getContentTabcoinsCreditDebit(
    {
      recipientId: updatedContent.id,
    },
    {
      transaction: options.transaction,
    },
  );
  updatedContent.tabcoins = tabcoinsCount.tabcoins;
  updatedContent.tabcoins_credit = tabcoinsCount.tabcoins_credit;
  updatedContent.tabcoins_debit = tabcoinsCount.tabcoins_debit;

  return updatedContent;

  async function runUpdateQuery(content, options = {}) {
    const query = {
      text: `
      WITH
        updated_content as (
          UPDATE contents SET
            slug = $2,
            title = $3,
            body = $4,
            status = $5,
            source_url = $6,
            published_at = $7,
            updated_at = (now() at time zone 'utc'),
            deleted_at = $8
          WHERE
            id = $1
          RETURNING *
        )
      SELECT
        updated_content.id,
        updated_content.owner_id,
        updated_content.parent_id,
        updated_content.slug,
        updated_content.title,
        updated_content.body,
        updated_content.status,
        updated_content.type,
        updated_content.source_url,
        updated_content.created_at,
        updated_content.updated_at,
        updated_content.published_at,
        updated_content.deleted_at,
        updated_content.path,
        users.username as owner_username
      FROM
        updated_content
      INNER JOIN
        users ON updated_content.owner_id = users.id
      ;`,
      values: [
        content.id,
        content.slug,
        content.title,
        content.body,
        content.status,
        content.source_url,
        content.published_at,
        content.deleted_at,
      ],
    };
    try {
      const results = await database.query(query, { transaction: options.transaction });
      return results.rows[0];
    } catch (error) {
      throw parseQueryErrorToCustomError(error);
    }
  }
}

async function confirmFirewallStatus(contentIds, options) {
  const query = {
    text: `
      WITH updated_contents AS (
        UPDATE contents SET
          status = 'deleted',
          deleted_at = CASE
            WHEN deleted_at IS NULL THEN (now() at time zone 'utc')
            ELSE deleted_at
          END
        WHERE
          id = ANY ($1)
        RETURNING
          *)
      
      SELECT
        updated_contents.*,
        tabcoins_count.total_balance as tabcoins,
        tabcoins_count.total_credit as tabcoins_credit,
        tabcoins_count.total_debit as tabcoins_debit,
        users.username as owner_username,
        (
          SELECT COUNT(*)
          FROM contents as children
          WHERE children.path @> ARRAY[updated_contents.id]
           AND children.status = 'published'
        ) as children_deep_count
      FROM
        updated_contents
      INNER JOIN
        users ON updated_contents.owner_id = users.id
      LEFT JOIN LATERAL
        get_content_balance_credit_debit(updated_contents.id) tabcoins_count ON true
      ;`,
    values: [contentIds],
  };

  const results = await database.query(query, options);
  return results.rows;
}

async function undoFirewallStatus(contentIds, options) {
  const query = {
    text: `
      WITH updated_contents AS (
        UPDATE contents SET
          status = CASE
            WHEN deleted_at IS NULL THEN 'published'
            ELSE 'deleted'
          END
        WHERE
          id = ANY ($1)
        RETURNING
          *
      )
  
      SELECT
        updated_contents.*,
        tabcoins_count.total_balance as tabcoins,
        tabcoins_count.total_credit as tabcoins_credit,
        tabcoins_count.total_debit as tabcoins_debit,
        users.username as owner_username,
        (
          SELECT COUNT(*)
          FROM contents as children
          LEFT JOIN updated_contents as uc ON children.id = uc.id
          WHERE children.path @> ARRAY[updated_contents.id]
           AND COALESCE(uc.status, children.status) = 'published'
        ) as children_deep_count
      FROM
        updated_contents
      INNER JOIN
        users ON updated_contents.owner_id = users.id
      LEFT JOIN LATERAL
        get_content_balance_credit_debit(updated_contents.id) tabcoins_count ON true
      ;`,
    values: [contentIds],
  };

  const results = await database.query(query, options);
  return results.rows;
}

function validateUpdateSchema(content) {
  const cleanValues = validator(content, {
    slug: 'optional',
    title: 'optional',
    body: 'optional',
    status: 'optional',
    source_url: 'optional',
  });

  if (cleanValues.status === 'firewall') {
    throw new ValidationError({
      message: 'Não é possível atualizar um conteúdo para o status "firewall".',
      key: 'status',
      type: 'any.only',
      errorLocationCode: 'MODEL:CONTENT:VALIDATE_UPDATE_SCHEMA:INVALID_STATUS',
    });
  }

  return cleanValues;
}

function populateDeletedAtValue(contentObject) {
  if (!contentObject.deleted_at && contentObject.status === 'deleted') {
    contentObject.deleted_at = new Date();
  }
}

function throwIfContentIsAlreadyDeleted(oldContent) {
  if (oldContent.status === 'deleted') {
    throw new ValidationError({
      message: `Não é possível alterar informações de um conteúdo já deletado.`,
      stack: new Error().stack,
      errorLocationCode: 'MODEL:CONTENT:CHECK_STATUS_CHANGE:STATUS_ALREADY_DELETED',
      statusCode: 400,
      key: 'status',
    });
  }
}

function throwIfContentPublishedIsChangedToDraft(oldContent, newContent) {
  if (oldContent.status === 'published' && newContent.status === 'draft') {
    throw new ValidationError({
      message: `Não é possível alterar para rascunho um conteúdo já publicado.`,
      stack: new Error().stack,
      errorLocationCode: 'MODEL:CONTENT:CHECK_STATUS_CHANGE:STATUS_ALREADY_PUBLISHED',
      statusCode: 400,
      key: 'status',
    });
  }
}

async function findTree(options = {}) {
  options.where = validateWhereSchema(options.where);
  let values;
  if (options.where.parent_id) {
    values = [options.where.parent_id];
  } else if (options.where.id) {
    values = [options.where.id];
  } else if (options.where.slug) {
    values = [options.where.owner_username, options.where.slug];
  }

  const flatList = await databaseLookup(options);
  return flatListToTree(flatList);

  async function databaseLookup(options) {
    const queryChildrenByParentId = `
      SELECT
        *,
        users.username as owner_username,
        tabcoins_count.total_balance as tabcoins,
        tabcoins_count.total_credit as tabcoins_credit,
        tabcoins_count.total_debit as tabcoins_debit
      FROM
        contents
      INNER JOIN
        users ON owner_id = users.id
      LEFT JOIN LATERAL
        get_content_balance_credit_debit(c.id) tabcoins_count ON true
      WHERE
        path @> ARRAY[$1]::uuid[] AND
        status = 'published';`;

    const queryTree = `
      WITH parent AS (SELECT * FROM contents
        WHERE
          ${options.where.id ? 'contents.id = $1 AND' : ''}
          ${options.where.owner_username ? `${whereOwnerUsername('$1')} AND` : ''}
          ${options.where.slug ? 'contents.slug = $2 AND' : ''}
          contents.status = 'published')

      SELECT
        parent.*,
        users.username as owner_username,
        tabcoins_count.total_balance as tabcoins,
        tabcoins_count.total_credit as tabcoins_credit,
        tabcoins_count.total_debit as tabcoins_debit
      FROM
        parent
      INNER JOIN
        users ON parent.owner_id = users.id
      LEFT JOIN LATERAL
        get_content_balance_credit_debit(parent.id) tabcoins_count ON true

      UNION ALL

      SELECT
        c.*,
        users.username as owner_username,
        tabcoins_count.total_balance as tabcoins,
        tabcoins_count.total_credit as tabcoins_credit,
        tabcoins_count.total_debit as tabcoins_debit
      FROM
        contents c
      INNER JOIN
        parent ON c.path @> ARRAY[parent.id]::uuid[]
      INNER JOIN
        users ON c.owner_id = users.id
      LEFT JOIN LATERAL
        get_content_balance_credit_debit(c.id) tabcoins_count ON true
      WHERE
        c.status = 'published';`;

    const query = {
      text: options.where.parent_id ? queryChildrenByParentId : queryTree,
      values: values,
    };
    const results = await database.query(query);
    return results.rows;
  }

  function validateWhereSchema(where) {
    const options = {};

    if (where.parent_id) {
      options.parent_id = 'required';
    } else if (where.slug) {
      options.owner_username = 'required';
      options.slug = 'required';
    } else {
      options.id = 'required';
    }

    const cleanValues = validator(where, options);

    return cleanValues;
  }

  function flatListToTree(list) {
    const tree = { children: [] };
    const table = {};

    list.forEach((row) => {
      table[row.id] = row;
      table[row.id].children = [];
    });

    list.forEach((row) => {
      if (table[row.parent_id]) {
        table[row.parent_id].children.push(row);
      } else if (!row.path.some((id) => table[id])) {
        tree.children.push(row);
      } else {
        let currentNode = row;
        let parentId = currentNode.parent_id;

        while (parentId && !table[parentId]) {
          table[parentId] = {
            id: parentId,
            children: [currentNode],
            path: currentNode.path.slice(0, -1),
            parent_id: currentNode.path.at(-2) || null,
          };
          currentNode = table[parentId];
          parentId = currentNode.parent_id;
        }

        if (parentId) {
          table[parentId].children.push(currentNode);
        }
      }
    });

    recursiveInjectChildrenDeepCount(tree);

    return tree.children;

    function recursiveInjectChildrenDeepCount(node) {
      let count = 0;

      for (const child of node.children) {
        if (child.status === 'published') count++;
      }

      if (node.children) {
        node.children = rankContentListByRelevance(node.children);
        node.children.forEach((child) => {
          count += recursiveInjectChildrenDeepCount(child);
        });
      }

      node.children_deep_count = count;
      return count;
    }
  }
}

function whereOwnerUsername($n) {
  return `
  contents.owner_id = (
    SELECT id FROM users
    WHERE
      LOWER(username) = LOWER(${$n})
    LIMIT 1)
  `;
}

function rankContentListByRelevance(contentList) {
  const rankedContentList = contentList.map(injectScoreProperty).sort(sortByScore);

  return rankedContentList;

  function injectScoreProperty(contentObject) {
    return {
      ...contentObject,
      score: getContentScore(contentObject),
    };
  }

  function sortByScore(first, second) {
    return second.score - first.score;
  }
}

// Inspired by:
// https://medium.com/hacking-and-gonzo/how-hacker-news-ranking-algorithm-works-1d9b0cf2c08d
// https://medium.com/hacking-and-gonzo/how-reddit-ranking-algorithms-work-ef111e33d0d9
const ageBaseInMilliseconds = 1000 * 60 * 60 * 6; // 6 hours
const boostPeriodInMilliseconds = 1000 * 60 * 10; // 10 minutes
const offset = 0.5;

function getContentScore(contentObject) {
  if (contentObject.status !== 'published') {
    return -10;
  }

  const tabcoins = contentObject.tabcoins;
  const ageInMilliseconds = Date.now() - new Date(contentObject.published_at);
  const initialBoost = ageInMilliseconds < boostPeriodInMilliseconds ? 3 : 1;
  const gravity = Math.exp(-ageInMilliseconds / ageBaseInMilliseconds);
  const score = (tabcoins - offset) * initialBoost;
  const finalScore = tabcoins > 0 ? score * (1 + gravity) : score * (1 - gravity);
  return finalScore;
}

export default Object.freeze({
  findAll,
  findOne,
  findTree,
  findWithStrategy,
  create,
  update,
  confirmFirewallStatus,
  undoFirewallStatus,
  creditOrDebitTabCoins,
});
</file>

<file path="models/controller.js">
import { truncate } from '@tabnews/helpers';
import { waitUntil } from '@vercel/functions';
import { randomUUID as uuidV4 } from 'node:crypto';
import snakeize from 'snakeize';

import {
  ForbiddenError,
  InternalServerError,
  MethodNotAllowedError,
  NotFoundError,
  TooManyRequestsError,
  UnauthorizedError,
  UnprocessableEntityError,
  ValidationError,
} from 'errors';
import logger from 'infra/logger.js';
import webserver from 'infra/webserver.js';
import ip from 'models/ip.js';

function injectRequestMetadata(request, response, next) {
  request.context = {
    ...request.context,
    requestId: request.headers['x-vercel-id'] || uuidV4(),
    clientIp: ip.extractFromRequest(request),
  };

  if (next) {
    return next();
  }
}

function onNoMatchHandler(request, response) {
  if (request.method === 'OPTIONS') {
    return response.status(200).end();
  }

  injectRequestMetadata(request);
  const publicErrorObject = new MethodNotAllowedError({
    message: `Método "${request.method}" não permitido para "${request.url}".`,
    action: 'Utilize um método HTTP válido para este recurso.',
    requestId: request.context?.requestId || uuidV4(),
  });

  const privateErrorObject = { ...publicErrorObject, context: { ...request.context } };
  logger.info(snakeize(privateErrorObject));

  return errorResponse(response, publicErrorObject.statusCode, snakeize(publicErrorObject));
}

function onErrorHandler(error, request, response) {
  if (
    error instanceof UnauthorizedError ||
    error instanceof ValidationError ||
    error instanceof MethodNotAllowedError ||
    error instanceof NotFoundError ||
    error instanceof ForbiddenError ||
    error instanceof UnprocessableEntityError ||
    error instanceof TooManyRequestsError
  ) {
    const publicErrorObject = { ...error, requestId: request.context.requestId };

    const privateErrorObject = { ...publicErrorObject, context: { ...request.context } };
    logger.info(snakeize(privateErrorObject));

    return errorResponse(response, error.statusCode, snakeize(publicErrorObject));
  }

  const publicErrorObject = new InternalServerError({
    requestId: request.context?.requestId,
    errorId: error.errorId,
    statusCode: error.statusCode,
    errorLocationCode: error.errorLocationCode,
  });

  const privateErrorObject = {
    ...new InternalServerError({
      ...error,
      requestId: request.context?.requestId,
    }),
    context: { ...request.context },
  };

  logger.error(snakeize(privateErrorObject));

  return errorResponse(response, publicErrorObject.statusCode, snakeize(publicErrorObject));
}

function errorResponse(response, statusCode, publicErrorObject) {
  response.status(statusCode);

  const isStream = response.getHeader('Content-Type') === 'application/x-ndjson';
  if (isStream) {
    response.write(JSON.stringify(publicErrorObject) + '\n');
    response.end();
  }

  return response.json(publicErrorObject);
}

function logRequest(request, response, next) {
  const { headers, body, context } = request;

  const log = {
    headers: clearHeaders(headers),
    body: clearBody(body),
    context: clearContext(context),
  };

  logger.info(log);

  let resolve;
  const flushPromise = new Promise((res) => (resolve = res));

  waitUntil(flushPromise);

  response.on('close', async () => {
    await logger.flush();
    resolve();
  });

  return next();
}

const headersToRedact = ['authorization', 'cookie'];
const headerToOmit = ['access-control-allow-headers', 'forwarded', 'x-vercel-proxy-signature', 'x-vercel-sc-headers'];

function clearHeaders(headers) {
  const cleanHeaders = { ...headers };

  headersToRedact.forEach((header) => {
    if (cleanHeaders[header]) {
      cleanHeaders[header] = '**';
    }
  });

  headerToOmit.forEach((header) => {
    delete cleanHeaders[header];
  });

  return [cleanHeaders];
}

const bodyToRedact = ['email', 'password'];

function clearBody(requestBody) {
  const cleanBody = { ...requestBody };

  if (typeof cleanBody.body === 'string') {
    cleanBody.body = truncate(cleanBody.body, 300);
  }

  bodyToRedact.forEach((key) => {
    if (cleanBody[key]) {
      cleanBody[key] = '**';
    }
  });

  return [cleanBody];
}

function clearContext(context) {
  const cleanContext = { ...context };

  if (cleanContext.user) {
    cleanContext.user = {
      id: context.user.id,
      username: context.user.username,
    };
  }

  return cleanContext;
}

function injectPaginationHeaders(pagination, endpoint, request, response) {
  const links = [];
  const baseUrl = `${webserver.host}${endpoint}`;

  const searchParams = new URLSearchParams();

  const acceptedParams = ['strategy', 'with_root', 'with_children', 'page', 'per_page'];

  acceptedParams.forEach((param) => {
    if (request?.query?.[param] !== undefined) {
      searchParams.set(param, request.query[param]);
    }
  });

  const pages = [
    { page: pagination.firstPage, rel: 'first' },
    { page: pagination.previousPage, rel: 'prev' },
    { page: pagination.nextPage, rel: 'next' },
    { page: pagination.lastPage, rel: 'last' },
  ];

  for (const { page, rel } of pages) {
    if (page) {
      searchParams.set('page', page);
      links.push(`<${baseUrl}?${searchParams.toString()}>; rel="${rel}"`);
    }
  }

  const linkHeaderString = links.join(', ');

  response.setHeader('Link', linkHeaderString);
  response.setHeader('X-Pagination-Total-Rows', pagination.totalRows);
}

const handlerOptions = {
  onNoMatch: onNoMatchHandler,
  onError: onErrorHandler,
};

export default Object.freeze({
  handlerOptions,
  injectRequestMetadata,
  logRequest,
  injectPaginationHeaders,
});
</file>

<file path="models/email-confirmation.js">
import { NotFoundError } from 'errors';
import database from 'infra/database.js';
import email from 'infra/email.js';
import webserver from 'infra/webserver.js';
import { ConfirmationEmail } from 'models/transactional';
import user from 'models/user.js';

async function createAndSendEmail(user, newEmail, options) {
  const tokenObject = await create(user.id, newEmail, options);
  await sendEmailToUser(user, newEmail, tokenObject.id);

  return tokenObject;
}

async function create(userId, newEmail, options) {
  const query = {
    text: `
      INSERT INTO
        email_confirmation_tokens (user_id, email, expires_at)
      VALUES
        ($1, $2, now() + interval '15 minutes')
      RETURNING
        *
      ;`,
    values: [userId, newEmail],
  };

  const results = await database.query(query, options);
  return results.rows[0];
}

async function sendEmailToUser(user, newEmail, tokenId) {
  const emailConfirmationPageEndpoint = getEmailConfirmationPageEndpoint(tokenId);

  const { html, text } = ConfirmationEmail({
    username: user.username,
    confirmationLink: emailConfirmationPageEndpoint,
  });

  await email.triggerSend({
    from: 'TabNews <contato@tabnews.com.br>',
    to: newEmail,
    subject: 'Confirme seu novo email',
    html,
    text,
  });
}

function getEmailConfirmationPageEndpoint(tokenId) {
  return `${webserver.host}/perfil/confirmar-email/${tokenId}`;
}

async function findOneTokenByUserId(userId) {
  const query = {
    text: `
      SELECT
        *
      FROM
        email_confirmation_tokens
      WHERE
        user_id = $1
      LIMIT
        1
    ;`,
    values: [userId],
  };
  const results = await database.query(query);

  if (results.rowCount === 0) {
    throw new NotFoundError({
      message: `O token de recuperação de senha utilizado não foi encontrado no sistema.`,
      action: 'Certifique-se que está sendo enviado o token corretamente.',
      stack: new Error().stack,
    });
  }

  return results.rows[0];
}

async function markTokenAsUsedById(tokenId) {
  const query = {
    text: `
      UPDATE
        email_confirmation_tokens
      SET
        used = true,
        updated_at = (now() at time zone 'utc')
      WHERE
        id = $1
        AND used = false
        AND expires_at >= now()
      RETURNING
        *
    ;`,
    values: [tokenId],
  };

  const results = await database.query(query);

  if (results.rowCount === 0) {
    throw new NotFoundError({
      message: `O token de confirmação de email utilizado não foi encontrado no sistema ou expirou.`,
      action: 'Solicite uma nova alteração de email.',
      stack: new Error().stack,
      errorLocationCode: 'MODEL:EMAIL_CONFIRMATION:FIND_ONE_VALID_TOKEN_BY_ID:NOT_FOUND',
      key: 'token_id',
    });
  }

  return results.rows[0];
}

async function confirmEmailUpdate(tokenId) {
  const usedToken = await markTokenAsUsedById(tokenId);
  await user.update({ id: usedToken.user_id }, { email: usedToken.email }, { skipEmailConfirmation: true });

  return usedToken;
}

export default Object.freeze({
  create,
  createAndSendEmail,
  findOneTokenByUserId,
  getEmailConfirmationPageEndpoint,
  confirmEmailUpdate,
});
</file>

<file path="models/event.js">
import database from 'infra/database.js';
import validator from 'models/validator.js';

async function create(object, options = {}) {
  const cleanObject = validateObject(object);

  const query = {
    text: `INSERT INTO events (type, originator_user_id, originator_ip, metadata)
               VALUES($1, $2, $3, $4) RETURNING *;`,
    values: [cleanObject.type, cleanObject.originator_user_id, cleanObject.originator_ip, cleanObject.metadata],
  };

  const results = await database.query(query, options);
  return results.rows[0];
}

function validateObject(object) {
  const cleanObject = validator(object, {
    event: 'required',
  });

  return cleanObject;
}

export default Object.freeze({
  create,
});
</file>

<file path="models/health.js">
import { performance } from 'perf_hooks';

import database from 'infra/database';
import logger from 'infra/logger';

async function getDependencies() {
  const dependenciesHandlersToCheck = [
    {
      name: 'database',
      handler: checkDatabaseDependency,
    },
    {
      name: 'webserver',
      handler: checkWebserverDependency,
    },
  ];

  const promises = dependenciesHandlersToCheck.map(async ({ name, handler }) => {
    const dependencyResult = await handler();

    return {
      name,
      result: dependencyResult,
    };
  });

  const checkedDependencies = await Promise.all(promises);

  // group dependencies by name
  return checkedDependencies.reduce((accumulator, currentDependency) => {
    accumulator[currentDependency.name] = currentDependency.result;

    return accumulator;
  }, {});
}

async function checkDatabaseDependency() {
  let result;
  try {
    const firstQueryTimer = performance.now();
    const [maxConnectionsResult, superuserReservedConnectionsResult] = await database.query(
      'SHOW max_connections; SHOW superuser_reserved_connections;',
    );
    const maxConnectionsValue = maxConnectionsResult.rows[0].max_connections;
    const superuserReservedConnectionsValue = superuserReservedConnectionsResult.rows[0].superuser_reserved_connections;
    const firstQueryDuration = performance.now() - firstQueryTimer;

    const secondQueryTimer = performance.now();
    const openConnectionsResult = await database.query({
      text: 'SELECT numbackends as opened_connections FROM pg_stat_database where datname = $1',
      values: [process.env.POSTGRES_DB],
    });
    const openConnectionsValue = openConnectionsResult.rows[0].opened_connections;
    const secondQueryDuration = performance.now() - secondQueryTimer;

    const thirdQueryTimer = performance.now();
    const versionResult = await database.query('SHOW server_version;');
    const versionResultValue = versionResult.rows[0].server_version;
    const thirdQueryDuration = performance.now() - thirdQueryTimer;

    result = {
      status: 'healthy',
      max_connections: parseInt(maxConnectionsValue) - parseInt(superuserReservedConnectionsValue),
      opened_connections: openConnectionsValue,
      latency: {
        first_query: firstQueryDuration,
        second_query: secondQueryDuration,
        third_query: thirdQueryDuration,
      },
      version: versionResultValue,
    };
  } catch (error) {
    logger.error(error);
    result = {
      status: 'unhealthy',
    };
  }

  return result;
}

function checkWebserverDependency() {
  return {
    status: 'healthy',
    provider: process.env.VERCEL ? 'vercel' : 'local',
    environment: process.env.VERCEL_ENV ? process.env.VERCEL_ENV : 'local',
    aws_region: process.env.AWS_REGION,
    vercel_region: process.env.VERCEL_REGION,
    timezone: process.env.TZ,
    last_commit_author: process.env.VERCEL_GIT_COMMIT_AUTHOR_LOGIN,
    last_commit_message: process.env.VERCEL_GIT_COMMIT_MESSAGE,
    last_commit_message_sha: process.env.VERCEL_GIT_COMMIT_SHA,
    version: process.version,
  };
}

export default Object.freeze({
  getDependencies,
});
</file>

<file path="models/ip.js">
import { isInSubnet, isIP } from 'is-in-subnet';

import webserver from 'infra/webserver';

function extractFromRequest(request) {
  if (isRequestFromCloudflare(request)) {
    // Vercel via Cloudflare
    return request instanceof Request
      ? request.headers.get('cf-connecting-ip') // edge runtime
      : request.headers['cf-connecting-ip']; // node runtime
  }

  let realIp;

  if (request instanceof Request) {
    // edge runtime
    realIp = webserver.isServerlessRuntime
      ? request.headers.get('x-vercel-proxied-for')?.split(', ').at(-1) // Vercel
      : request.headers.get('x-forwarded-for')?.split(', ').at(-1); // remote development
  } else {
    // node runtime
    realIp = webserver.isServerlessRuntime
      ? request.headers['x-vercel-proxied-for']?.split(', ').at(-1) // Vercel
      : request.headers['x-forwarded-for']?.split(', ').at(-1); // remote development
  }

  if (!realIp) {
    // local development
    realIp = request.socket?.remoteAddress || '127.0.0.1';
  }

  if (!webserver.isServerlessRuntime) {
    // Localhost loopback in IPv6
    if (realIp === '::1') {
      realIp = '127.0.0.1';
    }

    // IPv4-mapped IPv6 addresses
    if (realIp.substr(0, 7) == '::ffff:') {
      realIp = realIp.substr(7);
    }
  }

  return realIp;
}

function isRequestFromCloudflare(request) {
  const proxyIp =
    request instanceof Request
      ? request.headers.get('x-vercel-proxied-for')?.split(', ').at(-1) // edge runtime
      : request.headers['x-vercel-proxied-for']?.split(', ').at(-1); // node runtime

  return !!isIP(proxyIp) && isInSubnet(proxyIp, cloudflareIPs);
}

const cloudflareIPs = [
  '172.64.0.0/13',
  '162.158.0.0/15',
  '108.162.192.0/18',
  '198.41.128.0/17',
  '173.245.48.0/20',
  '103.21.244.0/22',
  '103.22.200.0/22',
  '103.31.4.0/22',
  '141.101.64.0/18',
  '190.93.240.0/20',
  '188.114.96.0/20',
  '197.234.240.0/22',
  '104.16.0.0/13',
  '104.24.0.0/14',
  '131.0.72.0/22',
  '2400:cb00::/32',
  '2606:4700::/32',
  '2803:f800::/32',
  '2405:b500::/32',
  '2405:8100::/32',
  '2a06:98c0::/29',
  '2c0f:f248::/32',
];

export default Object.freeze({
  extractFromRequest,
  isRequestFromCloudflare,
});
</file>

<file path="models/notification.js">
import { truncate } from '@tabnews/helpers';

import email from 'infra/email.js';
import webserver from 'infra/webserver.js';
import authorization from 'models/authorization.js';
import content from 'models/content.js';
import { FirewallEmail, NotificationEmail } from 'models/transactional';
import user from 'models/user.js';

async function sendReplyEmailToParentUser(createdContent) {
  const anonymousUser = user.createAnonymous();
  const secureCreatedContent = authorization.filterOutput(anonymousUser, 'read:content', createdContent);

  const parentContent = await content.findOne({
    where: {
      id: secureCreatedContent.parent_id,
    },
  });

  if (parentContent.owner_id !== secureCreatedContent.owner_id && secureCreatedContent.status === 'published') {
    const parentContentUser = await user.findOneById(parentContent.owner_id);

    if (parentContentUser.notifications === false) {
      return;
    }

    const childContentUrl = getContentUrl(secureCreatedContent);
    const rootContent = parentContent.parent_id
      ? await content.findOne({
          where: {
            id: parentContent.path[0],
          },
          attributes: { exclude: ['body'] },
        })
      : parentContent;

    const secureRootContent = authorization.filterOutput(anonymousUser, 'read:content', rootContent);

    const subject = getReplyEmailSubject({
      createdContent: secureCreatedContent,
      rootContent: secureRootContent,
    });

    const bodyReplyLine = getBodyReplyLine({
      createdContent: secureCreatedContent,
      rootContent: secureRootContent,
    });

    const { html, text } = NotificationEmail({
      username: parentContentUser.username,
      bodyReplyLine: bodyReplyLine,
      contentLink: childContentUrl,
    });

    await email.triggerSend({
      to: parentContentUser.email,
      from: 'TabNews <contato@tabnews.com.br>',
      subject: subject,
      html,
      text,
    });
  }
}

function getReplyEmailSubject({ createdContent, rootContent }) {
  const sanitizedRootContentTitle =
    rootContent.status === 'published' ? truncate(rootContent.title, 58) : '[Não disponível]';
  return `"${createdContent.owner_username}" comentou em "${sanitizedRootContentTitle}"`;
}

function getBodyReplyLine({ createdContent, rootContent }) {
  const sanitizedRootContentTitle = rootContent.status === 'published' ? rootContent.title : '[Não disponível]';

  if (createdContent.parent_id === rootContent.id) {
    return `"${createdContent.owner_username}" respondeu à sua publicação "${sanitizedRootContentTitle}".`;
  }

  return `"${createdContent.owner_username}" respondeu ao seu comentário na publicação "${sanitizedRootContentTitle}".`;
}

function getContentUrl({ owner_username, slug }) {
  return `${webserver.host}/${owner_username}/${slug}`;
}

async function sendUserDisabled({ eventId, user }) {
  const { html, text } = FirewallEmail({
    sideEffectLine: 'Identificamos a criação de muitos usuários em um curto período, então a sua conta foi desativada.',
    eventId: eventId,
    username: user.username,
  });

  await email.triggerSend({
    to: user.email,
    from: 'TabNews <contato@tabnews.com.br>',
    subject: 'Sua conta foi desativada',
    html,
    text,
  });
}

async function sendContentDeletedToUser({ contents, eventId, userId }) {
  const deletedContentLine = getFirewallDeletedContentLine(contents);

  const subject = contents.length > 1 ? 'Alguns conteúdos seus foram removidos' : 'Um conteúdo seu foi removido';

  const userToNotify = await user.findOneById(userId);

  const { html, text } = FirewallEmail({
    sideEffectLine: deletedContentLine,
    eventId: eventId,
    username: userToNotify.username,
  });

  await email.triggerSend({
    to: userToNotify.email,
    from: 'TabNews <contato@tabnews.com.br>',
    subject: subject,
    html,
    text,
  });
}

function getFirewallDeletedContentLine(contents) {
  const formatter = new Intl.ListFormat('pt-BR');
  const contentsReference = contents.map((content) => `"${content.title ?? content.id}"`);
  const formattedList = formatter.format(contentsReference);
  const isRootContent = !!contents[0].title;

  let beforeTitles;
  let afterTitles;
  if (isRootContent) {
    if (contents.length > 1) {
      beforeTitles = 'muitas publicações em um curto período, então as suas publicações';
      afterTitles = 'foram removidas';
    } else {
      beforeTitles = 'muitas publicações em um curto período, então a sua publicação';
      afterTitles = 'foi removida';
    }
  } else {
    if (contents.length > 1) {
      beforeTitles = 'muitos comentários em um curto período, então os seus comentários de IDs';
      afterTitles = 'foram removidos';
    } else {
      beforeTitles = 'muitos comentários em um curto período, então o seu comentário de ID';
      afterTitles = 'foi removido';
    }
  }

  return `Identificamos a criação de ${beforeTitles} ${formattedList} ${afterTitles}.`;
}

export default Object.freeze({
  sendContentDeletedToUser,
  sendReplyEmailToParentUser,
  sendUserDisabled,
});
</file>

<file path="models/pagination.js">
function get({ total_rows, page, per_page }) {
  const firstPage = 1;
  const lastPage = Math.ceil(total_rows / per_page) || 1;
  const nextPage = page >= lastPage ? null : page + 1;
  const previousPage = page <= 1 ? null : page > lastPage ? lastPage : page - 1;

  const pagination = {
    currentPage: page,
    totalRows: total_rows,
    perPage: per_page,
    firstPage: firstPage,
    nextPage: nextPage,
    previousPage: previousPage,
    lastPage: lastPage,
  };

  return pagination;
}

export default Object.freeze({
  get,
});
</file>

<file path="models/password.js">
import bcryptjs from 'bcryptjs';

import webserver from 'infra/webserver.js';

async function hash(password) {
  return await bcryptjs.hash(password, getNumberOfSaltRounds());
}

async function compare(providedPassword, storedPassword) {
  return await bcryptjs.compare(providedPassword, storedPassword);
}

function getNumberOfSaltRounds() {
  let saltRounds = 14;

  if (!webserver.isServerlessRuntime) {
    saltRounds = 1;
  }

  return saltRounds;
}

export default Object.freeze({
  hash,
  compare,
});
</file>

<file path="models/prestige.js">
import db from 'infra/database';
import query from 'queries/prestigeQueries';

async function getByContentId(contentId, { transaction, database = db } = {}) {
  const result = await database.query(
    {
      text: query.byContentId,
      values: [contentId],
    },
    { transaction },
  );

  let initialTabcoins = 0;

  const totalTabcoins = result.rows.reduce((acc, row) => {
    if (row.type === 'create:content:text_root' || row.type === 'create:content:text_child') {
      initialTabcoins = row.amount;
    }
    return acc + row.amount;
  }, 0);

  return {
    initialTabcoins,
    totalTabcoins,
  };
}

async function getByUserId(
  userId,
  {
    timeOffset = new Date(Date.now() - 1000 * 60 * 60 * 24 * 2), // 2 days ago
    offset = 3,
    isRoot = false,
    limit = 20,
    transaction,
    database = db,
  } = {},
) {
  const result = await database.query(
    {
      text: query.byUserId,
      values: [userId, timeOffset, isRoot, limit, offset],
    },
    { transaction },
  );

  const mean = calcTabcoinsAverage(result.rows);

  return calcPrestigeLevel(mean, isRoot);
}

function calcTabcoinsAverage(tabcoinsObjectArray) {
  const length = tabcoinsObjectArray?.length;

  if (!length || typeof length !== 'number') {
    return 1; // TabCoins default balance
  }

  const tabcoins = tabcoinsObjectArray.reduce((acc, { tabcoins }) => acc + (tabcoins || 0), 0);

  return tabcoins / length;
}

function calcPrestigeLevel(mean, isRoot) {
  if (isRoot) {
    if (0.5 >= mean) return -1;
    if (1.1 >= mean) return 0;
    if (1.2 >= mean) return 1;
    if (1.3 >= mean) return 2;
    if (1.4 >= mean) return 3;
    if (1.6 >= mean) return 4;
    if (1.8 >= mean) return 5;
    if (2.1 >= mean) return 6;
    if (2.4 >= mean) return 7;
  } else {
    if (0.4 >= mean) return -1;
    if (1.0 >= mean) return 0;
    if (1.1 >= mean) return 1;
    if (1.2 >= mean) return 2;
    if (1.25 >= mean) return 3;
    if (1.3 >= mean) return 4;
    if (1.5 >= mean) return 5;
    if (1.7 >= mean) return 6;
    if (2.0 >= mean) return 7;
  }

  return Math.ceil(mean + 5);
}

export default Object.freeze({
  calcPrestigeLevel,
  calcTabcoinsAverage,
  getByContentId,
  getByUserId,
});
</file>

<file path="models/recovery.js">
import { InternalServerError, NotFoundError } from 'errors';
import database from 'infra/database.js';
import email from 'infra/email.js';
import webserver from 'infra/webserver.js';
import session from 'models/session';
import { RecoveryEmail } from 'models/transactional';
import user from 'models/user.js';

async function requestPasswordRecovery(secureInputValues) {
  try {
    const userFound = await findUserByUsernameOrEmail(secureInputValues);
    const validTokensCount = await countValidTokensByUserId(userFound.id);

    if (validTokensCount >= 2) {
      return buildFakeToken();
    }

    const tokenObject = await create(userFound);
    await sendEmailToUser(userFound, tokenObject.id);

    return tokenObject;
  } catch (error) {
    if (error instanceof NotFoundError && error.key === 'email') {
      return buildFakeToken();
    }

    throw error;
  }
}

async function findUserByUsernameOrEmail({ username, email }) {
  if (username) {
    return await user.findOneByUsername(username);
  }

  if (email) {
    return await user.findOneByEmail(email);
  }
}

async function countValidTokensByUserId(userId) {
  const query = {
    text: `SELECT COUNT(*) FROM reset_password_tokens
        WHERE user_id = $1
        AND used = false
        AND expires_at >= now();`,
    values: [userId],
  };
  const results = await database.query(query);

  return Number(results.rows[0].count);
}

function buildFakeToken() {
  const now = new Date();
  const expiresAt = new Date(now.getTime() + 1000 * 60 * 15);

  return {
    used: false,
    expires_at: expiresAt,
    created_at: now,
    updated_at: now,
  };
}

async function create(user) {
  const query = {
    text: `INSERT INTO reset_password_tokens (user_id, expires_at)
           VALUES($1, now() + interval '15 minutes') RETURNING *;`,
    values: [user.id],
  };

  const results = await database.query(query);
  return results.rows[0];
}

async function sendEmailToUser(user, tokenId) {
  const recoverPageEndpoint = getRecoverPageEndpoint(tokenId);

  const { html, text } = RecoveryEmail({
    username: user.username,
    recoveryLink: recoverPageEndpoint,
  });

  await email.triggerSend({
    from: 'TabNews <contato@tabnews.com.br>',
    to: user.email,
    subject: 'Recuperação de Senha',
    html,
    text,
  });
}

function getRecoverPageEndpoint(tokenId) {
  return `${webserver.host}/cadastro/recuperar/${tokenId}`;
}

async function resetUserPassword(secureInputValues) {
  const tokenObject = await findOneValidTokenById(secureInputValues.token_id);
  const userToken = await markTokenAsUsed(tokenObject.id);

  await session.expireAllFromUserId(tokenObject.user_id);
  await user.update({ id: tokenObject.user_id }, { password: secureInputValues.password });

  return userToken;
}

async function findOneTokenById(tokenId) {
  if (process.env.NODE_ENV !== 'test') {
    throw new InternalServerError({
      message: '"recovery.findOneTokenById" só pode ser utilizado em ambiente de testes.',
      action: 'Verifique se o ambiente está correto.',
      errorLocationCode: 'MODEL:RECOVERY:FIND_ONE_TOKEN_BY_ID:INVALID_ENVIRONMENT',
    });
  }

  const query = {
    text: `SELECT * FROM reset_password_tokens
        WHERE id = $1
        LIMIT 1;`,
    values: [tokenId],
  };
  const results = await database.query(query);

  if (results.rowCount === 0) {
    throw new NotFoundError({
      message: `O token de recuperação de senha utilizado não foi encontrado no sistema.`,
      action: 'Certifique-se que está sendo enviado o token corretamente.',
      stack: new Error().stack,
    });
  }

  return results.rows[0];
}

async function findOneValidTokenById(tokenId) {
  const query = {
    text: `SELECT * FROM reset_password_tokens
        WHERE id = $1
        AND used = false
        AND expires_at >= now()
        LIMIT 1;`,
    values: [tokenId],
  };

  const results = await database.query(query);

  if (results.rowCount === 0) {
    throw new NotFoundError({
      message: `O token de recuperação de senha utilizado não foi encontrado no sistema ou expirou.`,
      action: 'Solicite uma nova recuperação de senha.',
      errorLocationCode: 'MODEL:RECOVERY:FIND_ONE_VALID_TOKEN_BY_ID:NOT_FOUND',
      key: 'token_id',
    });
  }

  return results.rows[0];
}

async function findOneTokenByUserId(userId) {
  if (process.env.NODE_ENV !== 'test') {
    throw new InternalServerError({
      message: '"findOneTokenByUserId" só pode ser utilizado em ambiente de testes.',
      action: 'Verifique se o ambiente está correto.',
      errorLocationCode: 'MODEL:RECOVERY:FIND_ONE_TOKEN_BY_USER_ID:INVALID_ENVIRONMENT',
    });
  }

  const query = {
    text: `SELECT * FROM reset_password_tokens
        WHERE user_id = $1
        ORDER BY created_at DESC
        LIMIT 1;`,
    values: [userId],
  };
  const results = await database.query(query);

  if (results.rowCount === 0) {
    throw new NotFoundError({
      message: `O token de recuperação de senha utilizado não foi encontrado no sistema.`,
      action: 'Certifique-se que está sendo enviado o token corretamente.',
      stack: new Error().stack,
    });
  }

  return results.rows[0];
}

async function markTokenAsUsed(tokenId) {
  const query = {
    text: `UPDATE reset_password_tokens
            SET used = true,
            updated_at = (now() at time zone 'utc')
            WHERE id = $1
            RETURNING *;`,
    values: [tokenId],
  };

  const results = await database.query(query);
  return results.rows[0];
}

async function update(tokenId, tokenBody) {
  if (process.env.NODE_ENV !== 'test') {
    throw new InternalServerError({
      message: '"recovery.update" só pode ser utilizado em ambiente de testes.',
      action: 'Verifique se o ambiente está correto.',
      errorLocationCode: 'MODEL:RECOVERY:UPDATE:INVALID_ENVIRONMENT',
    });
  }

  const currentToken = await findOneTokenById(tokenId);
  const updatedToken = { ...currentToken, ...tokenBody };

  const query = {
    text: `UPDATE reset_password_tokens SET
            user_id = $2,
            used = $3,
            expires_at = $4,
            created_at = $5,
            updated_at = $6
            WHERE id = $1
            RETURNING *;`,
    values: [
      tokenId,
      updatedToken.user_id,
      updatedToken.used,
      updatedToken.expires_at,
      updatedToken.created_at,
      updatedToken.updated_at,
    ],
  };

  const results = await database.query(query);

  return results.rows[0];
}

export default Object.freeze({
  create,
  findOneTokenById,
  findOneTokenByUserId,
  getRecoverPageEndpoint,
  requestPasswordRecovery,
  resetUserPassword,
  update,
});
</file>

<file path="models/remove-markdown.js">
import { trimEnd, trimStart, truncate } from '@tabnews/helpers';
import removeMarkdown from 'remove-markdown';

import logger from 'infra/logger';

export default function customRemoveMarkdown(md, options = {}) {
  options.oneLine = Object.hasOwn(options, 'oneLine') ? options.oneLine : true;
  options.throwError = Object.hasOwn(options, 'logError') ? options.throwError : true;
  options.trim = Object.hasOwn(options, 'trim') ? options.trim : true;

  let output = md || '';

  try {
    output = removeMarkdown(md, options);

    if (options.oneLine) {
      output = output.replace(/\s+/g, ' ');
    }

    if (options.trim) {
      output = trimStart(output);
      output = trimEnd(output);
    }

    output = truncate(output, options.maxLength);
  } catch (e) {
    if (options.throwError) {
      logger.error(e);
    }

    return md;
  }
  return output;
}
</file>

<file path="models/reward.js">
import database from 'infra/database';
import balance from 'models/balance';
import content from 'models/content.js';
import event from 'models/event';
import prestige from 'models/prestige';
import user from 'models/user';

const tabcoinsBase = 20;
const contentAgeBase = 604_800_000; // one week in milliseconds

export default async function reward(request, dbOptions = {}) {
  if (request?.context?.user?.tabcoins === undefined) return 0;

  const { id: userId, username, tabcoins, rewarded_at: rewardedAt } = request.context.user;

  if (!userId || !username || !rewardedAt) return 0;

  const utcZeroHourToday = new Date().setUTCHours(0, 0, 0, 0);

  if (rewardedAt >= utcZeroHourToday) return 0;

  const prestigeFactor = await prestige.getByUserId(userId, dbOptions);
  const tabcoinsFactor = calcTabcoinsFactor(tabcoins);

  let reward = 0;

  if (tabcoinsFactor <= prestigeFactor) {
    const contentAgeFactor = await getContentAgeFactor(userId);
    reward = calcReward(prestigeFactor, tabcoinsFactor, contentAgeFactor);
  }

  reward = await saveReward(request, reward, dbOptions);

  return reward;
}

function calcTabcoinsFactor(tabcoins) {
  if (tabcoins <= 0) return 0;

  const tabcoinsFactor = Math.floor((tabcoins / tabcoinsBase) ** 2);

  return tabcoinsFactor;
}

async function getContentAgeFactor(owner_id) {
  const contents = await content.findWithStrategy({
    strategy: 'new',
    where: {
      owner_id,
      status: 'published',
      type: 'content',
    },
    per_page: 1,
  });

  const lastContent = contents?.rows?.[0];

  if (!lastContent) return 0;

  const lastContentAge = new Date() - new Date(lastContent.created_at);

  return Math.ceil(lastContentAge / contentAgeBase);
}

function calcReward(prestige, tabcoinsFactor, contentAgeFactor) {
  if (!contentAgeFactor || prestige <= tabcoinsFactor) return 0;

  const reward = Math.ceil((prestige - tabcoinsFactor) / contentAgeFactor);

  return reward;
}

async function saveReward(request, reward, { transaction }) {
  transaction = transaction || (await database.transaction());

  try {
    await transaction.query('BEGIN');
    await transaction.query('SET TRANSACTION ISOLATION LEVEL REPEATABLE READ');

    if (reward > 0) {
      const currentUser = await user.findOneById(request.context.user.id, { transaction });

      const utcZeroHourToday = new Date().setUTCHours(0, 0, 0, 0);

      if (currentUser.rewarded_at >= utcZeroHourToday) {
        throw new Error('User already rewarded today');
      }

      const currentEvent = await event.create(
        {
          type: 'reward:user:tabcoins',
          originator_user_id: request.context.user.id,
          originator_ip: request.context.clientIp,
          metadata: {
            reward_type: 'daily',
            amount: reward,
          },
        },
        { transaction },
      );

      await balance.create(
        {
          balanceType: 'user:tabcoin',
          recipientId: request.context.user.id,
          amount: reward,
          originatorType: 'event',
          originatorId: currentEvent.id,
        },
        { transaction },
      );
    }

    await user.updateRewardedAt(request.context.user.id, { transaction });

    await transaction.query('COMMIT');

    return reward;
  } catch (error) {
    await transaction.query('ROLLBACK');

    if (
      error.databaseErrorCode === database.errorCodes.SERIALIZATION_FAILURE ||
      error.stack?.startsWith('error: could not serialize access due to concurrent update') ||
      error.message === 'User already rewarded today'
    ) {
      return 0;
    } else {
      throw error;
    }
  } finally {
    await transaction.release();
  }
}
</file>

<file path="models/rss.js">
import { Feed } from 'feed';
import { renderToStaticMarkup } from 'react-dom/server';

import { Viewer } from '@/TabNewsUI';
import webserver from 'infra/webserver.js';
import removeMarkdown from 'models/remove-markdown';

function generateRss2(contentList) {
  const webserverHost = webserver.host;

  // TODO: make this property flexible in the future to
  // support things like: `/[username]/rss`
  const feedURL = `${webserverHost}/recentes/rss`;

  const feed = new Feed({
    title: 'TabNews',
    description: 'Conteúdos para quem trabalha com Programação e Tecnologia',
    id: feedURL,
    link: feedURL,
    image: `${webserverHost}/favicon-mobile.png`,
    favicon: `${webserverHost}/favicon-mobile.png`,
    language: 'pt',
    updated: contentList.length > 0 ? new Date(contentList[0].updated_at) : new Date(),
    feedLinks: {
      rss2: feedURL,
    },
  });

  contentList.forEach((contentObject) => {
    const contentUrl = `${webserverHost}/${contentObject.owner_username}/${contentObject.slug}`;

    feed.addItem({
      title: contentObject.title,
      id: contentUrl,
      link: contentUrl,
      description: removeMarkdown(contentObject.body, { maxLength: 190 }),
      content: renderToStaticMarkup(
        <Viewer value={contentObject.body} clobberPrefix={`${contentObject.owner_username}-content-`} />,
      ).replace(/[\r\n]/gm, ''),
      author: [
        {
          name: contentObject.owner_username,
          link: `${webserverHost}/${contentObject.owner_username}`,
        },
      ],
      date: new Date(contentObject.published_at),
    });
  });

  return feed.rss2();
}

export default Object.freeze({
  generateRss2,
});
</file>

<file path="models/session.js">
import cookie from 'cookie';
import crypto from 'node:crypto';

import { UnauthorizedError } from 'errors';
import database from 'infra/database.js';
import cacheControl from 'models/cache-control';
import validator from 'models/validator.js';

const SESSION_EXPIRATION_IN_SECONDS = 60 * 60 * 24 * 30; // 30 days

async function create(userId) {
  const sessionToken = crypto.randomBytes(48).toString('hex');
  const expiresAt = new Date(Date.now() + 1000 * SESSION_EXPIRATION_IN_SECONDS);

  const query = {
    text: `INSERT INTO sessions (token, user_id, expires_at)
               VALUES($1, $2, $3) RETURNING *;`,
    values: [sessionToken, userId, expiresAt],
  };

  const results = await database.query(query);
  return results.rows[0];
}

function setSessionIdCookieInResponse(sessionToken, response) {
  cacheControl.noCache(undefined, response);
  response.setHeader('Set-Cookie', [
    cookie.serialize('session_id', sessionToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      path: '/',
      maxAge: SESSION_EXPIRATION_IN_SECONDS,
    }),
  ]);
}

async function expireById(id) {
  const query = {
    text: `
      UPDATE
        sessions
      SET
        expires_at = created_at - interval '1 day',
        updated_at = now()
      WHERE
        id = $1
      RETURNING
        *
      ;`,
    values: [id],
  };

  const results = await database.query(query);
  return results.rows[0];
}

async function expireAllFromUserId(userId, options = {}) {
  const query = {
    text: `
      UPDATE
        sessions
      SET
        expires_at = created_at - interval '1 day',
        updated_at = now()
      WHERE
        user_id = $1
        AND expires_at >= now()
      RETURNING
        *
      ;`,
    values: [userId],
  };

  const results = await database.query(query, options);
  return results;
}

// TODO: mark session as invalid also in Database.
function clearSessionIdCookie(response) {
  cacheControl.noCache(undefined, response);
  response.setHeader('Set-Cookie', [
    cookie.serialize('session_id', 'invalid', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      path: '/',
      maxAge: -1,
    }),
  ]);
}

async function findOneValidByToken(sessionToken) {
  validator(
    {
      session_id: sessionToken,
    },
    {
      session_id: 'required',
    },
  );

  const query = {
    text: `SELECT * FROM sessions WHERE token = $1 AND expires_at > now();`,
    values: [sessionToken],
  };

  const results = await database.query(query);
  return results.rows[0];
}

async function findOneById(sessionId) {
  const query = {
    text: `SELECT * FROM sessions WHERE id = $1;`,
    values: [sessionId],
  };

  const results = await database.query(query);
  return results.rows[0];
}

async function findOneValidFromRequest(request, response) {
  const sessionObject = await findOneValidByToken(request.cookies?.session_id);

  if (!sessionObject) {
    clearSessionIdCookie(response);

    throw new UnauthorizedError({
      message: `Usuário não possui sessão ativa.`,
      action: `Verifique se este usuário está logado.`,
    });
  }

  return sessionObject;
}

async function renew(sessionId, response) {
  const sessionObjectRenewed = await renewObjectInDatabase(sessionId);
  setSessionIdCookieInResponse(sessionObjectRenewed.token, response);
  return sessionObjectRenewed;

  async function renewObjectInDatabase(sessionId) {
    const expiresAt = new Date(Date.now() + 1000 * SESSION_EXPIRATION_IN_SECONDS);

    const query = {
      text: `UPDATE sessions SET
              expires_at = $2,
              updated_at = now()
            WHERE id = $1
            RETURNING *;`,
      values: [sessionId, expiresAt],
    };

    const results = await database.query(query);
    return results.rows[0];
  }
}

export default Object.freeze({
  create,
  setSessionIdCookieInResponse,
  expireById,
  expireAllFromUserId,
  clearSessionIdCookie,
  findOneValidByToken,
  findOneById,
  findOneValidFromRequest,
  renew,
});
</file>

<file path="models/thumbnail.js">
/* eslint-disable @next/next/no-img-element */
import { renderAsync } from '@resvg/resvg-js';
import { truncate } from '@tabnews/helpers';
import fs from 'node:fs';
import { join, resolve } from 'node:path';
import satori from 'satori';

import content from 'models/content.js';
import removeMarkdown from 'models/remove-markdown';

async function asPng(contentObject) {
  let parentContentObject;
  if (contentObject.parent_id) {
    parentContentObject = await content.findOne({
      where: {
        id: contentObject.parent_id,
      },
    });
  }

  const parsedContent = parseContent(contentObject, parentContentObject);

  const svg = await satori(renderTemplate(parsedContent), {
    width: 1200,
    height: 630,
    fonts: [
      {
        name: 'Roboto',
        data: fs.readFileSync(join(resolve('.'), 'fonts', 'Roboto-Regular.ttf')),
        weight: 400,
        style: 'normal',
      },
      {
        name: 'Roboto',
        data: fs.readFileSync(join(resolve('.'), 'fonts', 'Roboto-Bold.ttf')),
        weight: 700,
        style: 'normal',
      },
      {
        name: 'NotoEmoji',
        data: fs.readFileSync(join(resolve('.'), 'fonts', 'NotoEmoji-Bold.ttf')),
        weight: 700,
        style: 'normal',
      },
    ],
  });

  const renderBuffer = await renderAsync(svg);

  return renderBuffer.asPng();
}

export function parseContent(content, parentContent) {
  let title = content.title;

  if (!title) {
    title = removeMarkdown(content.body, { maxLength: 120 });
  }

  const parent_title = truncate(parentContent?.title || parentContent?.owner_username || '', 60);

  const date = new Date(content.published_at).toLocaleDateString('pt-BR');

  return {
    title,
    parentTitle: parent_title,
    username: content.owner_username,
    comments: content.children_deep_count,
    date,
  };
}

export function renderTemplate({ title, parentTitle, username, comments, date }) {
  return (
    <div
      style={{
        display: 'flex',
        flexDirection: 'column',
        width: '100%',
        height: '100%',
        padding: '80px 60px 60px',
        fontFamily: 'Roboto',
        backgroundColor: '#F5F5F5',
      }}>
      <div
        style={{
          display: 'flex',
          width: '100%',
        }}>
        <div
          style={{
            display: 'flex',
            flex: 1,
            flexDirection: 'column',
          }}>
          {!!parentTitle && (
            <div
              style={{
                display: 'flex',
                paddingBottom: 32,
                gap: 12,
                color: '#424C56',
              }}>
              <div
                style={{
                  display: 'block',
                  fontSize: 32,
                }}>
                Em resposta a
              </div>
              <div
                style={{
                  display: 'block',
                  flex: 1,
                  fontSize: 32,
                  lineClamp: 1,
                  textDecoration: 'underline',
                }}>
                {parentTitle}
              </div>
            </div>
          )}

          <div
            style={{
              display: 'block',
              fontSize: 74,
              lineHeight: 1.25,
              fontWeight: 'bold',
              lineClamp: 3,
              color: '#212529',
            }}>
            {title}
          </div>
        </div>

        <img
          src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODMiIGhlaWdodD0iNjciIHZpZXdCb3g9IjAgMCA4MyA2NyIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik03MC4zNzQ2IDAuNUM3Ny4yMDkzIDAuNSA4Mi43NDk2IDYuMDQwNDkgODIuNzQ5NiAxMi44NzVWNTQuMTI1QzgyLjc0OTYgNjAuOTU5NyA3Ny4yMDkzIDY2LjUgNzAuMzc0NiA2Ni41SDEyLjYyNDhDNS43OTAyMSA2Ni41IDAuMjQ5NzU2IDYwLjk1OTcgMC4yNDk3NTYgNTQuMTI1VjEyLjg3NUMwLjI0OTc1NiA2LjA0MDQ5IDUuNzkwMjEgMC41IDEyLjYyNDggMC41SDcwLjM3NDZaTTc0LjQ5OTYgMjMuNzAyM0g0NS42MjVDNDMuMzQ3MiAyMy43MDIzIDQwLjg1NzMgMjEuOTcwOSA0MC4wNjQ1IDE5LjgzNTJMMzUuOTQ4NiA4Ljc1SDEyLjYyNDhDMTAuMzQ2NiA4Ljc1IDguNDk5NzYgMTAuNTk2OCA4LjQ5OTc2IDEyLjg3NVY1NC4xMjVDOC40OTk3NiA1Ni40MDMyIDEwLjM0NjYgNTguMjUgMTIuNjI0OCA1OC4yNUg3MC4zNzQ2QzcyLjY1MjggNTguMjUgNzQuNDk5NiA1Ni40MDMyIDc0LjQ5OTYgNTQuMTI1VjIzLjcwMjNaIiBmaWxsPSIjMjEyNTI5Ii8+Cjwvc3ZnPgo="
          width={82.5}
          height={66}
          style={{ marginLeft: 40 }}
        />
      </div>

      <div
        style={{
          display: 'flex',
          flex: 1,
        }}></div>

      <div
        style={{
          display: 'flex',
          alignItems: 'center',
          width: '100%',
        }}>
        <div
          style={{
            padding: 20,
            backgroundColor: '#C7D9EC',
            color: '#424C56',
            borderRadius: 6,
            fontSize: 32,
          }}>
          {username}
        </div>

        <div
          style={{
            display: 'flex',
            flex: 1,
          }}></div>

        <div
          style={{
            display: 'flex',
            alignItems: 'center',
            fontSize: 32,
            gap: 20,
            color: '#424C56',
          }}>
          <img
            src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzAiIHZpZXdCb3g9IjAgMCAzMiAzMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTE2IDAuMzMzMzI4QzcuMTYyNjcgMC4zMzMzMjggMCA2LjQzMDY2IDAgMTMuOTUwN0MwIDE3LjEzNzMgMS4yNDI2NyAyMC4wNzIgMy4yMzYgMjIuMTY5M0wwIDI5LjY2NjdMMTAuMDg0IDI2LjY1MzNDMjIuNzQ0IDMwLjExNzMgMzIgMjIuMzE4NyAzMiAxMy45NTA3QzMyIDYuNDMwNjYgMjQuODM3MyAwLjMzMzMyOCAxNiAwLjMzMzMyOFoiIGZpbGw9IiM4RUExQjQiLz4KPC9zdmc+Cg=="
            width={32}
            height={30}
          />
          <div>{comments}</div>

          <div></div>

          <img
            src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzEiIHZpZXdCb3g9IjAgMCAzMiAzMSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTE4LjY2NjcgMTYuMzMzM0gxMy4zMzMzVjExSDE4LjY2NjdWMTYuMzMzM1pNMjYuNjY2NyAxMUgyMS4zMzMzVjE2LjMzMzNIMjYuNjY2N1YxMVpNMTAuNjY2NyAxOUg1LjMzMzMzVjI0LjMzMzNIMTAuNjY2N1YxOVpNMTguNjY2NyAxOUgxMy4zMzMzVjI0LjMzMzNIMTguNjY2N1YxOVpNMTAuNjY2NyAxMUg1LjMzMzMzVjE2LjMzMzNIMTAuNjY2N1YxMVpNMzIgMC4zMzMzMjhWMTguMTgxM0MzMiAyMS4zNjkzIDIzLjEzNiAzMSAxOC45MTg3IDMxSDBWMC4zMzMzMjhIMzJaTTI5LjMzMzMgOC4zMzMzM0gyLjY2NjY3VjI4LjMzMzNIMTcuODE2QzIzLjM1NzMgMjguMzMzMyAyMS4zMzMzIDIwLjMzMzMgMjEuMzMzMyAyMC4zMzMzQzIxLjMzMzMgMjAuMzMzMyAyOS4zMzMzIDIyLjUzMzMgMjkuMzMzMyAxNy4wNTczVjguMzMzMzNaIiBmaWxsPSIjOEVBMUI0Ii8+Cjwvc3ZnPgo="
            width={32}
            height={30}
          />

          <div>{date}</div>
        </div>
      </div>
    </div>
  );
}

export default Object.freeze({
  asPng,
});
</file>

<file path="models/umami.js">
import snakeize from 'snakeize';

import { ServiceError } from 'errors';
import logger from 'infra/logger';

function createUmamiService() {
  const apiEndpoint = process.env.UMAMI_API_ENDPOINT || `${process.env.NEXT_PUBLIC_UMAMI_ENDPOINT}/api`;
  const websiteId = process.env.NEXT_PUBLIC_UMAMI_WEBSITE_ID;
  const username = process.env.UMAMI_API_CLIENT_USERNAME || 'admin';
  const password = process.env.UMAMI_API_CLIENT_PASSWORD || 'umami';
  const apiKeys = [];

  while (process.env[`UMAMI_API_KEY_${apiKeys.length + 1}`]) {
    apiKeys.push(process.env[`UMAMI_API_KEY_${apiKeys.length + 1}`]);
  }

  apiKeys.sort(() => Math.random() - 0.5);

  const cache = {
    currentKeyIndex: 0,
  };

  cache.statsUrl = new URL(`${apiEndpoint}/websites/${websiteId}/stats`);
  cache.statsUrl.searchParams.append('startAt', 0);
  cache.statsUrl.searchParams.append('endAt', 8000000000000); // 2223-07-06T14:13:20.000Z

  async function getStatsByPath(path, attempt = 1) {
    const url = new URL(cache.statsUrl);
    url.searchParams.append('url', path);

    let response;

    try {
      response = await fetch(url, {
        headers: await getHeaders(),
      });

      if (response.ok) {
        const data = await response.json();

        return {
          pageviews: data.pageviews?.value,
          visitors: data.visitors?.value,
          visits: data.visits?.value,
        };
      }

      if (response.status === 429) {
        throw new Error('Umami API rate limit exceeded');
      }

      throw new Error(`Failed to fetch data from Umami API: ${response.statusText}`);
    } catch (error) {
      const errorObject = new ServiceError({
        message: error.message || 'Failed to fetch data from Umami API',
        statusCode: response?.status,
        errorLocationCode: 'INFRA:ANALYTICS:GET_STATS_BY_PATH',
      });

      logger.error(snakeize(errorObject));

      if (attempt < apiKeys.length) {
        return await getStatsByPath(path, attempt + 1);
      }
    }
  }

  async function getHeaders() {
    if (apiKeys.length) {
      const apiKey = apiKeys[cache.currentKeyIndex];
      cache.currentKeyIndex = (cache.currentKeyIndex + 1) % apiKeys.length;

      return {
        'x-umami-api-key': apiKey,
      };
    }

    return {
      Authorization: await getAuthorization(),
    };
  }

  async function getAuthorization() {
    if (!cache.authorization) {
      const token = await fetch(`${apiEndpoint}/auth/login`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username,
          password,
        }),
      })
        .then((res) => res.json())
        .then((data) => data.token);

      cache.authorization = `Bearer ${token}`;
    }

    return cache.authorization;
  }

  return Object.freeze({
    getStatsByPath,
  });
}

export default createUmamiService();
</file>

<file path="models/user-features.js">
const availableFeatures = new Set([
  // USER
  'create:user',
  'read:user',
  'read:user:self',
  'update:user',

  // MIGRATION
  'read:migration',
  'create:migration',

  // ACTIVATION_TOKEN
  'read:activation_token',

  // RECOVERY_TOKEN
  'read:recovery_token',

  // EMAIL_CONFIRMATION_TOKEN
  'read:email_confirmation_token',

  // SESSION
  'create:session',
  'read:session',

  // CONTENT
  'read:content',
  'update:content',
  'create:content',
  'create:content:text_root',
  'create:content:text_child',
  'read:content:list',
  'read:content:tabcoins',

  // MODERATION
  'read:user:list',
  'read:votes:others',
  'update:content:others',
  'update:user:others',
  'ban:user',
  'create:recovery_token:username',
  'read:firewall',
  'review:firewall',

  // BANNED
  'nuked',

  // ADVERTISEMENT
  'read:ad:list',
]);

export default Object.freeze(availableFeatures);
</file>

<file path="models/user.js">
import { NotFoundError, ValidationError } from 'errors';
import database from 'infra/database.js';
import authentication from 'models/authentication.js';
import emailConfirmation from 'models/email-confirmation.js';
import pagination from 'models/pagination.js';
import validator from 'models/validator.js';

async function findAll(values = {}, options) {
  const where = values.where ?? {};

  const whereClause = buildWhereClause(where);
  const query = {
    text: `
      SELECT
        *
      FROM
        users
      CROSS JOIN LATERAL (
        SELECT
          get_user_current_tabcoins(users.id) as tabcoins,
          get_user_current_tabcash(users.id) as tabcash
      ) as balance
      ${whereClause.text}
      ORDER BY
        created_at ASC
      ;`,
    values: whereClause.values,
  };

  const results = await database.query(query, options);
  return results.rows;
}

function buildWhereClause(where, nextArgumentIndex = 1) {
  const values = [];
  const conditions = Object.entries(where).map(([column, value]) => {
    values.push(value);
    return Array.isArray(value) ? `${column} = ANY ($${nextArgumentIndex++})` : `${column} = $${nextArgumentIndex++}`;
  });

  return {
    text: conditions.length ? `WHERE ${conditions.join(' AND ')}` : '',
    values: values,
    nextArgumentIndex: nextArgumentIndex,
  };
}

async function findAllWithPagination(values) {
  const offset = (values.page - 1) * values.per_page;

  const query = {
    text: `
      WITH user_window AS (
        SELECT
          COUNT(*) OVER()::INTEGER as total_rows,
          id
        FROM users
        ORDER BY updated_at DESC
        LIMIT $1 OFFSET $2
      )

      SELECT
        *
      FROM
        users
      INNER JOIN
        user_window ON users.id = user_window.id
      CROSS JOIN LATERAL (
        SELECT
          get_user_current_tabcoins(users.id) as tabcoins,
          get_user_current_tabcash(users.id) as tabcash
      ) as balance
      ORDER BY updated_at DESC
    `,
    values: [values.limit || values.per_page, offset],
  };

  const queryResults = await database.query(query);

  const results = {
    rows: queryResults.rows,
  };

  values.total_rows = results.rows[0]?.total_rows ?? (await countTotalRows());

  results.pagination = pagination.get(values);

  return results;
}

async function countTotalRows() {
  const countQuery = `SELECT COUNT(*) OVER()::INTEGER as total_rows FROM users`;
  const countResult = await database.query(countQuery);
  return countResult.rows[0].total_rows;
}

async function findOneByUsername(username, options = {}) {
  const baseQuery = `
      WITH user_found AS (
        SELECT
          *
        FROM
          users
        WHERE
          LOWER(username) = LOWER($1)
          AND NOT 'nuked' = ANY(features)
        LIMIT
          1
      )`;

  const balanceQuery = `
      SELECT
        user_found.*,
        get_user_current_tabcoins(user_found.id) as tabcoins,
        get_user_current_tabcash(user_found.id) as tabcash
      FROM
        user_found
      `;

  const queryText = options.withBalance ? `${baseQuery} ${balanceQuery};` : `${baseQuery} SELECT * FROM user_found;`;

  const query = {
    text: queryText,
    values: [username],
  };

  const results = await database.query(query, options);

  if (results.rowCount === 0) {
    throw new NotFoundError({
      message: `O "username" informado não foi encontrado no sistema.`,
      action: 'Verifique se o "username" está digitado corretamente.',
      stack: new Error().stack,
      errorLocationCode: 'MODEL:USER:FIND_ONE_BY_USERNAME:NOT_FOUND',
      key: 'username',
    });
  }

  return results.rows[0];
}

async function findOneByEmail(email, options = {}) {
  const baseQuery = `
      WITH user_found AS (
        SELECT
          *
        FROM
          users
        WHERE
          LOWER(email) = LOWER($1)
          AND NOT 'nuked' = ANY(features)
        LIMIT
          1
      )`;

  const balanceQuery = `
      SELECT
        user_found.*,
        get_user_current_tabcoins(user_found.id) as tabcoins,
        get_user_current_tabcash(user_found.id) as tabcash
      FROM
        user_found
      `;

  const queryText = options.withBalance ? `${baseQuery} ${balanceQuery};` : `${baseQuery} SELECT * FROM user_found;`;

  const query = {
    text: queryText,
    values: [email],
  };

  const results = await database.query(query, options);

  if (results.rowCount === 0) {
    throw new NotFoundError({
      message: `O email informado não foi encontrado no sistema.`,
      action: 'Verifique se o "email" está digitado corretamente.',
      stack: new Error().stack,
      errorLocationCode: 'MODEL:USER:FIND_ONE_BY_EMAIL:NOT_FOUND',
      key: 'email',
    });
  }

  return results.rows[0];
}

async function findOneById(userId, options = {}) {
  const baseQuery = `
      WITH user_found AS (
        SELECT
          *
        FROM
          users
        WHERE
          id = $1
        LIMIT
          1
      )`;

  const balanceQuery = `
      SELECT
        user_found.*,
        get_user_current_tabcoins(user_found.id) as tabcoins,
        get_user_current_tabcash(user_found.id) as tabcash
      FROM
        user_found
      `;

  const queryText = options.withBalance ? `${baseQuery} ${balanceQuery};` : `${baseQuery} SELECT * FROM user_found;`;

  const query = {
    text: queryText,
    values: [userId],
  };

  const results = await database.query(query, options);

  if (results.rowCount === 0) {
    throw new NotFoundError({
      message: `O id "${userId}" não foi encontrado no sistema.`,
      action: 'Verifique se o "id" está digitado corretamente.',
      stack: new Error().stack,
      errorLocationCode: 'MODEL:USER:FIND_ONE_BY_ID:NOT_FOUND',
      key: 'id',
    });
  }

  return results.rows[0];
}

async function create(postedUserData) {
  const validUserData = validatePostSchema(postedUserData);
  await validateUniqueUser(validUserData);
  await deleteExpiredUsers(validUserData);
  await hashPasswordInObject(validUserData);

  validUserData.features = ['read:activation_token'];

  const newUser = await runInsertQuery(validUserData);
  return newUser;

  async function runInsertQuery(validUserData) {
    const query = {
      text: `
        INSERT INTO
          users (username, email, password, features)
        VALUES
          ($1, $2, $3, $4)
        RETURNING
          *
        ;`,
      values: [validUserData.username, validUserData.email, validUserData.password, validUserData.features],
    };

    const results = await database.query(query);
    const newUser = results.rows[0];

    newUser.tabcoins = 0;
    newUser.tabcash = 0;

    return newUser;
  }
}

function createAnonymous() {
  return {
    features: ['read:activation_token', 'create:session', 'create:user'],
  };
}

function validatePostSchema(postedUserData) {
  const cleanValues = validator(postedUserData, {
    username: 'required',
    email: 'required',
    password: 'required',
  });

  return cleanValues;
}

async function update(targetUser, postedUserData, options = {}) {
  const validPostedUserData = validatePatchSchema(postedUserData);

  const isTargetUserComplete = 'username' in targetUser;
  const needsTargetUserComplete = 'username' in validPostedUserData || 'email' in validPostedUserData;
  const currentUser =
    !isTargetUserComplete && needsTargetUserComplete
      ? await findOneById(targetUser.id, { transaction: options.transaction })
      : targetUser;

  const shouldValidateUsername =
    'username' in validPostedUserData &&
    currentUser.username.toLowerCase() !== validPostedUserData.username.toLowerCase();
  const shouldValidateEmail =
    'email' in validPostedUserData && validPostedUserData.email.toLowerCase() !== currentUser.email.toLowerCase();

  if (shouldValidateUsername || shouldValidateEmail) {
    try {
      await validateUniqueUser({ ...validPostedUserData, id: currentUser.id }, { transaction: options.transaction });
      await deleteExpiredUsers(validPostedUserData, { transaction: options.transaction });
      if (shouldValidateEmail && !options.skipEmailConfirmation) {
        await emailConfirmation.createAndSendEmail(currentUser, validPostedUserData.email, {
          transaction: options.transaction,
        });
        delete validPostedUserData.email;
      }
    } catch (error) {
      if (error instanceof ValidationError && error.key === 'email' && !options.skipEmailConfirmation) {
        delete validPostedUserData.email;
      } else {
        throw error;
      }
    }
  }

  if ('password' in validPostedUserData) {
    await hashPasswordInObject(validPostedUserData);
  }
  const updatedUser = await runUpdateQuery(currentUser, validPostedUserData, {
    transaction: options.transaction,
  });
  return updatedUser;

  async function runUpdateQuery(currentUser, valuesToUpdate, options) {
    const values = [currentUser.id];
    const setFields = [];

    for (const [field, newValue] of Object.entries(valuesToUpdate)) {
      if (newValue !== undefined) {
        values.push(newValue);
        setFields.push(`${field} = $${values.length}`);
      }
    }

    if (!setFields.length) {
      return currentUser;
    }

    const query = {
      text: `
        UPDATE
          users
        SET
          ${setFields.join(', ')},
          updated_at = (now() at time zone 'utc')
        WHERE
          id = $1
        RETURNING
          *,
          get_user_current_tabcoins($1) as tabcoins,
          get_user_current_tabcash($1) as tabcash
      ;`,
      values: values,
    };

    const results = await database.query(query, options);
    const updatedUser = results.rows[0];

    return updatedUser;
  }
}

function validatePatchSchema(postedUserData) {
  const cleanValues = validator(postedUserData, {
    username: 'optional',
    email: 'optional',
    password: 'optional',
    description: 'optional',
    notifications: 'optional',
  });

  return cleanValues;
}

async function validateUniqueUser(userData, options) {
  const orConditions = [];
  const queryValues = [];

  if (userData.username) {
    queryValues.push(userData.username);
    orConditions.push(`LOWER(u.username) = LOWER($${queryValues.length})`);
  }

  if (userData.email) {
    queryValues.push(userData.email);
    orConditions.push(`LOWER(u.email) = LOWER($${queryValues.length})`);
  }

  let where = `(${orConditions.join(' OR ')})`;

  if (userData.id) {
    queryValues.push(userData.id);
    where += ` AND u.id <> $${queryValues.length}`;
  }

  const query = {
    text: `
      SELECT
        u.username,
        u.email
      FROM
        users u
      LEFT JOIN activate_account_tokens aat ON user_id = u.id
      WHERE
        (
          COALESCE(aat.used, true)
          OR aat.expires_at > NOW()
          OR 'nuked' = ANY(u.features)
        )
        AND ${where}
    `,
    values: queryValues,
  };

  const results = await database.query(query, options);

  if (!results.rowCount) return;

  const isSameUsername = results.rows.some(
    ({ username }) => username.toLowerCase() === userData.username?.toLowerCase(),
  );

  if (isSameUsername) {
    throw new ValidationError({
      message: `O "username" informado já está sendo usado.`,
      stack: new Error().stack,
      errorLocationCode: `MODEL:USER:VALIDATE_UNIQUE_USERNAME:ALREADY_EXISTS`,
      key: 'username',
    });
  }

  throw new ValidationError({
    message: `O email informado já está sendo usado.`,
    stack: new Error().stack,
    errorLocationCode: `MODEL:USER:VALIDATE_UNIQUE_EMAIL:ALREADY_EXISTS`,
    key: 'email',
  });
}

async function deleteExpiredUsers(userObject, options) {
  const query = {
    text: `
      DELETE FROM
        users u
      WHERE
        (
          LOWER(u.username) = LOWER($1)
          OR LOWER(u.email) = LOWER($2)
        )
        AND NOT ('nuked' = ANY(u.features))
        AND NOT EXISTS (
          SELECT 1
          FROM activate_account_tokens aat
          WHERE aat.user_id = u.id
            AND (
              COALESCE(aat.used, true)
              OR aat.expires_at > NOW()
            )
        )
    ;`,
    values: [userObject.username, userObject.email],
  };

  await database.query(query, options);
}

async function hashPasswordInObject(userObject) {
  userObject.password = await authentication.hashPassword(userObject.password);
  return userObject;
}

async function removeFeatures(userId, features, options = {}) {
  let lastUpdatedUser;

  if (features?.length > 0) {
    for (const feature of features) {
      const query = {
        text: `
          UPDATE
            users
          SET
            features = array_remove(features, $1),
            updated_at = (now() at time zone 'utc')
          WHERE
            id = $2
          RETURNING
            *
        ;`,
        values: [feature, userId],
      };

      const results = await database.query(query, options);
      lastUpdatedUser = results.rows[0];
    }
  } else {
    const query = {
      text: `
        UPDATE
          users
        SET
          features = '{}',
          updated_at = (now() at time zone 'utc')
        WHERE
          id = $1
        RETURNING
          *
      ;`,
      values: [userId],
    };

    const results = await database.query(query, options);
    lastUpdatedUser = results.rows[0];
  }

  return lastUpdatedUser;
}

async function addFeatures(userId, features, options = {}) {
  const where = { id: userId };
  const firstWhereArgumentIndex = 2;
  const whereClause = buildWhereClause(where, firstWhereArgumentIndex);

  const updateQuery = `
    UPDATE
      users
    SET
      ${options.ignoreUpdatedAt ? '' : "updated_at = (now() at time zone 'utc'),"}
      features = array_cat(features, $1)
    ${whereClause.text}
    RETURNING
      *`;

  const updateWithBalanceQuery = `
    WITH updated_user AS (
      ${updateQuery}
    )
    SELECT
      updated_user.*,
      get_user_current_tabcoins(updated_user.id) as tabcoins,
      get_user_current_tabcash(updated_user.id) as tabcash
    FROM
      updated_user;
    `;

  const query = {
    text: options.withBalance ? updateWithBalanceQuery : updateQuery,
    values: [features, userId],
  };

  const results = await database.query(query, options);

  return Array.isArray(userId) ? results.rows : results.rows[0];
}

async function updateRewardedAt(userId, options) {
  if (!userId) {
    throw new ValidationError({
      message: `É necessário informar o "id" do usuário.`,
      stack: new Error().stack,
      errorLocationCode: 'MODEL:USER:UPDATE_REWARDED_AT:USER_ID_REQUIRED',
      key: 'userId',
    });
  }

  const query = {
    text: `
      UPDATE
        users
      SET
        rewarded_at = (now() at time zone 'utc')
      WHERE
        id = $1
      RETURNING
        *
    ;`,
    values: [userId],
  };

  const results = await database.query(query, options);

  return results.rows[0];
}

export default Object.freeze({
  create,
  findAll,
  findAllWithPagination,
  findOneByUsername,
  findOneByEmail,
  findOneById,
  update,
  removeFeatures,
  addFeatures,
  createAnonymous,
  updateRewardedAt,
});
</file>

<file path="models/validator.js">
import { trimEnd, trimStart } from '@tabnews/helpers';
import Joi from 'joi';

import { ValidationError } from 'errors';
import webserver from 'infra/webserver';
import removeMarkdown from 'models/remove-markdown';
import availableFeatures from 'models/user-features';

const MAX_INTEGER = 2147483647;
const MIN_INTEGER = -2147483648;

const cachedSchemas = {};

const defaultSchema = Joi.object()
  .label('body')
  .required()
  .min(1)
  .messages({
    'any.invalid': '{#label} possui o valor inválido "{#value}".',
    'any.only': '{#label} deve possuir um dos seguintes valores: {#valids}.',
    'any.required': '{#label} é um campo obrigatório.',
    'array.base': '{#label} deve ser do tipo Array.',
    'array.min': `{#label} deve possuir ao menos {#limit} {if(#limit==1, "elemento", "elementos")}.`,
    'boolean.base': '{#label} deve ser do tipo Boolean.',
    'date.base': '{#label} deve conter uma data válida.',
    'markdown.empty': 'Markdown deve conter algum texto.',
    'number.base': '{#label} deve ser do tipo Number.',
    'number.integer': '{#label} deve ser um Inteiro.',
    'number.max': '{#label} deve possuir um valor máximo de {#limit}.',
    'number.min': '{#label} deve possuir um valor mínimo de {#limit}.',
    'number.unsafe': `{#label} deve possuir um valor entre ${MIN_INTEGER} e ${MAX_INTEGER}.`,
    'object.base': '{#label} enviado deve ser do tipo Object.',
    'object.min': 'Objeto enviado deve ter no mínimo uma chave.',
    'string.alphanum': '{#label} deve conter apenas caracteres alfanuméricos.',
    'string.base': '{#label} deve ser do tipo String.',
    'string.email': '{#label} deve conter um email válido.',
    'string.empty': '{#label} não pode estar em branco.',
    'string.length': '{#label} deve possuir {#limit} {if(#limit==1, "caractere", "caracteres")}.',
    'string.ip': '{#label} deve possuir um IP válido.',
    'string.guid': '{#label} deve possuir um token UUID na versão 4.',
    'string.max': '{#label} deve conter no máximo {#limit} {if(#limit==1, "caractere", "caracteres")}.',
    'string.min': '{#label} deve conter no mínimo {#limit} {if(#limit==1, "caractere", "caracteres")}.',
    'username.reserved': 'Este nome de usuário não está disponível para uso.',
    'string.pattern.base': '{#label} está no formato errado.',
  });

export default function validator(object, keys) {
  // Force the clean up of "undefined" values since JSON
  // doesn't support them and Joi doesn't clean
  // them up. Also handles the case where the
  // "object" is not a valid JSON.
  try {
    object = JSON.parse(JSON.stringify(object));
  } catch (error) {
    throw new ValidationError({
      message: 'Não foi possível interpretar o valor enviado.',
      action: 'Verifique se o valor enviado é um JSON válido.',
      errorLocationCode: 'MODEL:VALIDATOR:ERROR_PARSING_JSON',
      stack: new Error().stack,
      key: 'object',
    });
  }

  const keysString = Object.keys(keys).join(',');

  if (!cachedSchemas[keysString]) {
    let finalSchema = defaultSchema;

    for (const key of Object.keys(keys)) {
      const keyValidationFunction = schemas[key];
      finalSchema = finalSchema.concat(keyValidationFunction());
    }
    cachedSchemas[keysString] = finalSchema;
  }

  const { error, value } = cachedSchemas[keysString].validate(object, {
    stripUnknown: true,
    context: {
      required: keys,
    },
    errors: {
      escapeHtml: true,
      wrap: {
        array: false,
        string: '"',
      },
    },
  });

  if (error) {
    throw new ValidationError({
      message: error.details[0].message,
      key: error.details[0].context.key || error.details[0].context.type || 'object',
      errorLocationCode: 'MODEL:VALIDATOR:FINAL_SCHEMA',
      stack: new Error().stack,
      type: error.details[0].type,
    });
  }

  return value;
}

const schemas = {
  id: function () {
    return Joi.object({
      id: Joi.string()
        .trim()
        .guid({ version: 'uuidv4' })
        .when('$required.id', { is: 'required', then: Joi.required(), otherwise: Joi.optional().allow(null) }),
    });
  },

  username: function () {
    return Joi.object({
      username: Joi.string()
        .alphanum()
        .min(3)
        .max(30)
        .trim()
        .custom(checkReservedUsernames, 'check if username is reserved')
        .when('$required.username', { is: 'required', then: Joi.required(), otherwise: Joi.optional() }),
    });
  },

  owner_username: function () {
    return Joi.object({
      owner_username: Joi.string()
        .alphanum()
        .min(3)
        .max(30)
        .trim()
        .custom(checkReservedUsernames, 'check if username is reserved')
        .when('$required.owner_username', { is: 'required', then: Joi.required(), otherwise: Joi.optional() }),
    });
  },

  email: function () {
    return Joi.object({
      email: Joi.string()
        .email()
        .min(7)
        .max(254)
        .lowercase()
        .trim()
        .when('$required.email', { is: 'required', then: Joi.required(), otherwise: Joi.optional() }),
    });
  },

  password: function () {
    return Joi.object({
      // Why 72 in max length? https://security.stackexchange.com/a/39851
      password: Joi.string()
        .min(8)
        .max(72)
        .trim()
        .when('$required.password', { is: 'required', then: Joi.required(), otherwise: Joi.optional() }),
    });
  },

  description: function () {
    return Joi.object({
      description: Joi.string()
        .max(5000)
        .replace(/\u0000/gu, '')
        .custom(trimEnd)
        .allow('')
        .when('$required.description', { is: 'required', then: Joi.required(), otherwise: Joi.optional() }),
    });
  },

  features: function () {
    return Joi.object({
      features: Joi.array()
        .when('$required.features', { is: 'required', then: Joi.required(), otherwise: Joi.optional() })
        .items(Joi.string().valid(...availableFeatures))
        .messages({
          'any.only': '{#label} não aceita o valor "{#value}".',
        }),
    });
  },

  notifications: function () {
    return Joi.object({
      notifications: Joi.boolean().when('$required.notifications', {
        is: 'required',
        then: Joi.required(),
        otherwise: Joi.optional(),
      }),
    });
  },

  token_id: function () {
    return Joi.object({
      token_id: Joi.string()
        .trim()
        .guid({ version: 'uuidv4' })
        .when('$required.token_id', { is: 'required', then: Joi.required(), otherwise: Joi.optional() }),
    });
  },

  session_id: function () {
    return Joi.object({
      session_id: Joi.string()
        .length(96)
        .alphanum()
        .when('$required.session_id', { is: 'required', then: Joi.required(), otherwise: Joi.optional() }),
    });
  },

  parent_id: function () {
    return Joi.object({
      parent_id: Joi.string()
        .trim()
        .guid({ version: 'uuidv4' })
        .when('$required.parent_id', { is: 'required', then: Joi.required(), otherwise: Joi.optional().allow(null) }),
    });
  },

  slug: function () {
    return Joi.object({
      slug: Joi.string()
        .min(1)
        .max(160, 'utf8')
        .trim()
        .truncate()
        .custom(noTrailingHyphen)
        .pattern(/^[a-z0-9](-?[a-z0-9])*$/)
        .when('$required.slug', { is: 'required', then: Joi.required(), otherwise: Joi.optional() }),
    });
  },

  title: function () {
    return Joi.object({
      title: Joi.string()
        .min(1)
        .max(255)
        .replace(/\u0000/gu, '')
        .custom(trimStart)
        .custom(trimEnd)
        .when('$required.title', { is: 'required', then: Joi.required(), otherwise: Joi.optional().allow(null) }),
    });
  },

  body: function () {
    return Joi.object({
      body: Joi.string()
        .pattern(/^[\s\p{C}\u034f\u17b4\u17b5\u2800\u115f\u1160\u3164\uffa0].*$/su, { invert: true })
        .min(1)
        .max(20000)
        .replace(/\u0000/gu, '')
        .custom(trimEnd)
        .custom(withoutMarkdown, 'check if is empty without markdown')
        .when('$required.body', { is: 'required', then: Joi.required(), otherwise: Joi.optional() })
        .messages({
          'string.pattern.invert.base': `{#label} deve começar com caracteres visíveis.`,
        }),
    });
  },

  status: function () {
    return Joi.object({
      status: Joi.string()
        .trim()
        .valid('draft', 'published', 'deleted', 'firewall')
        .when('$required.status', { is: 'required', then: Joi.required(), otherwise: Joi.optional() }),
    });
  },

  content_type: function () {
    return Joi.object({
      type: Joi.string()
        .trim()
        .valid('content', 'ad')
        .default('content')
        .when('$required.content_type', { is: 'required', then: Joi.required(), otherwise: Joi.optional() }),
    });
  },

  source_url: function () {
    return Joi.object({
      source_url: Joi.string()
        .replace(/\u0000/g, '')
        .trim()
        .max(2000)
        .pattern(/^https?:\/\/([-\p{Ll}\d_]{1,255}\.)+[-a-z0-9]{2,24}(:[0-9]{1,5})?([/?#]\S*)?$/u)
        .when('$required.source_url', { is: 'required', then: Joi.required(), otherwise: Joi.optional().allow(null) })
        .messages({
          'string.pattern.base': `{#label} deve possuir uma URL válida e utilizando os protocolos HTTP ou HTTPS.`,
        }),
    });
  },

  owner_id: function () {
    return Joi.object({
      owner_id: Joi.string()
        .trim()
        .guid({ version: 'uuidv4' })
        .when('$required.owner_id', { is: 'required', then: Joi.required(), otherwise: Joi.optional().allow(null) }),
    });
  },

  created_at: function () {
    return Joi.object({
      created_at: Joi.date().when('$required.created_at', {
        is: 'required',
        then: Joi.required(),
        otherwise: Joi.optional(),
      }),
    });
  },

  updated_at: function () {
    return Joi.object({
      updated_at: Joi.date().when('$required.updated_at', {
        is: 'required',
        then: Joi.required(),
        otherwise: Joi.optional(),
      }),
    });
  },

  published_at: function () {
    return Joi.object({
      published_at: Joi.date().when('$required.published_at', {
        is: 'required',
        then: Joi.required(),
        otherwise: Joi.optional().allow(null),
      }),
    });
  },

  deleted_at: function () {
    return Joi.object({
      deleted_at: Joi.date().when('$required.deleted_at', {
        is: 'required',
        then: Joi.required(),
        otherwise: Joi.optional().allow(null),
      }),
    });
  },

  expires_at: function () {
    return Joi.object({
      expires_at: Joi.date().when('$required.expires_at', {
        is: 'required',
        then: Joi.required(),
        otherwise: Joi.optional().allow(null),
      }),
    });
  },

  used: function () {
    return Joi.object({
      used: Joi.boolean().when('$required.used', { is: 'required', then: Joi.required(), otherwise: Joi.optional() }),
    });
  },

  page: function () {
    const min = 1;
    const max = 9007199254740990;
    return Joi.object({
      page: Joi.number()
        .integer()
        .min(min)
        .max(max)
        .default(1)
        .when('$required.page', { is: 'required', then: Joi.required(), otherwise: Joi.optional() })
        .messages({
          'number.unsafe': `{#label} deve possuir um valor entre ${min} e ${max}.`,
        }),
    });
  },

  per_page: function () {
    const min = 1;
    const max = 100;
    return Joi.object({
      per_page: Joi.number()
        .integer()
        .min(min)
        .max(max)
        .default(30)
        .when('$required.per_page', { is: 'required', then: Joi.required(), otherwise: Joi.optional() })
        .messages({
          'number.unsafe': `{#label} deve possuir um valor entre ${min} e ${max}.`,
        }),
    });
  },

  strategy: function () {
    return Joi.object({
      strategy: Joi.string()
        .trim()
        .valid('new', 'old', 'relevant')
        .default('relevant')
        .when('$required.strategy', { is: 'required', then: Joi.required(), otherwise: Joi.optional() }),
    });
  },

  // TODO: refactor this in the future for
  // an Array just like Sequelize.
  order: function () {
    return Joi.object({
      order: Joi.string()
        .trim()
        .valid('created_at DESC', 'created_at ASC', 'published_at DESC', 'published_at ASC')
        .when('$required.order', { is: 'required', then: Joi.required(), otherwise: Joi.optional() }),
    });
  },

  ignore_id: function () {
    return Joi.object({
      ignore_id: schemas.id().extract('id'),
    });
  },

  flexible: function () {
    return Joi.object({
      flexible: Joi.boolean()
        .default(false)
        .when('$required.optional', { is: 'required', then: Joi.required(), otherwise: Joi.optional() }),
    });
  },

  where: function () {
    let whereSchema = Joi.object({}).optional().min(1);

    for (const key of [
      'parent_id',
      'slug',
      'title',
      'body',
      'source_url',
      'owner_id',
      'username',
      'owner_username',
      '$not_null',
      'attributes',
    ]) {
      const keyValidationFunction = schemas[key];
      whereSchema = whereSchema.concat(keyValidationFunction());
    }

    for (const key of ['id', 'status']) {
      whereSchema = whereSchema.concat(
        Joi.object({
          [key]: Joi.alternatives().try(Joi.array().items(schemas[key]().extract(key)), schemas[key]().extract(key)),
        }),
      );
    }

    whereSchema = whereSchema.concat(
      Joi.object({
        type: Joi.alternatives().try(
          Joi.array().items(schemas.content_type().extract('type')),
          schemas.content_type().extract('type'),
        ),
      }),
    );

    return Joi.object({
      where: whereSchema,
    });
  },

  limit: function () {
    const min = 1;
    const max = 9007199254740990;
    return Joi.object({
      limit: Joi.number()
        .integer()
        .min(min)
        .max(max)
        .default(null)
        .when('$required.limit', { is: 'required', then: Joi.required(), otherwise: Joi.optional() })
        .messages({
          'number.unsafe': `{#label} deve possuir um valor entre ${min} e ${max}.`,
        }),
    });
  },

  $not_null: function () {
    return Joi.object({
      $not_null: Joi.array().optional().items(Joi.string().valid('parent_id')),
    });
  },

  attributes: function () {
    return Joi.object({
      attributes: Joi.object({
        exclude: Joi.array().items(Joi.string().valid('body')),
      }),
    });
  },

  count: function () {
    return Joi.object({
      count: Joi.boolean()
        .default(false)
        .when('$required.count', { is: 'required', then: Joi.required(), otherwise: Joi.optional() }),
    });
  },

  children_deep_count: function () {
    return Joi.object({
      children_deep_count: Joi.number().when('$required.children_deep_count', {
        is: 'required',
        then: Joi.required(),
        otherwise: Joi.optional(),
      }),
    });
  },

  content: function () {
    let contentSchema = Joi.object({
      children: Joi.array().optional().items(Joi.link('#content')),
    })
      .required()
      .min(1)
      .id('content');

    for (const key of [
      'id',
      'owner_id',
      'parent_id',
      'slug',
      'title',
      'body',
      'status',
      'content_type',
      'source_url',
      'created_at',
      'updated_at',
      'published_at',
      'deleted_at',
      'owner_username',
      'children_deep_count',
      'tabcoins',
      'tabcoins_credit',
      'tabcoins_debit',
      'tabcash',
    ]) {
      const keyValidationFunction = schemas[key];
      contentSchema = contentSchema.concat(keyValidationFunction());
    }

    return contentSchema;
  },

  ad: function () {
    let contentSchema = Joi.object({
      children: Joi.array().optional().items(Joi.link('#content')),
    })
      .required()
      .min(1)
      .id('ad');

    for (const key of [
      'id',
      'owner_id',
      'slug',
      'title',
      'body',
      'status',
      'ad_type',
      'source_url',
      'created_at',
      'updated_at',
      'published_at',
      'deleted_at',
      'owner_username',
      'children_deep_count',
      'tabcash',
    ]) {
      const keyValidationFunction = schemas[key];
      contentSchema = contentSchema.concat(keyValidationFunction());
    }

    return contentSchema;
  },

  ad_list: function () {
    return Joi.object({
      ad_list: Joi.array().items(Joi.link('#ad')).required().shared(schemas.ad()),
    });
  },

  ad_type: function () {
    return Joi.object({
      type: Joi.string()
        .trim()
        .valid('markdown')
        .default('markdown')
        .when('$required.ad_type', { is: 'required', then: Joi.required(), otherwise: Joi.optional() }),
    });
  },

  with_children: function () {
    return Joi.object({
      with_children: Joi.boolean().when('$required.with_children', {
        is: 'required',
        then: Joi.required(),
        otherwise: Joi.optional(),
      }),
    });
  },

  with_root: function () {
    return Joi.object({
      with_root: Joi.boolean().when('$required.with_root', {
        is: 'required',
        then: Joi.required(),
        otherwise: Joi.optional(),
      }),
    });
  },

  event: function () {
    return Joi.object({
      id: schemas.id().extract('id'),
      created_at: schemas.created_at().extract('created_at'),
      type: Joi.string()
        .valid(
          'create:user',
          'update:user',
          'ban:user',
          'create:content:text_root',
          'create:content:text_child',
          'update:content:text_root',
          'update:content:text_child',
          'update:content:tabcoins',
          'firewall:block_users',
          'firewall:block_contents:text_root',
          'firewall:block_contents:text_child',
          'moderation:block_users',
          'moderation:block_contents:text_root',
          'moderation:block_contents:text_child',
          'moderation:unblock_users',
          'moderation:unblock_contents:text_root',
          'moderation:unblock_contents:text_child',
          'reward:user:tabcoins',
          'system:update:tabcoins',
        )
        .messages({
          'any.only': '{#label} não aceita o valor "{#value}".',
        }),
      originator_user_id: Joi.string().allow(null).guid({ version: 'uuidv4' }).optional(),
      originator_ip: Joi.string()
        .ip({
          version: ['ipv4', 'ipv6'],
        })
        .optional(),
      metadata: Joi.when('type', [
        {
          is: 'create:user',
          then: Joi.object({
            id: Joi.string().required(),
          }),
        },
        {
          is: 'update:user',
          then: Joi.object({
            id: Joi.string().required(),
            updatedFields: Joi.array().items(Joi.string()).required(),
            username: Joi.object({
              old: Joi.string().required(),
              new: Joi.string().required(),
            }),
          }),
        },
        {
          is: 'create:content:text_root',
          then: Joi.object({
            id: Joi.string().required(),
          }),
        },
        {
          is: 'create:content:text_child',
          then: Joi.object({
            id: Joi.string().required(),
          }),
        },
        {
          is: 'update:content:text_root',
          then: Joi.object({
            id: Joi.string().required(),
          }),
        },
        {
          is: 'update:content:text_child',
          then: Joi.object({
            id: Joi.string().required(),
          }),
        },
        {
          is: 'firewall:block_users',
          then: Joi.object({
            from_rule: Joi.string().required(),
            users: Joi.array().required(),
          }),
        },
        {
          is: 'firewall:block_contents:text_root',
          then: Joi.object({
            from_rule: Joi.string().required(),
            contents: Joi.array().required(),
          }),
        },
        {
          is: 'firewall:block_contents:text_child',
          then: Joi.object({
            from_rule: Joi.string().required(),
            contents: Joi.array().required(),
          }),
        },
        {
          is: Joi.string().valid('moderation:block_users', 'moderation:unblock_users'),
          then: Joi.object({
            related_events: Joi.array().items(Joi.string()).required(),
            users: Joi.array().required(),
          }),
        },
        {
          is: Joi.string().valid(
            'moderation:block_contents:text_root',
            'moderation:block_contents:text_child',
            'moderation:unblock_contents:text_root',
            'moderation:unblock_contents:text_child',
          ),
          then: Joi.object({
            related_events: Joi.array().items(Joi.string()).required(),
            contents: Joi.array().required(),
          }),
        },
      ]),
    });
  },

  firewall_event: function () {
    return Joi.object({
      affected: Joi.object({
        contents: Joi.array().items(schemas.content()).min(1),
        users: Joi.array().items(schemas.user()).min(1).required(),
      }),
      events: Joi.array().items(schemas.event()).min(1).required(),
    });
  },

  firewall_review_action: function () {
    return Joi.object({
      action: Joi.string()
        .trim()
        .valid('confirm', 'undo')
        .when('$required.firewall_review_action', { is: 'required', then: Joi.required(), otherwise: Joi.optional() }),
    });
  },

  user: function () {
    return Joi.object()
      .concat(schemas.id())
      .concat(schemas.created_at())
      .concat(schemas.updated_at())
      .concat(schemas.username())
      .concat(schemas.description())
      .concat(schemas.features())
      .concat(schemas.tabcoins())
      .concat(schemas.tabcash());
  },

  tabcoins: function () {
    return Joi.object({
      tabcoins: Joi.number()
        .integer()
        .min(MIN_INTEGER)
        .max(MAX_INTEGER)
        .when('$required.tabcoins', { is: 'required', then: Joi.required(), otherwise: Joi.optional() }),
    });
  },

  tabcoins_credit: function () {
    const min = 0;
    return Joi.object({
      tabcoins_credit: Joi.number()
        .integer()
        .min(min)
        .max(MAX_INTEGER)
        .when('$required.tabcoins', { is: 'required', then: Joi.required(), otherwise: Joi.optional() })
        .messages({
          'number.unsafe': `{#label} deve possuir um valor entre ${min} e ${MAX_INTEGER}.`,
        }),
    });
  },

  tabcoins_debit: function () {
    const max = 0;
    return Joi.object({
      tabcoins_debit: Joi.number()
        .integer()
        .min(MIN_INTEGER)
        .max(max)
        .when('$required.tabcoins', { is: 'required', then: Joi.required(), otherwise: Joi.optional() })
        .messages({
          'number.unsafe': `{#label} deve possuir um valor entre ${MIN_INTEGER} e ${max}.`,
        }),
    });
  },

  tabcash: function () {
    return Joi.object({
      tabcash: Joi.number()
        .integer()
        .min(MIN_INTEGER)
        .max(MAX_INTEGER)
        .when('$required.tabcash', { is: 'required', then: Joi.required(), otherwise: Joi.optional() }),
    });
  },

  transaction_type: function () {
    return Joi.object({
      transaction_type: Joi.string()
        .trim()
        .valid('credit', 'debit')
        .when('$required.transaction_type', { is: 'required', then: Joi.required(), otherwise: Joi.optional() }),
    });
  },

  ban_type: function () {
    return Joi.object({
      ban_type: Joi.string()
        .trim()
        .valid('nuke')
        .when('$required.ban_type', { is: 'required', then: Joi.required(), otherwise: Joi.optional() }),
    });
  },
};

const noTrailingHyphen = (value) => {
  while (value.endsWith('-')) {
    value = value.slice(0, -1);
  }
  return value;
};

const withoutMarkdown = (value, helpers) => {
  return removeMarkdown(value, { trim: true }).length > 0 ? value : helpers.error('markdown.empty');
};

function checkReservedUsernames(username, helpers) {
  if (
    (webserver.isServerlessRuntime && reservedDevUsernames.includes(username.toLowerCase())) ||
    reservedUsernames.includes(username.toLowerCase()) ||
    reservedUsernamesStartingWith.find((reserved) => username.toLowerCase().startsWith(reserved))
  ) {
    return helpers.error('username.reserved');
  }
  return username;
}

const reservedDevUsernames = ['admin', 'user'];
const reservedUsernamesStartingWith = ['favicon', 'manifest'];
const reservedUsernames = [
  'account',
  'administracao',
  'administrador',
  'administradora',
  'administradores',
  'administrator',
  'afiliado',
  'afiliados',
  'ajuda',
  'alerta',
  'alertas',
  'all',
  'analytics',
  'anonymous',
  'anunciar',
  'anuncie',
  'anuncio',
  'anuncios',
  'api',
  'app',
  'apps',
  'autenticacao',
  'auth',
  'authentication',
  'autorizacao',
  'avatar',
  'backup',
  'banner',
  'banners',
  'beta',
  'blog',
  'cadastrar',
  'cadastro',
  'carrinho',
  'categoria',
  'categorias',
  'categories',
  'category',
  'ceo',
  'cfo',
  'checkout',
  'classificados',
  'comentario',
  'comentarios',
  'compartilhada',
  'compartilhadas',
  'compartilhado',
  'compartilhados',
  'comunidade',
  'comunidades',
  'config',
  'configuracao',
  'configuracoes',
  'configurar',
  'configure',
  'conta',
  'contas',
  'contato',
  'contatos',
  'content',
  'conteudos',
  'contrato',
  'convite',
  'convites',
  'create',
  'criar',
  'css',
  'cto',
  'cultura',
  'curso',
  'cursos',
  'dados',
  'dashboard',
  'desconectar',
  'descricao',
  'description',
  'deslogar',
  'diretrizes',
  'discussao',
  'docs',
  'documentacao',
  'download',
  'downloads',
  'draft',
  'edit',
  'editar',
  'editor',
  'email',
  'estatisticas',
  'eu',
  'faq',
  'features',
  'gerente',
  'grupo',
  'grupos',
  'guest',
  'guidelines',
  'hoje',
  'imagem',
  'imagens',
  'init',
  'interface',
  'licenca',
  'log',
  'login',
  'logout',
  'loja',
  'me',
  'membership',
  'moderacao',
  'moderador',
  'moderadora',
  'moderadoras',
  'moderadores',
  'museu',
  'news',
  'newsletter',
  'newsletters',
  'notificacoes',
  'notification',
  'notifications',
  'ontem',
  'pagina',
  'password',
  'patrocinada',
  'patrocinadas',
  'patrocinado',
  'patrocinados',
  'perfil',
  'pesquisa',
  'popular',
  'post',
  'postar',
  'posts',
  'preferencias',
  'promoted',
  'promovida',
  'promovidas',
  'promovido',
  'promovidos',
  'public',
  'publicar',
  'publish',
  'rascunho',
  'recentes',
  'register',
  'registration',
  'regras',
  'relatorio',
  'relatorios',
  'replies',
  'reply',
  'resetar-senha',
  'resetar',
  'resposta',
  'respostas',
  'root',
  'rootuser',
  'rss',
  'sair',
  'senha',
  'sobre',
  'sponsored',
  'status',
  'sudo',
  'superuser',
  'suporte',
  'support',
  'swr',
  'sysadmin',
  'tabnew',
  'tabnews',
  'tag',
  'tags',
  'termos-de-uso',
  'termos',
  'terms',
  'toc',
  'todos',
  'trending',
  'upgrade',
  'username',
  'users',
  'usuario',
  'usuarios',
  'va',
  'vagas',
  'videos',
];
</file>

<file path="pages/[username]/[slug]/index.public.js">
import { truncate } from '@tabnews/helpers';
import { getStaticPropsRevalidate } from 'next-swr';
import { useEffect, useState } from 'react';
import useSWR from 'swr';

import { AdBanner, Box, Button, Confetti, Content, DefaultLayout, Link, TabCoinButtons, Tooltip } from '@/TabNewsUI';
import { CommentDiscussionIcon, CommentIcon, FoldIcon, UnfoldIcon } from '@/TabNewsUI/icons';
import { NotFoundError, ValidationError } from 'errors';
import webserver from 'infra/webserver.js';
import authorization from 'models/authorization.js';
import content from 'models/content.js';
import removeMarkdown from 'models/remove-markdown.js';
import user from 'models/user.js';
import { useCollapse } from 'pages/interface';

export default function Post({ contentFound, rootContentFound, parentContentFound, contentMetadata }) {
  const [childrenToShow, setChildrenToShow] = useState(108);
  const [showConfetti, setShowConfetti] = useState(false);

  const {
    data: { body: adsFound },
    isLoading: isLoadingAd,
  } = useSWR(
    `/api/v1/sponsored-beta?per_page=1&ignore_id=${contentFound.id}&owner_id=${contentFound.owner_id}&flexible=${contentFound.type === 'content'}`,
    {
      fallbackData: { body: [], headers: {} },
      revalidateOnFocus: false,
    },
  );

  useEffect(() => {
    setChildrenToShow(Math.ceil(window.innerHeight / 10));

    const justPublishedNewRootContent = localStorage.getItem('justPublishedNewRootContent');

    if (justPublishedNewRootContent) {
      setShowConfetti(true);
      localStorage.removeItem('justPublishedNewRootContent');
    }
  }, []);

  return (
    <>
      {showConfetti && <Confetti />}
      <DefaultLayout metadata={contentMetadata}>
        <InReplyToLinks content={contentFound} parentContent={parentContentFound} rootContent={rootContentFound} />

        <Box
          sx={{
            width: '100%',
            display: 'flex',
          }}>
          <Box
            sx={{
              pr: 2,
              display: 'flex',
              flexDirection: 'column',
              justifyContent: 'center',
            }}>
            <TabCoinButtons key={contentFound.id} content={contentFound} />
            <Box
              sx={{
                borderWidth: 0,
                borderRightWidth: 1,
                borderColor: 'btn.activeBorder',
                borderStyle: 'dotted',
                width: '50%',
                height: '100%',
                minHeight: '8px',
              }}
            />
          </Box>

          <Box sx={{ width: '100%', mt: contentFound.title ? 0 : '9px', pl: '1px', overflow: 'auto' }}>
            <Content key={contentFound.id} content={contentFound} mode="view" />
          </Box>
        </Box>

        <Box sx={{ width: '100%' }}>
          <Box
            sx={{
              borderRadius: '6px',
              borderWidth: 1,
              borderColor: 'border.default',
              borderStyle: 'solid',
              mt: 4,
              mb: 3,
              p: 4,
              wordWrap: 'break-word',
            }}>
            <Content
              key={contentFound.id}
              content={{
                owner_id: contentFound.owner_id,
                owner_username: contentFound.owner_username,
                parent_id: contentFound.id,
                slug: contentFound.slug,
              }}
              rootContent={rootContentFound || contentFound}
              mode="compact"
            />
          </Box>

          <AdBanner ad={adsFound[0]} isLoading={isLoadingAd} sx={{ ml: 5, pl: 1 }} />

          <RenderChildrenTree
            key={contentFound.id}
            childrenDeepCount={contentFound.children_deep_count}
            childrenList={contentFound.children}
            pageRootOwnerId={contentFound.owner_id}
            renderIntent={childrenToShow}
            renderIncrement={Math.ceil(childrenToShow / 2)}
            rootContent={rootContentFound || contentFound}
          />
        </Box>
      </DefaultLayout>
    </>
  );
}

function InReplyToLinks({ content, parentContent, rootContent }) {
  return (
    <>
      {/*          ↱ You are here
        [root]->[child]->[child]
      */}
      {content.parent_id && parentContent.id === rootContent.id && (
        <Box sx={{ fontSize: 1, mb: 2, display: 'flex', flexDirection: 'row' }}>
          <Box
            sx={{
              textAlign: 'center',
              pl: ['6px', null, null, '6px'],
              pr: ['6px', null, null, '13px'],
            }}>
            <CommentIcon verticalAlign="middle" size="small" />
          </Box>
          <Box>
            Em resposta a{' '}
            {parentContent.status === 'published' && (
              <Link href={`/${parentContent.owner_username}/${parentContent.slug}`}>
                <strong>{parentContent.title}</strong>
              </Link>
            )}
            {parentContent.status !== 'published' && (
              <Tooltip text={`Este conteúdo está atualmente com status "${parentContent.status}"`} direction="s">
                <strong>[Não disponível]</strong>
              </Tooltip>
            )}
          </Box>
        </Box>
      )}

      {/*                   ↱ You are here
        [root]->[child]->[child]
      */}
      {content.parent_id && parentContent.id !== rootContent.id && (
        <Box sx={{ fontSize: 1, mb: 2, display: 'flex', flexDirection: 'row' }}>
          <Box
            sx={{
              textAlign: 'center',
              pl: ['6px', null, null, '6px'],
              pr: ['6px', null, null, '13px'],
            }}>
            <CommentDiscussionIcon verticalAlign="middle" size="small" />
          </Box>
          <Box>
            Respondendo a{' '}
            {parentContent.status === 'published' && (
              <Link href={`/${parentContent.owner_username}/${parentContent.slug}`}>
                <strong>{`"${parentContent.body}"`}</strong>
              </Link>
            )}
            {parentContent.status !== 'published' && (
              <Tooltip text={`Este conteúdo está atualmente com status "${parentContent.status}"`} direction="s">
                <strong>[Não disponível]</strong>
              </Tooltip>
            )}
            {' dentro da publicação '}
            {rootContent.status === 'published' && (
              <Link href={`/${rootContent.owner_username}/${rootContent.slug}`}>
                <strong>{rootContent.title}</strong>
              </Link>
            )}
            {rootContent.status !== 'published' && (
              <Tooltip text={`Este conteúdo está atualmente com status "${rootContent.status}"`} direction="s">
                <strong>[Não disponível]</strong>
              </Tooltip>
            )}
          </Box>
        </Box>
      )}
    </>
  );
}

function RenderChildrenTree({ childrenList, pageRootOwnerId, renderIntent, renderIncrement, rootContent }) {
  const { childrenState, handleCollapse, handleExpand } = useCollapse({ childrenList, renderIntent, renderIncrement });

  return childrenState.map((child) => {
    const {
      children,
      children_deep_count,
      groupedCount,
      id,
      owner_id,
      owner_username,
      renderIntent,
      renderShowMore,
      slug,
      status,
    } = child;
    const isPublished = status === 'published';
    const labelShowMore = Math.min(groupedCount, renderIncrement) || '';
    const plural = labelShowMore != 1 ? 's' : '';
    const isPageRootOwner = pageRootOwnerId === owner_id;

    if (!renderIntent && !renderShowMore) return null;
    if (!isPublished && !children_deep_count) return null;

    return (
      <Box
        sx={{
          width: '100%',
          wordWrap: 'break-word',
          display: 'flex',
          mt: 3,
        }}
        key={id}>
        {renderIntent ? (
          <>
            <Box
              sx={{
                mr: 2,
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                minWidth: '28px',
              }}>
              <TabCoinButtons content={child} />
              <Tooltip
                direction="ne"
                text={`Ocultar resposta${plural}`}
                role="button"
                onClick={() => handleCollapse(id)}
                sx={{
                  cursor: 'pointer',
                  width: '80%',
                  height: '100%',
                  minHeight: '24px',
                  display: 'flex',
                  justifyContent: 'center',
                  mt: 1,
                  mx: '10%',
                  '&:hover': {
                    div: {
                      display: 'block',
                      borderLeftWidth: 1,
                      borderColor: 'btn.danger.hoverBg',
                      borderStyle: 'dashed',
                    },
                    svg: {
                      backgroundColor: 'canvas.default',
                    },
                  },
                }}>
                <Box
                  sx={{
                    display: 'none',
                    position: 'relative',
                    width: '0%',
                    left: '-7px',
                    color: 'btn.danger.hoverBg',
                    borderStyle: 'hidden!important',
                  }}>
                  <FoldIcon />
                </Box>
                <Box
                  sx={{
                    borderWidth: 0,
                    borderRightWidth: 1,
                    borderLeftWidth: 0,
                    borderColor: 'btn.activeBorder',
                    borderStyle: 'dotted',
                    width: 0,
                    transition: 'border 0.1s cubic-bezier(1,1,1,0)',
                  }}
                />
              </Tooltip>
            </Box>

            <Box
              sx={{ display: 'flex', flexDirection: 'column', width: '100%', mt: '9px', pl: '1px', overflow: 'auto' }}>
              {isPublished && <Content content={child} isPageRootOwner={isPageRootOwner} mode="view" />}

              <Box sx={{ display: 'flex', flex: 1, mt: isPublished ? 4 : 0, alignItems: 'end' }}>
                <Content
                  content={{ owner_id, owner_username, parent_id: id, slug }}
                  mode={isPublished ? 'compact' : 'deleted'}
                  rootContent={rootContent}
                  viewFrame={true}
                />
              </Box>

              {children_deep_count > 0 && (
                <RenderChildrenTree
                  childrenDeepCount={children_deep_count}
                  childrenList={children}
                  pageRootOwnerId={pageRootOwnerId}
                  renderIntent={renderIntent - 1}
                  renderIncrement={renderIncrement}
                  rootContent={rootContent}
                />
              )}
            </Box>
          </>
        ) : (
          <Button onClick={() => handleExpand(id)} variant="invisible" sx={{ color: 'accent.fg' }}>
            <UnfoldIcon /> {`Ver mais ${labelShowMore} resposta${plural}`}
            {labelShowMore != groupedCount && ` (${groupedCount} ocultas)`}
          </Button>
        )}
      </Box>
    );
  });
}

export async function getStaticPaths() {
  const relevantResults = await content.findWithStrategy({
    strategy: 'relevant',
    where: {
      parent_id: null,
      status: 'published',
    },
    attributes: {
      exclude: ['body'],
    },
    page: 1,
    per_page: 100,
  });

  const paths = relevantResults.rows.map((content) => {
    return {
      params: {
        username: content.owner_username,
        slug: content.slug,
      },
    };
  });

  return {
    paths,
    fallback: 'blocking',
  };
}

export const getStaticProps = getStaticPropsRevalidate(async (context) => {
  const userTryingToGet = user.createAnonymous();

  let contentTreeFound;

  try {
    contentTreeFound = await content.findTree({
      where: {
        owner_username: context.params.username,
        slug: context.params.slug,
      },
    });

    if (!contentTreeFound?.length) {
      throw new NotFoundError({
        message: `O conteúdo informado não foi encontrado no sistema.`,
        action: 'Verifique se o "slug" está digitado corretamente.',
        stack: new Error().stack,
        errorLocationCode: 'PAGES:USERNAME:SLUG:GET_STATIC_PROPS:SLUG_NOT_FOUND',
        key: 'slug',
      });
    }
  } catch (error) {
    if (error instanceof ValidationError) {
      return {
        notFound: true,
      };
    }

    if (error instanceof NotFoundError) {
      return {
        notFound: true,
        revalidate: 1,
      };
    }

    throw error;
  }

  const secureContentTree = authorization.filterOutput(userTryingToGet, 'read:content:list', contentTreeFound);

  const secureContentFound = secureContentTree[0];

  const oneLineBody = removeMarkdown(secureContentFound.body, { maxLength: 190 });

  const contentMetadata = {
    title: `${secureContentFound.title ?? truncate(oneLineBody, 80)} · ${secureContentFound.owner_username}`,
    image: `${webserver.host}/api/v1/contents/${secureContentFound.owner_username}/${secureContentFound.slug}/thumbnail`,
    url: `${webserver.host}/${secureContentFound.owner_username}/${secureContentFound.slug}`,
    description: oneLineBody,
    published_time: secureContentFound.published_at,
    modified_time: secureContentFound.updated_at,
    author: secureContentFound.owner_username,
    type: 'article',
    canonical: secureContentFound.parent_id
      ? undefined
      : `${webserver.host}/${secureContentFound.owner_username}/${secureContentFound.slug}`,
    noIndex: secureContentFound.type === 'ad',
  };

  let secureRootContentFound = null;
  let secureParentContentFound = null;

  if (contentTreeFound[0].path.length > 1) {
    const rootContentFound = await content.findOne({
      where: {
        id: contentTreeFound[0].path[0],
      },
      attributes: { exclude: ['body'] },
    });

    secureRootContentFound = authorization.filterOutput(userTryingToGet, 'read:content', rootContentFound);

    const parentContentFound = await content.findOne({
      where: {
        id: secureContentFound.parent_id,
      },
    });

    parentContentFound.body = removeMarkdown(parentContentFound.body, { maxLength: 50 });
    secureParentContentFound = authorization.filterOutput(userTryingToGet, 'read:content', parentContentFound);
  }

  if (contentTreeFound[0].path.length === 1) {
    const parentContentFound = await content.findOne({
      where: {
        id: secureContentFound.parent_id,
      },
      attributes: { exclude: ['body'] },
    });

    secureParentContentFound = authorization.filterOutput(userTryingToGet, 'read:content', parentContentFound);

    secureRootContentFound = { id: secureParentContentFound.id, title: secureParentContentFound.title };
  }

  return {
    props: {
      contentFound: JSON.parse(JSON.stringify(secureContentFound)),
      rootContentFound: JSON.parse(JSON.stringify(secureRootContentFound)),
      parentContentFound: JSON.parse(JSON.stringify(secureParentContentFound)),
      contentMetadata: JSON.parse(JSON.stringify(contentMetadata)),
    },
    revalidate: 1,
    swr: { revalidateOnFocus: false },
  };
});
</file>

<file path="pages/[username]/classificados/[page]/index.public.js">
import { useRouter } from 'next/router';
import { getStaticPropsRevalidate } from 'next-swr';

import { ContentList, DefaultLayout, UserHeader } from '@/TabNewsUI';
import { FaUser } from '@/TabNewsUI/icons';
import { NotFoundError } from 'errors';
import authorization from 'models/authorization.js';
import content from 'models/content.js';
import user from 'models/user.js';
import validator from 'models/validator.js';
import { useUser } from 'pages/interface';

export default function RootContent({ contentListFound, pagination, username }) {
  const { push } = useRouter();
  const { user, isLoading } = useUser();
  const isAuthenticatedUser = user && user.username === username;

  return (
    <DefaultLayout
      metadata={{ title: `Classificados · Página ${pagination.currentPage} · ${username}`, noIndex: true }}>
      <UserHeader username={username} adContentCount={pagination.totalRows} />

      <ContentList
        contentList={contentListFound}
        pagination={pagination}
        paginationBasePath={`/${username}/classificados`}
        emptyStateProps={{
          isLoading: isLoading,
          title: 'Nenhum classificado encontrado',
          description: `${isAuthenticatedUser ? 'Você' : username} não possui anúncios publicados.`,
          icon: FaUser,
          action: isAuthenticatedUser && {
            text: 'Publicar',
            onClick: () => push('/publicar'),
          },
        }}
      />
    </DefaultLayout>
  );
}

export function getStaticPaths() {
  return {
    paths: [],
    fallback: 'blocking',
  };
}

export const getStaticProps = getStaticPropsRevalidate(async (context) => {
  const userTryingToGet = user.createAnonymous();

  try {
    context.params = validator(context.params, {
      username: 'required',
      page: 'optional',
      per_page: 'optional',
    });
  } catch (error) {
    return {
      notFound: true,
    };
  }

  let results;
  let secureUserFound;

  try {
    const userFound = await user.findOneByUsername(context.params.username);

    secureUserFound = authorization.filterOutput(userTryingToGet, 'read:user', userFound);

    results = await content.findWithStrategy({
      strategy: 'new',
      where: {
        owner_id: secureUserFound.id,
        status: 'published',
        type: 'ad',
      },
      attributes: {
        exclude: ['body'],
      },
      page: context.params.page,
      per_page: context.params.per_page,
    });
  } catch (error) {
    if (error instanceof NotFoundError) {
      return {
        notFound: true,
        revalidate: 1,
      };
    }

    throw error;
  }

  const contentListFound = results.rows;

  const secureContentListFound = authorization.filterOutput(userTryingToGet, 'read:content:list', contentListFound);

  if (secureContentListFound.length === 0 && context.params.page !== 1) {
    const lastValidPage = `/${secureUserFound.username}/classificados/${results.pagination.lastPage || 1}`;
    const revalidate = context.params.page > results.pagination.lastPage + 1 ? 60 : 1;

    return {
      redirect: {
        destination: lastValidPage,
      },
      revalidate,
    };
  }

  return {
    props: {
      contentListFound: secureContentListFound,
      pagination: results.pagination,
      username: secureUserFound.username,
    },

    revalidate: 10,
  };
});
</file>

<file path="pages/[username]/comentarios/[page]/index.public.js">
import { getStaticPropsRevalidate } from 'next-swr';

import { ContentList, DefaultLayout, UserHeader } from '@/TabNewsUI';
import { FaUser } from '@/TabNewsUI/icons';
import { NotFoundError } from 'errors';
import authorization from 'models/authorization.js';
import content from 'models/content.js';
import removeMarkdown from 'models/remove-markdown.js';
import user from 'models/user.js';
import validator from 'models/validator.js';
import { useUser } from 'pages/interface';

export default function ChildContent({ contentListFound, pagination, username }) {
  const { user, isLoading } = useUser();
  const isAuthenticatedUser = user && user.username === username;

  return (
    <DefaultLayout metadata={{ title: `Comentários · Página ${pagination.currentPage} · ${username}` }}>
      <UserHeader username={username} childContentCount={pagination.totalRows} />

      <ContentList
        contentList={contentListFound}
        pagination={pagination}
        paginationBasePath={`/${username}/comentarios`}
        emptyStateProps={{
          isLoading: isLoading,
          title: 'Nenhum comentário encontrado',
          description: `${isAuthenticatedUser ? 'Você' : username} ainda não fez nenhum comentário.`,
          icon: FaUser,
        }}
      />
    </DefaultLayout>
  );
}

export function getStaticPaths() {
  return {
    paths: [],
    fallback: 'blocking',
  };
}

export const getStaticProps = getStaticPropsRevalidate(async (context) => {
  const userTryingToGet = user.createAnonymous();

  try {
    context.params = validator(context.params, {
      username: 'required',
      page: 'optional',
      per_page: 'optional',
    });
  } catch (error) {
    return {
      notFound: true,
    };
  }

  let results;
  let secureUserFound;

  try {
    const userFound = await user.findOneByUsername(context.params.username);

    secureUserFound = authorization.filterOutput(userTryingToGet, 'read:user', userFound);

    results = await content.findWithStrategy({
      strategy: 'new',
      where: {
        owner_id: secureUserFound.id,
        status: 'published',
        $not_null: ['parent_id'],
      },
      page: context.params.page,
      per_page: context.params.per_page,
    });
  } catch (error) {
    if (error instanceof NotFoundError) {
      return {
        notFound: true,
        revalidate: 1,
      };
    }

    throw error;
  }

  const contentListFound = results.rows;

  const secureContentListFound = authorization.filterOutput(userTryingToGet, 'read:content:list', contentListFound);

  if (secureContentListFound.length === 0 && context.params.page !== 1) {
    const lastValidPage = `/${secureUserFound.username}/comentarios/${results.pagination.lastPage || 1}`;
    const revalidate = context.params.page > results.pagination.lastPage + 1 ? 60 : 1;

    return {
      redirect: {
        destination: lastValidPage,
      },
      revalidate,
    };
  }

  for (const content of secureContentListFound) {
    content.body = removeMarkdown(content.body, { maxLength: 255 });
  }

  return {
    props: {
      contentListFound: secureContentListFound,
      pagination: results.pagination,
      username: secureUserFound.username,
    },

    revalidate: 10,
  };
});
</file>

<file path="pages/[username]/conteudos/[page]/index.public.js">
import { useRouter } from 'next/router';
import { getStaticPropsRevalidate } from 'next-swr';

import { ContentList, DefaultLayout, UserHeader } from '@/TabNewsUI';
import { FaUser } from '@/TabNewsUI/icons';
import { NotFoundError } from 'errors';
import authorization from 'models/authorization.js';
import content from 'models/content.js';
import user from 'models/user.js';
import validator from 'models/validator.js';
import { useUser } from 'pages/interface';

export default function RootContent({ contentListFound, pagination, username }) {
  const { push } = useRouter();
  const { user, isLoading } = useUser();
  const isAuthenticatedUser = user && user.username === username;

  return (
    <DefaultLayout metadata={{ title: `Publicações · Página ${pagination.currentPage} · ${username}` }}>
      <UserHeader username={username} rootContentCount={pagination.totalRows} />

      <ContentList
        contentList={contentListFound}
        pagination={pagination}
        paginationBasePath={`/${username}/conteudos`}
        emptyStateProps={{
          isLoading: isLoading,
          title: 'Nenhuma publicação encontrada',
          description: `${isAuthenticatedUser ? 'Você' : username} ainda não fez nenhuma publicação.`,
          icon: FaUser,
          action: isAuthenticatedUser && {
            text: 'Publicar conteúdo',
            onClick: () => push('/publicar'),
          },
        }}
      />
    </DefaultLayout>
  );
}

export function getStaticPaths() {
  return {
    paths: [],
    fallback: 'blocking',
  };
}

export const getStaticProps = getStaticPropsRevalidate(async (context) => {
  const userTryingToGet = user.createAnonymous();

  try {
    context.params = validator(context.params, {
      username: 'required',
      page: 'optional',
      per_page: 'optional',
    });
  } catch (error) {
    return {
      notFound: true,
    };
  }

  let results;
  let secureUserFound;

  try {
    const userFound = await user.findOneByUsername(context.params.username);

    secureUserFound = authorization.filterOutput(userTryingToGet, 'read:user', userFound);

    results = await content.findWithStrategy({
      strategy: 'new',
      where: {
        parent_id: null,
        owner_id: secureUserFound.id,
        status: 'published',
        type: 'content',
      },
      attributes: {
        exclude: ['body'],
      },
      page: context.params.page,
      per_page: context.params.per_page,
    });
  } catch (error) {
    if (error instanceof NotFoundError) {
      return {
        notFound: true,
        revalidate: 1,
      };
    }

    throw error;
  }

  const contentListFound = results.rows;

  const secureContentListFound = authorization.filterOutput(userTryingToGet, 'read:content:list', contentListFound);

  if (secureContentListFound.length === 0 && context.params.page !== 1) {
    const lastValidPage = `/${secureUserFound.username}/conteudos/${results.pagination.lastPage || 1}`;
    const revalidate = context.params.page > results.pagination.lastPage + 1 ? 60 : 1;

    return {
      redirect: {
        destination: lastValidPage,
      },
      revalidate,
    };
  }

  return {
    props: {
      contentListFound: secureContentListFound,
      pagination: results.pagination,
      username: secureUserFound.username,
    },

    revalidate: 10,
  };
});
</file>

<file path="pages/[username]/index.public.js">
import { getStaticPropsRevalidate } from 'next-swr';
import { useState } from 'react';
import useSWR from 'swr';

import {
  ActionList,
  ActionMenu,
  Box,
  Button,
  ButtonWithLoader,
  CharacterCount,
  DefaultLayout,
  Editor,
  Flash,
  FormControl,
  IconButton,
  Label,
  LabelGroup,
  NavItem,
  NavList,
  PastTime,
  TabCashCount,
  TabCoinCount,
  Text,
  useConfirm,
  UserHeader,
  Viewer,
} from '@/TabNewsUI';
import { CircleSlashIcon, GearIcon, KebabHorizontalIcon } from '@/TabNewsUI/icons';
import { NotFoundError } from 'errors';
import authorization from 'models/authorization.js';
import content from 'models/content.js';
import user from 'models/user.js';
import validator from 'models/validator.js';
import { createErrorMessage, useUser } from 'pages/interface';

export default function Page({ userFound: userFoundFallback }) {
  const {
    data: { body: userFound },
    mutate: userFoundMutate,
  } = useSWR(`/api/v1/users/${userFoundFallback.username}`, {
    fallbackData: { body: userFoundFallback },
    revalidateOnMount: false,
  });

  function onUpdate(updatedUser) {
    userFoundMutate({ body: updatedUser }, { revalidate: false });
  }

  return (
    <DefaultLayout metadata={{ title: `${userFound.username}` }}>
      <UserProfile key={userFound.id} userFound={userFound} onUpdate={onUpdate} />
    </DefaultLayout>
  );
}

const DESCRIPTION_MAX_LENGTH = 5_000;

function UserProfile({ userFound, onUpdate }) {
  const { user } = useUser();
  const [globalMessageObject, setGlobalMessageObject] = useState(null);
  const [isEditingDescription, setIsEditingDescription] = useState(false);

  const isAuthenticatedUser = user && user.username === userFound.username;
  const canUpdate = isAuthenticatedUser && user?.features?.includes('update:user');
  const canUpdateDescription = canUpdate || user?.features?.includes('update:user:others');

  function handleEditDescription() {
    setGlobalMessageObject(null);
    setIsEditingDescription(true);
  }

  function handleEditSuccess(newUser) {
    setIsEditingDescription(false);
    onUpdate(newUser);
  }

  return (
    <>
      {globalMessageObject?.position === 'main' && (
        <Flash variant={globalMessageObject.type} sx={{ width: '100%', mb: 4 }}>
          {globalMessageObject.text}
        </Flash>
      )}

      <UserHeader username={userFound.username}>
        <UserFeatures userFound={userFound} />
        <OptionsMenu
          canUpdate={canUpdate}
          isAuthenticatedUser={isAuthenticatedUser}
          onNuke={onUpdate}
          setGlobalMessageObject={setGlobalMessageObject}
          user={user}
          userFound={userFound}
        />
      </UserHeader>

      <Box
        sx={{
          width: '100%',
          display: 'flex',
          alignItems: 'end',
          wordBreak: 'break-word',
          flexWrap: 'wrap',
          gap: 2,
          mb: 2,
        }}>
        <Box sx={{ flex: 1, display: 'flex', flexWrap: 'wrap', gap: 2 }}>
          {userFound.tabcoins !== undefined && <TabCoinCount amount={userFound.tabcoins} mode="full" />}

          {userFound.tabcash !== undefined && <TabCashCount amount={userFound.tabcash} mode="full" />}

          <Box sx={{ ml: 1 }}>
            <PastTime date={userFound.created_at} formatText={(date) => `Membro há ${date}`} direction="ne" />
          </Box>
        </Box>
      </Box>

      {userFound.description && !isEditingDescription && (
        <>
          <Box
            sx={{
              display: 'flex',
              width: '100%',
              justifyContent: 'space-between',
              mb: 1,
              minHeight: '32px', // This is the button height, so it doesn't flick when the button is rendered
            }}>
            <Text sx={{ fontSize: 1, fontWeight: 'bold', mt: 'auto', pb: 1 }}>Descrição</Text>
            {canUpdateDescription && (
              <Button variant="invisible" sx={{ color: 'accent.fg' }} onClick={handleEditDescription}>
                Editar descrição
              </Button>
            )}
          </Box>

          <Box
            sx={{
              borderWidth: 1,
              borderStyle: 'solid',
              borderColor: 'border.default',
              borderRadius: 2,
              width: '100%',
              p: 3,
              overflow: 'hidden',
            }}>
            <Viewer value={userFound.description} clobberPrefix={`${userFound.username}-content-`} />
          </Box>
        </>
      )}

      {!userFound.description && canUpdateDescription && !isEditingDescription && (
        <Button sx={{ mx: 'auto', mt: 1 }} onClick={handleEditDescription}>
          Criar descrição
        </Button>
      )}

      {isEditingDescription && (
        <DescriptionForm
          user={userFound}
          onCancel={() => setIsEditingDescription(false)}
          onSuccess={handleEditSuccess}
          globalMessageObject={globalMessageObject}
          setGlobalMessageObject={setGlobalMessageObject}
          isAuthenticatedUser={isAuthenticatedUser}
        />
      )}

      {!isEditingDescription && globalMessageObject?.position === 'description' && (
        <Flash variant={globalMessageObject.type} sx={{ width: '100%', mt: 3 }}>
          {globalMessageObject.text}
        </Flash>
      )}
    </>
  );
}

function DescriptionForm({
  user,
  onCancel,
  onSuccess,
  globalMessageObject,
  setGlobalMessageObject,
  isAuthenticatedUser,
}) {
  const [description, setDescription] = useState(user.description ?? '');
  const [isPosting, setIsPosting] = useState(false);
  const [errorObject, setErrorObject] = useState();

  const confirm = useConfirm();

  async function handleSubmit(event) {
    event.preventDefault();

    clearMessages();

    if (user.description === description) {
      setGlobalMessageObject({
        type: 'warning',
        position: 'description',
        text: 'A descrição não foi alterada.',
      });
      return;
    }

    const confirmSubmit = !isAuthenticatedUser
      ? await confirm({
          title: 'Tem certeza que deseja salvar as alterações?',
          content: (
            <Text>
              Você está editando a descrição do usuário &quot;<Text sx={{ fontWeight: 'bold' }}>{user.username}</Text>
              &quot;.
            </Text>
          ),
          cancelButtonContent: 'Cancelar',
          confirmButtonContent: 'Sim',
        })
      : true;

    if (!confirmSubmit) return;

    setIsPosting(true);

    try {
      const response = await fetch(`/api/v1/users/${user.username}`, {
        method: 'PATCH',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ description: description }),
      });

      const responseBody = await response.json();

      if (response.status === 200) {
        setGlobalMessageObject({
          type: 'success',
          position: 'description',
          text: 'Descrição salva com sucesso!',
        });
        onSuccess(responseBody);
        return;
      }

      if (response.status === 400) {
        setErrorObject(responseBody);
        return;
      }

      if (response.status >= 403) {
        setGlobalMessageObject({
          type: 'danger',
          position: 'description',
          text: createErrorMessage(responseBody),
        });
      }
    } catch (error) {
      setGlobalMessageObject({
        type: 'danger',
        position: 'description',
        text: 'Não foi possível se conectar ao TabNews. Por favor, verifique sua conexão.',
      });
    } finally {
      setIsPosting(false);
    }
  }

  async function handleCancel() {
    const confirmCancel =
      description !== user.description
        ? await confirm({
            title: 'Tem certeza que deseja sair da edição?',
            content: 'A alteração não foi salva e será perdida.',
            cancelButtonContent: 'Cancelar',
            confirmButtonContent: 'Sim',
          })
        : true;

    if (!confirmCancel) return;

    clearMessages();
    onCancel();
  }

  function handleDescriptionChange(value) {
    setDescription(value);
    clearMessages();
  }

  function clearMessages() {
    setErrorObject(undefined);
    setGlobalMessageObject(null);
  }

  function handleKeyDown(event) {
    if (isPosting) return;
    if (event.key === 'Enter' && (event.ctrlKey || event.metaKey)) {
      handleSubmit(event);
    } else if (event.key === 'Escape') {
      handleCancel();
    }
  }

  return (
    <Box as="form" sx={{ width: '100%' }} onSubmit={handleSubmit}>
      <FormControl id="description">
        {/* Label styled similar to the "read" view so it is in the same position */}
        <FormControl.Label sx={{ display: 'flex', alignItems: 'flex-end', pb: 1, minHeight: '32px' }}>
          Descrição
        </FormControl.Label>
        <Editor
          isInvalid={errorObject?.key === 'description' || description.length > DESCRIPTION_MAX_LENGTH}
          value={description}
          onChange={handleDescriptionChange}
          onKeyDown={handleKeyDown}
          clobberPrefix={`${user.username}-content-`}
        />

        <Box sx={{ display: 'flex', width: '100%' }}>
          {errorObject?.key === 'description' && (
            <FormControl.Validation variant="error">{errorObject.message}</FormControl.Validation>
          )}

          <CharacterCount maxLength={DESCRIPTION_MAX_LENGTH} value={description} />
        </Box>
      </FormControl>

      {globalMessageObject?.position === 'description' && (
        <Flash variant={globalMessageObject.type} sx={{ mt: 3 }}>
          {globalMessageObject.text}
        </Flash>
      )}

      <Box sx={{ display: 'flex', justifyContent: 'flex-end', alignItems: 'center', gap: 3, mt: 3 }}>
        <Button
          variant="invisible"
          type="button"
          disabled={isPosting}
          sx={{ fontWeight: 'normal', color: 'fg.muted' }}
          aria-label="Cancelar alteração"
          onClick={handleCancel}>
          Cancelar
        </Button>

        <ButtonWithLoader variant="primary" type="submit" aria-label="Salvar" isLoading={isPosting}>
          Salvar
        </ButtonWithLoader>
      </Box>
    </Box>
  );
}

function UserFeatures({ userFound }) {
  if (!userFound?.features?.length) return null;

  return (
    <LabelGroup sx={{ display: 'flex', alignSelf: 'center' }}>
      {userFound.features.includes('nuked') && <Label variant="danger">nuked</Label>}
    </LabelGroup>
  );
}

function OptionsMenu({ canUpdate, isAuthenticatedUser, onNuke, setGlobalMessageObject, user, userFound }) {
  const confirm = useConfirm();

  async function handleNuke() {
    setGlobalMessageObject(null);

    const confirmDelete1 = await confirm({
      title: `Atenção: Você está realizando um Nuke!`,
      content: `Deseja banir o usuário "${userFound.username}" e desfazer todas as suas ações?`,
      confirmButtonContent: 'Sim',
      cancelButtonContent: 'Cancelar',
    });

    if (!confirmDelete1) return;

    // Fake delay to avoid multiple accidental clicks
    await new Promise((r) => setTimeout(r, 1000));

    const confirmDelete2 = await confirm({
      title: `Nuke em "${userFound.username}"`,
      content: `Confirme novamente esta operação.`,
    });

    if (!confirmDelete2) return;

    const payload = {
      ban_type: 'nuke',
    };

    const response = await fetch(`/api/v1/users/${userFound.username}`, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload),
    });

    const responseBody = await response.json();

    if (response.status === 200) {
      onNuke(responseBody);
      return;
    }

    setGlobalMessageObject({
      type: 'danger',
      position: 'main',
      text: createErrorMessage(responseBody),
    });
  }

  const canNuke =
    !isAuthenticatedUser && user?.features?.includes('ban:user') && !userFound?.features?.includes('nuked');
  if (!canNuke && !canUpdate) {
    return null;
  }

  return (
    <ActionMenu>
      <ActionMenu.Anchor>
        <IconButton
          sx={{ ml: 'auto', px: 1, alignSelf: 'center' }}
          size="small"
          icon={KebabHorizontalIcon}
          aria-label="Editar usuário"
        />
      </ActionMenu.Anchor>
      <ActionMenu.Overlay>
        <ActionList>
          {canUpdate && (
            <NavItem href="/perfil">
              <NavList.LeadingVisual>
                <GearIcon />
              </NavList.LeadingVisual>
              Editar perfil
            </NavItem>
          )}
          {canNuke && (
            <ActionList.Item variant="danger" onSelect={handleNuke}>
              <ActionList.LeadingVisual>
                <CircleSlashIcon />
              </ActionList.LeadingVisual>
              Nuke
            </ActionList.Item>
          )}
        </ActionList>
      </ActionMenu.Overlay>
    </ActionMenu>
  );
}

export async function getStaticPaths() {
  const relevantResults = await content.findWithStrategy({
    strategy: 'relevant',
    where: {
      parent_id: null,
      status: 'published',
    },
    attributes: {
      exclude: ['body'],
    },
    page: 1,
    per_page: 100,
  });

  const paths = relevantResults.rows.map((content) => {
    return {
      params: {
        username: content.owner_username,
      },
    };
  });

  return {
    paths,
    fallback: 'blocking',
  };
}

export const getStaticProps = getStaticPropsRevalidate(async (context) => {
  const userTryingToGet = user.createAnonymous();

  try {
    context.params = validator(context.params, {
      username: 'required',
      page: 'optional',
      per_page: 'optional',
    });
  } catch (error) {
    return {
      notFound: true,
    };
  }

  let secureUserFound;

  try {
    const userFound = await user.findOneByUsername(context.params.username, { withBalance: true });

    secureUserFound = authorization.filterOutput(userTryingToGet, 'read:user', userFound);
  } catch (error) {
    // `user` model will throw a `NotFoundError` if the user is not found.
    if (error instanceof NotFoundError) {
      return {
        notFound: true,
        revalidate: 1,
      };
    }

    throw error;
  }

  return {
    props: {
      userFound: JSON.parse(JSON.stringify(secureUserFound)),
    },

    revalidate: 10,
  };
});
</file>

<file path="pages/api/v1/_responses/rate-limit-reached-sessions.public.js">
import { createRouter } from 'next-connect';
import { randomUUID as uuidV4 } from 'node:crypto';
import snakeize from 'snakeize';

import { ForbiddenError, TooManyRequestsError, UnauthorizedError } from 'errors';
import logger from 'infra/logger.js';
import controller from 'models/controller.js';
import ip from 'models/ip.js';
import validator from 'models/validator.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(logRequest)
  .get(getValidationHandler, getHandler)
  .post(postValidationHandler, postHandler)
  .handler(controller.handlerOptions);

function getValidationHandler(request, response, next) {
  if (request.cookies?.session_id) {
    validator(request.cookies, {
      session_id: 'required',
    });
  }

  return next();
}

function logRequest(request, response, next) {
  const error = new TooManyRequestsError({
    context: {
      method: request.method,
      url: request.url,
      body: request.body,
      clientIp: ip.extractFromRequest(request),
      type: 'sessions',
    },
  });

  logger.error(snakeize(error));

  return next();
}

function getHandler(request, response) {
  const error = new ForbiddenError({
    message: 'Usuário não pode executar esta operação.',
    action: 'Verifique se este usuário possui a feature "read:session".',
    requestId: uuidV4(),
    errorId: uuidV4(),
    errorLocationCode: 'MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND',
  });

  response.status(error.statusCode).json(snakeize(error));
}

function postValidationHandler(request, response, next) {
  validator(request.body, {
    email: 'required',
    password: 'required',
  });

  return next();
}

async function postHandler(request, response) {
  const error = new UnauthorizedError({
    message: 'Dados não conferem.',
    action: 'Verifique se os dados enviados estão corretos.',
    requestId: uuidV4(),
    errorLocationCode: 'CONTROLLER:SESSIONS:POST_HANDLER:DATA_MISMATCH',
  });

  await fakeLatency();

  response.status(error.statusCode).json(snakeize(error));
}

async function fakeLatency() {
  const latency = random(100, 1000);
  await new Promise((r) => setTimeout(r, latency));

  function random(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
  }
}
</file>

<file path="pages/api/v1/_responses/rate-limit-reached.public.js">
import snakeize from 'snakeize';

import { TooManyRequestsError } from 'errors';
import logger from 'infra/logger.js';
import ip from 'models/ip.js';

export default function handler(request, response) {
  const error = new TooManyRequestsError({
    context: {
      method: request.method,
      url: request.url,
      body: request.body,
      clientIp: ip.extractFromRequest(request),
      type: 'general',
    },
  });

  logger.error(snakeize(error));
  delete error.context;

  response.status(error.statusCode).json(snakeize(error));
}
</file>

<file path="pages/api/v1/activation/index.public.js">
import { createRouter } from 'next-connect';

import activation from 'models/activation.js';
import authentication from 'models/authentication.js';
import authorization from 'models/authorization.js';
import cacheControl from 'models/cache-control';
import controller from 'models/controller.js';
import validator from 'models/validator.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(authentication.injectAnonymousOrUser)
  .use(controller.logRequest)
  .use(cacheControl.noCache)
  .patch(patchValidationHandler, authorization.canRequest('read:activation_token'), patchHandler)
  .handler(controller.handlerOptions);

function patchValidationHandler(request, response, next) {
  const cleanValues = validator(request.body, {
    token_id: 'required',
  });

  request.body = cleanValues;
  return next();
}
async function patchHandler(request, response) {
  const userTryingToActivate = request.context.user;
  const insecureInputValues = request.body;

  //TODO: validate input values with the new validation strategy
  const secureInputValues = authorization.filterInput(
    userTryingToActivate,
    'read:activation_token',
    insecureInputValues,
  );

  const tokenObject = await activation.activateUserUsingTokenId(secureInputValues.tokenId);

  const authorizedValuesToReturn = authorization.filterOutput(
    userTryingToActivate,
    'read:activation_token',
    tokenObject,
  );

  return response.status(200).json(authorizedValuesToReturn);
}
</file>

<file path="pages/api/v1/analytics/child-content-published/index.public.js">
import { createRouter } from 'next-connect';

import analytics from 'models/analytics.js';
import cacheControl from 'models/cache-control';
import controller from 'models/controller.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(controller.logRequest)
  .use(cacheControl.swrMaxAge(300))
  .get(getHandler)
  .handler(controller.handlerOptions);

async function getHandler(request, response) {
  const contentsPublished = await analytics.getChildContentsPublished();

  return response.status(200).json(contentsPublished);
}
</file>

<file path="pages/api/v1/analytics/root-content-published/index.public.js">
import { createRouter } from 'next-connect';

import analytics from 'models/analytics.js';
import cacheControl from 'models/cache-control';
import controller from 'models/controller.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(controller.logRequest)
  .use(cacheControl.swrMaxAge(300))
  .get(getHandler)
  .handler(controller.handlerOptions);

async function getHandler(request, response) {
  const contentsPublished = await analytics.getRootContentsPublished();

  return response.status(200).json(contentsPublished);
}
</file>

<file path="pages/api/v1/analytics/users-created/index.public.js">
import { createRouter } from 'next-connect';

import analytics from 'models/analytics.js';
import cacheControl from 'models/cache-control';
import controller from 'models/controller.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(controller.logRequest)
  .use(cacheControl.swrMaxAge(300))
  .get(getHandler)
  .handler(controller.handlerOptions);

async function getHandler(request, response) {
  const usersCreated = await analytics.getUsersCreated();

  return response.status(200).json(usersCreated);
}
</file>

<file path="pages/api/v1/contents/[username]/[slug]/children/index.public.js">
import { createRouter } from 'next-connect';

import { NotFoundError } from 'errors';
import authorization from 'models/authorization.js';
import cacheControl from 'models/cache-control';
import content from 'models/content.js';
import controller from 'models/controller.js';
import user from 'models/user.js';
import validator from 'models/validator.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(controller.logRequest)
  .use(cacheControl.swrMaxAge(10))
  .get(getValidationHandler, getHandler)
  .handler(controller.handlerOptions);

function getValidationHandler(request, response, next) {
  const cleanValues = validator(request.query, {
    username: 'required',
    slug: 'required',
  });

  request.query = cleanValues;

  return next();
}

async function getHandler(request, response) {
  const userTryingToGet = user.createAnonymous();

  const contentTreeFound = await content.findTree({
    where: {
      owner_username: request.query.username,
      slug: request.query.slug,
    },
  });

  if (!contentTreeFound?.length) {
    throw new NotFoundError({
      message: `O conteúdo informado não foi encontrado no sistema.`,
      action: 'Verifique se o "slug" está digitado corretamente.',
      stack: new Error().stack,
      errorLocationCode: 'CONTROLLER:CONTENT:CHILDREN:GET_HANDLER:SLUG_NOT_FOUND',
      key: 'slug',
    });
  }

  const childrenFound = contentTreeFound[0].children;

  const secureOutputValues = authorization.filterOutput(userTryingToGet, 'read:content:list', childrenFound);

  return response.status(200).json(secureOutputValues);
}
</file>

<file path="pages/api/v1/contents/[username]/[slug]/parent/index.public.js">
import { createRouter } from 'next-connect';

import { NotFoundError } from 'errors';
import authorization from 'models/authorization.js';
import cacheControl from 'models/cache-control';
import content from 'models/content.js';
import controller from 'models/controller.js';
import user from 'models/user.js';
import validator from 'models/validator.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(controller.logRequest)
  .use(cacheControl.swrMaxAge(10))
  .get(getValidationHandler, getHandler)
  .handler(controller.handlerOptions);

function getValidationHandler(request, response, next) {
  const cleanValues = validator(request.query, {
    username: 'required',
    slug: 'required',
  });

  request.query = cleanValues;

  return next();
}

async function getHandler(request, response) {
  const userTryingToGet = user.createAnonymous();

  const contentFound = await content.findOne({
    where: {
      owner_username: request.query.username,
      slug: request.query.slug,
      status: 'published',
    },
  });

  if (!contentFound) {
    throw new NotFoundError({
      message: `O conteúdo informado não foi encontrado no sistema.`,
      action: 'Verifique se o "slug" está digitado corretamente.',
      stack: new Error().stack,
      errorLocationCode: 'CONTROLLER:CONTENT:PARENT:GET_HANDLER:SLUG_NOT_FOUND',
      key: 'slug',
    });
  }

  if (!contentFound.parent_id) {
    throw new NotFoundError({
      message: `O conteúdo requisitado é um conteúdo raiz.`,
      action:
        'Busque apenas por conteúdos com "parent_id", pois este conteúdo não possui níveis superiores na árvore de conteúdos.',
      stack: new Error().stack,
      errorLocationCode: 'CONTROLLER:CONTENT:PARENT:GET_HANDLER:ALREADY_ROOT',
      key: 'parent_id',
    });
  }

  const parentContentFound = await content.findOne({
    where: {
      id: contentFound.parent_id,
    },
  });

  const secureParentContent = authorization.filterOutput(userTryingToGet, 'read:content', parentContentFound);

  return response.status(200).json(secureParentContent);
}
</file>

<file path="pages/api/v1/contents/[username]/[slug]/root/index.public.js">
import { createRouter } from 'next-connect';

import { NotFoundError } from 'errors';
import authorization from 'models/authorization.js';
import cacheControl from 'models/cache-control';
import content from 'models/content.js';
import controller from 'models/controller.js';
import user from 'models/user.js';
import validator from 'models/validator.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(controller.logRequest)
  .use(cacheControl.swrMaxAge(10))
  .get(getValidationHandler, getHandler)
  .handler(controller.handlerOptions);

function getValidationHandler(request, response, next) {
  const cleanValues = validator(request.query, {
    username: 'required',
    slug: 'required',
  });

  request.query = cleanValues;

  return next();
}

async function getHandler(request, response) {
  const userTryingToGet = user.createAnonymous();

  const contentFound = await content.findOne({
    where: {
      owner_username: request.query.username,
      slug: request.query.slug,
      status: 'published',
    },
  });

  if (!contentFound) {
    throw new NotFoundError({
      message: `O conteúdo informado não foi encontrado no sistema.`,
      action: 'Verifique se o "slug" está digitado corretamente.',
      stack: new Error().stack,
      errorLocationCode: 'CONTROLLER:CONTENT:ROOT:GET_HANDLER:SLUG_NOT_FOUND',
      key: 'slug',
    });
  }

  if (!contentFound.parent_id) {
    throw new NotFoundError({
      message: `O conteúdo requisitado é um conteúdo raiz.`,
      action:
        'Busque apenas por conteúdos com "parent_id", pois este conteúdo não possui níveis superiores na árvore de conteúdos.',
      stack: new Error().stack,
      errorLocationCode: 'CONTROLLER:CONTENT:ROOT:GET_HANDLER:ALREADY_ROOT',
      key: 'parent_id',
    });
  }

  const rootContentFound = await content.findOne({
    where: {
      id: contentFound.path[0],
    },
  });

  const secureOutputValues = authorization.filterOutput(userTryingToGet, 'read:content', rootContentFound);

  return response.status(200).json(secureOutputValues);
}
</file>

<file path="pages/api/v1/contents/[username]/[slug]/tabcoins/index.public.js">
import { createRouter } from 'next-connect';

import { NotFoundError, UnprocessableEntityError, ValidationError } from 'errors';
import database from 'infra/database.js';
import authentication from 'models/authentication.js';
import authorization from 'models/authorization.js';
import balance from 'models/balance.js';
import cacheControl from 'models/cache-control';
import content from 'models/content.js';
import controller from 'models/controller.js';
import event from 'models/event.js';
import validator from 'models/validator.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(authentication.injectAnonymousOrUser)
  .use(controller.logRequest)
  .use(cacheControl.noCache)
  .post(postValidationHandler, authorization.canRequest('update:content'), postHandler)
  .handler(controller.handlerOptions);

function postValidationHandler(request, response, next) {
  const cleanQueryValues = validator(request.query, {
    username: 'required',
    slug: 'required',
  });

  request.query = cleanQueryValues;

  const cleanBodyValues = validator(request.body, {
    transaction_type: 'required',
  });

  request.body = cleanBodyValues;

  return next();
}

async function postHandler(request, response) {
  const userTryingToPost = request.context.user;

  const contentFound = await content.findOne({
    where: {
      owner_username: request.query.username,
      slug: request.query.slug,
      status: 'published',
    },
  });

  if (!contentFound) {
    throw new NotFoundError({
      message: `O conteúdo informado não foi encontrado no sistema.`,
      action: 'Verifique se o "slug" está digitado corretamente.',
      stack: new Error().stack,
      errorLocationCode: 'CONTROLLER:CONTENT:TABCOINS:CONTENT_NOT_FOUND',
      key: 'slug',
    });
  }

  if (userTryingToPost.id === contentFound.owner_id) {
    throw new UnprocessableEntityError({
      message: `Você não pode realizar esta operação em conteúdos de sua própria autoria.`,
      action: 'Realize esta operação em conteúdos de outros usuários.',
      stack: new Error().stack,
      errorLocationCode: 'CONTROLLER:CONTENT:TABCOINS:OWN_CONTENT',
      key: 'tabcoins',
    });
  }

  // TODO: Refactor firewall.js to accept other parameters such as content.id
  // and move this function to there.
  await canIpUpdateContentTabCoins(request.context.clientIp, contentFound.id);

  let currentContentTabCoinsBalance;

  await tabcoinsTransaction(null, 5);

  async function tabcoinsTransaction(transaction, remainingAttempts) {
    if (!transaction) {
      transaction = await database.transaction();
    }

    try {
      await transaction.query('BEGIN');
      await transaction.query('SET TRANSACTION ISOLATION LEVEL SERIALIZABLE');

      const tabCoinsRequiredAmount = 2;

      const currentEvent = await event.create(
        {
          type: 'update:content:tabcoins',
          originator_user_id: request.context.user.id,
          originator_ip: request.context.clientIp,
          metadata: {
            transaction_type: request.body.transaction_type,
            from_user_id: userTryingToPost.id,
            content_owner_id: contentFound.owner_id,
            content_id: contentFound.id,
            amount: tabCoinsRequiredAmount,
          },
        },
        {
          transaction: transaction,
        },
      );

      currentContentTabCoinsBalance = await balance.rateContent(
        {
          contentId: contentFound.id,
          contentOwnerId: contentFound.owner_id,
          fromUserId: userTryingToPost.id,
          transactionType: request.body.transaction_type,
        },
        {
          eventId: currentEvent.id,
          transaction: transaction,
        },
      );

      await transaction.query('COMMIT');
      await transaction.release();
    } catch (error) {
      await transaction.query('ROLLBACK');

      if (
        error.databaseErrorCode === database.errorCodes.SERIALIZATION_FAILURE ||
        error.stack?.startsWith('error: could not serialize access due to read/write dependencies among transaction')
      ) {
        if (remainingAttempts > 0) {
          await tabcoinsTransaction(transaction, remainingAttempts - 1);
        } else {
          await transaction.release();
          throw new UnprocessableEntityError({
            message: `Muitos votos ao mesmo tempo.`,
            action: 'Tente realizar esta operação mais tarde.',
            errorLocationCode: 'CONTROLLER:CONTENT:TABCOINS:SERIALIZATION_FAILURE',
          });
        }
      } else {
        await transaction.release();
        throw error;
      }
    }
  }

  const secureOutputValues = authorization.filterOutput(
    userTryingToPost,
    'read:content:tabcoins',
    currentContentTabCoinsBalance,
  );

  return response.status(201).json(secureOutputValues);
}

async function canIpUpdateContentTabCoins(clientIp, contentId) {
  const results = await database.query({
    text: `
      SELECT
        count(*)
      FROM
        events
      WHERE
        type = 'update:content:tabcoins'
        AND originator_ip = $1
        AND metadata->>'content_id' = $2
        AND created_at > NOW() - INTERVAL '72 hours'
      ;`,
    values: [clientIp, contentId],
  });

  const pass = results.rows[0].count > 2 ? false : true;

  if (!pass) {
    throw new ValidationError({
      message: 'Você está tentando qualificar muitas vezes o mesmo conteúdo.',
      action: 'Esta operação não poderá ser repetida dentro de 72 horas.',
    });
  }
}
</file>

<file path="pages/api/v1/contents/[username]/[slug]/thumbnail/index.public.js">
import { createRouter } from 'next-connect';

import { NotFoundError } from 'errors';
import cacheControl from 'models/cache-control';
import content from 'models/content.js';
import controller from 'models/controller';
import thumbnail from 'models/thumbnail.js';
import validator from 'models/validator.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(controller.logRequest)
  .use(cacheControl.swrMaxAge(60))
  .get(getValidationHandler, getHandler)
  .handler(controller.handlerOptions);

function getValidationHandler(request, response, next) {
  const cleanValues = validator(request.query, {
    username: 'required',
    slug: 'required',
  });

  request.query = cleanValues;

  return next();
}

async function getHandler(request, response) {
  const contentFound = await content.findOne({
    where: {
      owner_username: request.query.username,
      slug: request.query.slug,
      status: 'published',
    },
  });

  if (!contentFound) {
    throw new NotFoundError({
      message: `Este conteúdo não está disponível.`,
      action: 'Verifique se o "slug" está digitado corretamente ou considere o fato do conteúdo ter sido despublicado.',
      stack: new Error().stack,
      errorLocationCode: 'CONTROLLER:CONTENT:THUMBNAIL:GET_HANDLER:SLUG_NOT_FOUND',
      key: 'slug',
    });
  }

  const thumbnailPng = await thumbnail.asPng(contentFound);

  response.statusCode = 200;
  response.setHeader('Content-Type', `image/png`);
  response.end(thumbnailPng);
}
</file>

<file path="pages/api/v1/contents/[username]/[slug]/index.public.js">
import { createRouter } from 'next-connect';

import { ForbiddenError, NotFoundError } from 'errors';
import database from 'infra/database.js';
import authentication from 'models/authentication.js';
import authorization from 'models/authorization.js';
import cacheControl from 'models/cache-control';
import content from 'models/content.js';
import controller from 'models/controller.js';
import event from 'models/event.js';
import user from 'models/user.js';
import validator from 'models/validator.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(controller.logRequest)
  .get(cacheControl.swrMaxAge(10), getValidationHandler, getHandler)
  .patch(
    cacheControl.noCache,
    authentication.injectAnonymousOrUser,
    patchValidationHandler,
    authorization.canRequest('update:content'),
    patchHandler,
  )
  .handler(controller.handlerOptions);

function getValidationHandler(request, response, next) {
  const cleanValues = validator(request.query, {
    username: 'required',
    slug: 'required',
  });

  request.query = cleanValues;

  return next();
}

async function getHandler(request, response) {
  const userTryingToGet = user.createAnonymous();

  const contentFound = await content.findOne({
    where: {
      owner_username: request.query.username,
      slug: request.query.slug,
      status: 'published',
    },
  });

  if (!contentFound) {
    throw new NotFoundError({
      message: `O conteúdo informado não foi encontrado no sistema.`,
      action: 'Verifique se o "slug" está digitado corretamente.',
      stack: new Error().stack,
      errorLocationCode: 'CONTROLLER:CONTENT:GET_HANDLER:SLUG_NOT_FOUND',
      key: 'slug',
    });
  }

  const secureOutputValues = authorization.filterOutput(userTryingToGet, 'read:content', contentFound);

  return response.status(200).json(secureOutputValues);
}

function patchValidationHandler(request, response, next) {
  const cleanQueryValues = validator(request.query, {
    username: 'required',
    slug: 'required',
  });

  request.query = cleanQueryValues;

  const cleanBodyValues = validator(request.body, {
    slug: 'optional',
    title: 'optional',
    body: 'optional',
    status: 'optional',
    source_url: 'optional',
  });

  request.body = cleanBodyValues;

  return next();
}

async function patchHandler(request, response) {
  const userTryingToPatch = request.context.user;
  const unfilteredBodyValues = request.body;

  const contentToBeUpdated = await content.findOne({
    where: {
      owner_username: request.query.username,
      slug: request.query.slug,
      status: ['draft', 'published'],
    },
  });

  if (!contentToBeUpdated) {
    throw new NotFoundError({
      message: `O conteúdo informado não foi encontrado no sistema.`,
      action: 'Verifique se o "slug" está digitado corretamente.',
      stack: new Error().stack,
      errorLocationCode: 'CONTROLLER:CONTENT:PATCH_HANDLER:SLUG_NOT_FOUND',
      key: 'slug',
    });
  }

  if (!authorization.can(userTryingToPatch, 'update:content', contentToBeUpdated)) {
    throw new ForbiddenError({
      message: 'Você não possui permissão para atualizar o conteúdo de outro usuário.',
      action: 'Verifique se você possui a feature "update:content:others".',
      errorLocationCode: 'CONTROLLER:CONTENTS:PATCH:USER_CANT_UPDATE_CONTENT_FROM_OTHER_USER',
    });
  }

  if (!contentToBeUpdated.parent_id) {
    if (!authorization.can(userTryingToPatch, 'create:content:text_root')) {
      throw new ForbiddenError({
        message: 'Você não possui permissão para editar conteúdos na raiz do site.',
        action: 'Verifique se você possui a feature "create:content:text_root".',
        errorLocationCode: 'CONTROLLER:CONTENT:PATCH_HANDLER:CREATE:CONTENT:TEXT_ROOT:FEATURE_NOT_FOUND',
      });
    }
  } else {
    if (!authorization.can(userTryingToPatch, 'create:content:text_child')) {
      throw new ForbiddenError({
        message: 'Você não possui permissão para editar conteúdos dentro de outros conteúdos.',
        action: 'Verifique se você possui a feature "create:content:text_child".',
        errorLocationCode: 'CONTROLLER:CONTENT:PATCH_HANDLER:CREATE:CONTENT:TEXT_CHILD:FEATURE_NOT_FOUND',
      });
    }
  }

  const filteredBodyValues = authorization.filterInput(
    userTryingToPatch,
    'update:content',
    unfilteredBodyValues,
    contentToBeUpdated,
  );

  const transaction = await database.transaction();

  try {
    await transaction.query('BEGIN');

    const currentEvent = await event.create(
      {
        type: contentToBeUpdated.parent_id ? 'update:content:text_child' : 'update:content:text_root',
        originator_user_id: request.context.user.id,
        originator_ip: request.context.clientIp,
        metadata: {
          id: contentToBeUpdated.id,
        },
      },
      {
        transaction: transaction,
      },
    );

    const updatedContent = await content.update(contentToBeUpdated.id, filteredBodyValues, {
      oldContent: contentToBeUpdated,
      eventId: currentEvent.id,
      transaction: transaction,
    });

    await transaction.query('COMMIT');
    await transaction.release();

    const secureOutputValues = authorization.filterOutput(userTryingToPatch, 'read:content', updatedContent);

    return response.status(200).json(secureOutputValues);
  } catch (error) {
    await transaction.query('ROLLBACK');
    await transaction.release();
    throw error;
  }
}
</file>

<file path="pages/api/v1/contents/[username]/index.public.js">
import { createRouter } from 'next-connect';

import authorization from 'models/authorization.js';
import cacheControl from 'models/cache-control';
import content from 'models/content.js';
import controller from 'models/controller.js';
import removeMarkdown from 'models/remove-markdown.js';
import user from 'models/user.js';
import validator from 'models/validator.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(controller.logRequest)
  .use(cacheControl.swrMaxAge(10))
  .get(getValidationHandler, getHandler)
  .handler(controller.handlerOptions);

function getValidationHandler(request, response, next) {
  const cleanValues = validator(request.query, {
    username: 'required',
    page: 'optional',
    per_page: 'optional',
    strategy: 'optional',
    with_root: 'optional',
    with_children: 'optional',
  });

  request.query = cleanValues;

  return next();
}

async function getHandler(request, response) {
  const userTryingToGet = user.createAnonymous();

  const results = await content.findWithStrategy({
    strategy: request.query.strategy,
    where: {
      parent_id: request.query.with_children === false ? null : undefined,
      owner_username: request.query.username,
      status: 'published',
      $not_null: request.query.with_root === false ? ['parent_id'] : undefined,
    },
    page: request.query.page,
    per_page: request.query.per_page,
  });
  const contentListFound = results.rows;

  const secureOutputValues = authorization.filterOutput(userTryingToGet, 'read:content:list', contentListFound);

  for (const content of secureOutputValues) {
    if (content.parent_id) {
      content.body = removeMarkdown(content.body, { maxLength: 255 });
    } else {
      delete content.body;
    }
  }

  controller.injectPaginationHeaders(
    results.pagination,
    `/api/v1/contents/${request.query.username}`,
    request,
    response,
  );

  return response.status(200).json(secureOutputValues);
}
</file>

<file path="pages/api/v1/contents/rss/index.public.js">
import { createRouter } from 'next-connect';

import authorization from 'models/authorization.js';
import cacheControl from 'models/cache-control';
import content from 'models/content.js';
import controller from 'models/controller.js';
import rss from 'models/rss';
import user from 'models/user.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(controller.logRequest)
  .use(cacheControl.swrMaxAge(60))
  .get(handleRequest)
  .handler(controller.handlerOptions);

async function handleRequest(request, response) {
  const userTryingToList = user.createAnonymous();

  const results = await content.findWithStrategy({
    strategy: 'new',
    where: {
      parent_id: null,
      status: 'published',
      type: 'content',
    },
    page: 1,
    per_page: 30,
  });

  const contentListFound = results.rows;

  const secureContentListFound = authorization.filterOutput(userTryingToList, 'read:content:list', contentListFound);
  const rss2 = rss.generateRss2(secureContentListFound);

  response.setHeader('Content-Type', 'text/xml; charset=utf-8');
  response.status(200).send(rss2);
}
</file>

<file path="pages/api/v1/contents/index.public.js">
import { createRouter } from 'next-connect';
import { randomUUID as uuidV4 } from 'node:crypto';

import { ForbiddenError } from 'errors';
import database from 'infra/database.js';
import authentication from 'models/authentication.js';
import authorization from 'models/authorization.js';
import cacheControl from 'models/cache-control';
import content from 'models/content.js';
import controller from 'models/controller.js';
import event from 'models/event.js';
import firewall from 'models/firewall';
import notification from 'models/notification.js';
import removeMarkdown from 'models/remove-markdown';
import user from 'models/user.js';
import validator from 'models/validator.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(controller.logRequest)
  .get(cacheControl.swrMaxAge(10), getValidationHandler, getHandler)
  .post(
    cacheControl.noCache,
    authentication.injectAnonymousOrUser,
    postValidationHandler,
    authorization.canRequest('create:content'),
    firewallValidationHandler,
    postHandler,
  )
  .handler(controller.handlerOptions);

function getValidationHandler(request, response, next) {
  const cleanValues = validator(request.query, {
    page: 'optional',
    per_page: 'optional',
    strategy: 'optional',
    with_root: 'optional',
    with_children: 'optional',
  });

  request.query = cleanValues;

  return next();
}

async function getHandler(request, response) {
  const userTryingToList = user.createAnonymous();

  const results = await content.findWithStrategy({
    strategy: request.query.strategy,
    where: {
      parent_id: request.query.with_children ? undefined : null,
      status: 'published',
      type: 'content',
      $not_null: request.query.with_root === false ? ['parent_id'] : undefined,
    },
    attributes: {
      exclude: request.query.with_children ? undefined : ['body'],
    },
    page: request.query.page,
    per_page: request.query.per_page,
  });

  const contentList = results.rows;

  const secureOutputValues = authorization.filterOutput(userTryingToList, 'read:content:list', contentList);

  if (request.query.with_children) {
    for (const content of secureOutputValues) {
      if (content.parent_id) {
        content.body = removeMarkdown(content.body, { maxLength: 255 });
      } else {
        delete content.body;
      }
    }
  }

  controller.injectPaginationHeaders(results.pagination, '/api/v1/contents', request, response);

  return response.status(200).json(secureOutputValues);
}

function postValidationHandler(request, response, next) {
  const cleanValues = validator(request.body, {
    parent_id: 'optional',
    slug: 'optional',
    title: 'optional',
    body: 'required',
    status: 'optional',
    content_type: 'optional',
    source_url: 'optional',
  });

  request.body = cleanValues;

  return next();
}

function firewallValidationHandler(request, response, next) {
  if (!request.body.parent_id) {
    return firewall.canRequest('create:content:text_root')(request, response, next);
  }

  return firewall.canRequest('create:content:text_child')(request, response, next);
}

async function postHandler(request, response) {
  const userTryingToCreate = request.context.user;
  const insecureInputValues = request.body;

  let secureInputValues;

  if (!insecureInputValues.parent_id) {
    if (!authorization.can(userTryingToCreate, 'create:content:text_root')) {
      throw new ForbiddenError({
        message: 'Você não possui permissão para criar conteúdos na raiz do site.',
        action: 'Verifique se você possui a feature "create:content:text_root".',
        errorLocationCode: 'CONTROLLER:CONTENT:POST_HANDLER:CREATE:CONTENT:TEXT_ROOT:FEATURE_NOT_FOUND',
      });
    }

    secureInputValues = authorization.filterInput(userTryingToCreate, 'create:content:text_root', insecureInputValues);
  } else {
    if (!authorization.can(userTryingToCreate, 'create:content:text_child')) {
      throw new ForbiddenError({
        message: 'Você não possui permissão para criar conteúdos dentro de outros conteúdos.',
        action: 'Verifique se você possui a feature "create:content:text_child".',
        errorLocationCode: 'CONTROLLER:CONTENT:POST_HANDLER:CREATE:CONTENT:TEXT_CHILD:FEATURE_NOT_FOUND',
      });
    }

    secureInputValues = authorization.filterInput(userTryingToCreate, 'create:content:text_child', insecureInputValues);
  }

  secureInputValues.owner_id = userTryingToCreate.id;
  secureInputValues.id = uuidV4();

  const transaction = await database.transaction();

  try {
    await transaction.query('BEGIN');

    const currentEvent = await event.create(
      {
        type: secureInputValues.parent_id ? 'create:content:text_child' : 'create:content:text_root',
        originator_user_id: request.context.user.id,
        originator_ip: request.context.clientIp,
        metadata: {
          id: secureInputValues.id,
        },
      },
      {
        transaction: transaction,
      },
    );

    const createdContent = await content.create(secureInputValues, {
      eventId: currentEvent.id,
      transaction: transaction,
    });

    await transaction.query('COMMIT');
    await transaction.release();

    const secureOutputValues = authorization.filterOutput(userTryingToCreate, 'read:content', createdContent);
    const sendStream = !!insecureInputValues.parent_id && request.headers.accept?.includes('application/x-ndjson');

    response.status(201);

    if (sendStream) {
      response.setHeader('Content-Type', 'application/x-ndjson');
      response.write(JSON.stringify(secureOutputValues) + '\n');
    }

    if (createdContent.parent_id) {
      try {
        await notification.sendReplyEmailToParentUser(createdContent);
      } catch (error) {
        if (sendStream) throw error;
      }
    }

    if (sendStream) {
      response.end();
    } else {
      response.json(secureOutputValues);
    }
  } catch (error) {
    await transaction.query('ROLLBACK');
    await transaction.release();
    throw error;
  }
}
</file>

<file path="pages/api/v1/email-confirmation/index.public.js">
import { createRouter } from 'next-connect';

import authentication from 'models/authentication.js';
import authorization from 'models/authorization.js';
import cacheControl from 'models/cache-control';
import controller from 'models/controller.js';
import emailConfirmation from 'models/email-confirmation.js';
import validator from 'models/validator.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(authentication.injectAnonymousOrUser)
  .use(controller.logRequest)
  .use(cacheControl.noCache)
  .patch(patchValidationHandler, patchHandler)
  .handler(controller.handlerOptions);

function patchValidationHandler(request, response, next) {
  const cleanValues = validator(request.body, {
    token_id: 'required',
  });

  request.body = cleanValues;

  return next();
}

async function patchHandler(request, response) {
  const userTryingToChangeEmail = request.context.user;
  const validatedInputValues = request.body;

  const tokenObject = await emailConfirmation.confirmEmailUpdate(validatedInputValues.token_id);

  const authorizedValuesToReturn = authorization.filterOutput(
    userTryingToChangeEmail,
    'read:email_confirmation_token',
    tokenObject,
  );

  return response.status(200).json(authorizedValuesToReturn);
}
</file>

<file path="pages/api/v1/events/firewall/[id]/index.public.js">
import { createRouter } from 'next-connect';

import authentication from 'models/authentication';
import authorization from 'models/authorization';
import cacheControl from 'models/cache-control';
import controller from 'models/controller';
import firewall from 'models/firewall';
import validator from 'models/validator';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(controller.logRequest)
  .use(authentication.injectAnonymousOrUser)
  .get(cacheControl.noCache, getValidationHandler, authorization.canRequest('read:firewall'), getHandler)
  .handler(controller.handlerOptions);

function getValidationHandler(request, response, next) {
  const cleanValues = validator(request.query, {
    id: 'required',
  });

  request.query = cleanValues;

  return next();
}

async function getHandler(request, response) {
  const userTryingToGet = request.context.user;

  const data = await firewall.findByEventId(request.query.id);

  const secureOutputValues = authorization.filterOutput(userTryingToGet, 'read:firewall', data);

  return response.status(200).json(secureOutputValues);
}
</file>

<file path="pages/api/v1/migrations/index.public.js">
import { createRouter } from 'next-connect';

import migrator from 'infra/migrator.js';
import authentication from 'models/authentication.js';
import authorization from 'models/authorization.js';
import cacheControl from 'models/cache-control';
import controller from 'models/controller.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(authentication.injectAnonymousOrUser)
  .use(controller.logRequest)
  .use(cacheControl.noCache)
  .get(authorization.canRequest('read:migration'), getHandler)
  .post(authorization.canRequest('create:migration'), postHandler)
  .handler(controller.handlerOptions);

async function getHandler(request, response) {
  const pendingMigrations = await migrator.listPendingMigrations();
  return response.status(200).json(pendingMigrations);
}

async function postHandler(request, response) {
  const migratedMigrations = await migrator.runPendingMigrations();

  if (migratedMigrations.length > 0) {
    return response.status(201).json(migratedMigrations);
  }

  return response.status(200).json(migratedMigrations);
}
</file>

<file path="pages/api/v1/moderations/review_firewall/[id]/index.public.js">
import { createRouter } from 'next-connect';

import authentication from 'models/authentication';
import authorization from 'models/authorization';
import cacheControl from 'models/cache-control';
import controller from 'models/controller';
import firewall from 'models/firewall';
import validator from 'models/validator';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(controller.logRequest)
  .use(authentication.injectAnonymousOrUser)
  .post(cacheControl.noCache, postValidationHandler, authorization.canRequest('review:firewall'), postHandler)
  .handler(controller.handlerOptions);

function postValidationHandler(request, response, next) {
  const cleanQueryValues = validator(request.query, {
    id: 'required',
  });

  const cleanBodyValues = validator(request.body, {
    firewall_review_action: 'required',
  });

  request.query = cleanQueryValues;
  request.body = cleanBodyValues;

  return next();
}

async function postHandler(request, response) {
  const eventId = request.query.id;
  const action = request.body.action;
  const originatorIp = request.context.clientIp;
  const originatorUserId = request.context.user.id;

  const firewallData = await firewall.reviewEvent({
    eventId,
    action,
    originatorIp,
    originatorUserId,
  });

  const secureOutputValues = authorization.filterOutput(request.context.user, 'read:firewall', firewallData);

  return response.status(200).json(secureOutputValues);
}
</file>

<file path="pages/api/v1/recovery/index.public.js">
import { createRouter } from 'next-connect';

import { ForbiddenError } from 'errors';
import authentication from 'models/authentication.js';
import authorization from 'models/authorization.js';
import cacheControl from 'models/cache-control';
import controller from 'models/controller.js';
import event from 'models/event';
import recovery from 'models/recovery.js';
import validator from 'models/validator.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(authentication.injectAnonymousOrUser)
  .use(controller.logRequest)
  .use(cacheControl.noCache)
  .post(postValidationHandler, postHandler)
  .patch(patchValidationHandler, patchHandler)
  .handler(controller.handlerOptions);

function postValidationHandler(request, response, next) {
  const cleanValues = validator(request.body, {
    username: 'optional',
    email: 'optional',
  });

  request.body = cleanValues;

  return next();
}

async function postHandler(request, response) {
  const userTryingToRecover = request.context.user;
  const validatedInputValues = request.body;

  if (validatedInputValues.username && !authorization.can(userTryingToRecover, 'create:recovery_token:username')) {
    throw new ForbiddenError({
      message: `Você não possui permissão para criar um token de recuperação com username.`,
      action: `Verifique se este usuário tem a feature "create:recovery_token:username".`,
      errorLocationCode: 'CONTROLLER:RECOVERY:POST_HANDLER:CAN_NOT_CREATE_RECOVERY_TOKEN_USERNAME',
    });
  }

  const tokenObject = await recovery.requestPasswordRecovery(validatedInputValues);

  const authorizedValuesToReturn = authorization.filterOutput(userTryingToRecover, 'read:recovery_token', tokenObject);

  return response.status(201).json(authorizedValuesToReturn);
}

function patchValidationHandler(request, response, next) {
  const cleanValues = validator(request.body, {
    token_id: 'required',
    password: 'required',
  });

  request.body = cleanValues;

  return next();
}

async function patchHandler(request, response) {
  const userTryingToRecover = request.context.user;
  const validatedInputValues = request.body;

  const tokenObject = await recovery.resetUserPassword(validatedInputValues);

  await event.create({
    type: 'update:user',
    originator_user_id: request.context.user.id,
    originator_ip: request.context.clientIp,
    metadata: {
      id: tokenObject.user_id,
      updatedFields: ['password'],
    },
  });

  const authorizedValuesToReturn = authorization.filterOutput(userTryingToRecover, 'read:recovery_token', tokenObject);

  return response.status(200).json(authorizedValuesToReturn);
}
</file>

<file path="pages/api/v1/sessions/index.public.js">
import { createRouter } from 'next-connect';

import { ForbiddenError, UnauthorizedError } from 'errors';
import activation from 'models/activation.js';
import authentication from 'models/authentication.js';
import authorization from 'models/authorization.js';
import cacheControl from 'models/cache-control';
import controller from 'models/controller.js';
import session from 'models/session';
import user from 'models/user';
import validator from 'models/validator.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(authentication.injectAnonymousOrUser)
  .use(controller.logRequest)
  .use(cacheControl.noCache)
  .delete(authorization.canRequest('read:session'), deleteHandler)
  .post(postValidationHandler, authorization.canRequest('create:session'), postHandler)
  .handler(controller.handlerOptions);

async function deleteHandler(request, response) {
  const authenticatedUser = request.context.user;
  const sessionObject = request.context.session;

  const expiredSession = await session.expireById(sessionObject.id);
  session.clearSessionIdCookie(response);

  const secureOutputValues = authorization.filterOutput(authenticatedUser, 'read:session', expiredSession);

  return response.status(200).json(secureOutputValues);
}

function postValidationHandler(request, response, next) {
  const cleanValues = validator(request.body, {
    email: 'required',
    password: 'required',
  });

  request.body = cleanValues;

  return next();
}

async function postHandler(request, response) {
  const userTryingToCreateSession = request.context.user;
  const insecureInputValues = request.body;

  const secureInputValues = authorization.filterInput(userTryingToCreateSession, 'create:session', insecureInputValues);

  // Compress all mismatch errors (email and password) into one single error.
  let storedUser;
  try {
    storedUser = await user.findOneByEmail(secureInputValues.email);
    await authentication.comparePasswords(secureInputValues.password, storedUser.password);
  } catch (error) {
    throw new UnauthorizedError({
      message: `Dados não conferem.`,
      action: `Verifique se os dados enviados estão corretos.`,
      errorLocationCode: `CONTROLLER:SESSIONS:POST_HANDLER:DATA_MISMATCH`,
    });
  }

  if (!authorization.can(storedUser, 'create:session') && authorization.can(storedUser, 'read:activation_token')) {
    await activation.createAndSendActivationEmail(storedUser);
    throw new ForbiddenError({
      message: `O seu usuário ainda não está ativado.`,
      action: `Verifique seu email, pois acabamos de enviar um novo convite de ativação.`,
      errorLocationCode: 'CONTROLLER:SESSIONS:POST_HANDLER:USER_NOT_ACTIVATED',
    });
  }

  if (!authorization.can(storedUser, 'create:session')) {
    throw new ForbiddenError({
      message: `Você não possui permissão para fazer login.`,
      action: `Verifique se este usuário possui a feature "create:session".`,
      errorLocationCode: 'CONTROLLER:SESSIONS:POST_HANDLER:CAN_NOT_CREATE_SESSION',
    });
  }

  const sessionObject = await authentication.createSessionAndSetCookies(storedUser.id, response);

  const secureOutputValues = authorization.filterOutput(storedUser, 'create:session', sessionObject);

  return response.status(201).json(secureOutputValues);
}
</file>

<file path="pages/api/v1/sponsored-beta/index.public.js">
import { createRouter } from 'next-connect';

import ad from 'models/advertisement';
import authorization from 'models/authorization.js';
import cacheControl from 'models/cache-control';
import controller from 'models/controller.js';
import user from 'models/user.js';
import validator from 'models/validator.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(controller.logRequest)
  .get(cacheControl.swrMaxAge(10), getValidationHandler, getHandler)
  .handler(controller.handlerOptions);

function getValidationHandler(request, response, next) {
  const cleanValues = validator(request.query, {
    per_page: 'optional',
    owner_id: 'optional',
    ignore_id: 'optional',
    flexible: 'optional',
  });

  request.query = cleanValues;

  return next();
}

async function getHandler(request, response) {
  const userTryingToList = user.createAnonymous();

  const ads = await ad.getRandom(request.query.per_page, {
    ignoreId: request.query.ignore_id,
    ownerId: request.query.owner_id,
    tryOtherOwners: request.query.flexible,
  });

  const secureOutputValues = authorization.filterOutput(userTryingToList, 'read:ad:list', ads);

  return response.status(200).json(secureOutputValues);
}
</file>

<file path="pages/api/v1/status/votes/index.public.js">
import { formatISO } from 'date-fns';
import { createRouter } from 'next-connect';

import analytics from 'models/analytics';
import authentication from 'models/authentication';
import authorization from 'models/authorization';
import cacheControl from 'models/cache-control';
import controller from 'models/controller.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(authentication.injectAnonymousOrUser)
  .use(controller.logRequest)
  .use(cacheControl.noCache)
  .get(authorization.canRequest('read:votes:others'), getHandler)
  .handler(controller.handlerOptions);

async function getHandler(_, response) {
  const votesGraph = await analytics.getVotesGraph({
    limit: 1000,
    showUsernames: true,
  });

  return response.json({
    updated_at: formatISO(Date.now()),
    votesGraph,
  });
}
</file>

<file path="pages/api/v1/status/index.public.js">
import { formatISO } from 'date-fns';
import { createRouter } from 'next-connect';

import cacheControl from 'models/cache-control';
import controller from 'models/controller.js';
import health from 'models/health.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(controller.logRequest)
  .use(cacheControl.swrMaxAge(5))
  .get(getHandler)
  .handler(controller.handlerOptions);

async function getHandler(request, response) {
  let statusCode = 200;

  const checkedDependencies = await health.getDependencies();

  if (checkedDependencies.database.status === 'unhealthy') {
    statusCode = 503;
  }

  return response.status(statusCode).json({
    updated_at: formatISO(Date.now()),
    dependencies: checkedDependencies,
  });
}
</file>

<file path="pages/api/v1/user/index.public.js">
import { createRouter } from 'next-connect';

import authentication from 'models/authentication.js';
import authorization from 'models/authorization.js';
import cacheControl from 'models/cache-control';
import controller from 'models/controller.js';
import reward from 'models/reward';
import session from 'models/session';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(injectUserWithBalance)
  .use(controller.logRequest)
  .use(cacheControl.noCache)
  .get(authorization.canRequest('read:session'), renewSessionIfNecessary, getHandler)
  .handler(controller.handlerOptions);

async function getHandler(request, response) {
  const authenticatedUser = request.context.user;

  authenticatedUser.tabcoins += await reward(request);

  const secureOutputValues = authorization.filterOutput(authenticatedUser, 'read:user:self', authenticatedUser);

  return response.status(200).json(secureOutputValues);
}

async function renewSessionIfNecessary(request, response, next) {
  let sessionObject = request.context.session;

  // Renew session if it expires in less than 3 weeks.
  if (new Date(sessionObject.expires_at) < Date.now() + 1000 * 60 * 60 * 24 * 7 * 3) {
    sessionObject = await session.renew(sessionObject.id, response);

    request.context.session = sessionObject;
  }
  return next();
}

function injectUserWithBalance(request, response, next) {
  return authentication.injectAnonymousOrUser(request, response, next, {
    withBalance: true,
  });
}
</file>

<file path="pages/api/v1/users/[username]/index.public.js">
import { createRouter } from 'next-connect';

import { ForbiddenError, UnprocessableEntityError } from 'errors';
import database from 'infra/database.js';
import authentication from 'models/authentication.js';
import authorization from 'models/authorization.js';
import ban from 'models/ban.js';
import cacheControl from 'models/cache-control';
import controller from 'models/controller.js';
import event from 'models/event.js';
import user from 'models/user.js';
import validator from 'models/validator.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(controller.logRequest)
  .get(cacheControl.swrMaxAge(10), getValidationHandler, getHandler)
  .patch(
    cacheControl.noCache,
    authentication.injectAnonymousOrUser,
    patchValidationHandler,
    authorization.canRequest('update:user'),
    patchHandler,
  )
  .delete(
    cacheControl.noCache,
    authentication.injectAnonymousOrUser,
    deleteValidationHandler,
    authorization.canRequest('ban:user'),
    deleteHandler,
  )
  .handler(controller.handlerOptions);

function getValidationHandler(request, response, next) {
  const cleanValues = validator(request.query, {
    username: 'required',
  });

  request.query = cleanValues;

  return next();
}

async function getHandler(request, response) {
  const userTryingToGet = user.createAnonymous();
  const userStoredFromDatabase = await user.findOneByUsername(request.query.username, {
    withBalance: true,
  });

  const secureOutputValues = authorization.filterOutput(userTryingToGet, 'read:user', userStoredFromDatabase);

  return response.status(200).json(secureOutputValues);
}

function patchValidationHandler(request, response, next) {
  const cleanQueryValues = validator(request.query, {
    username: 'required',
  });

  request.query = cleanQueryValues;

  const cleanBodyValues = validator(request.body, {
    username: 'optional',
    email: 'optional',
    password: 'optional',
    description: 'optional',
    notifications: 'optional',
  });

  request.body = cleanBodyValues;

  return next();
}

async function patchHandler(request, response) {
  const userTryingToPatch = request.context.user;
  const targetUsername = request.query.username;
  const targetUser =
    targetUsername === userTryingToPatch.username ? userTryingToPatch : await user.findOneByUsername(targetUsername);
  const insecureInputValues = request.body;

  let updateAnotherUser = false;

  if (!authorization.can(userTryingToPatch, 'update:user', targetUser)) {
    if (!authorization.can(userTryingToPatch, 'update:user:others')) {
      throw new ForbiddenError({
        message: 'Você não possui permissão para atualizar outro usuário.',
        action: 'Verifique se você possui a feature "update:user:others".',
        errorLocationCode: 'CONTROLLER:USERS:USERNAME:PATCH:USER_CANT_UPDATE_OTHER_USER',
      });
    }

    updateAnotherUser = true;
  }

  const secureInputValues = authorization.filterInput(
    userTryingToPatch,
    updateAnotherUser ? 'update:user:others' : 'update:user',
    insecureInputValues,
    targetUser,
  );

  // TEMPORARY BEHAVIOR
  // TODO: only let user update "password"
  // once we have double confirmation.
  delete secureInputValues.password;

  const transaction = await database.transaction();

  let updatedUser;

  try {
    await transaction.query('BEGIN');

    updatedUser = await user.update(targetUser, secureInputValues, {
      transaction: transaction,
    });

    await event.create(
      {
        type: 'update:user',
        originator_user_id: request.context.user.id,
        originator_ip: request.context.clientIp,
        metadata: getEventMetadata(targetUser, updatedUser),
      },
      {
        transaction: transaction,
      },
    );

    await transaction.query('COMMIT');
  } catch (error) {
    await transaction.query('ROLLBACK');

    throw error;
  } finally {
    await transaction.release();
  }

  const secureOutputValues = authorization.filterOutput(
    userTryingToPatch,
    updateAnotherUser ? 'read:user' : 'read:user:self',
    updatedUser,
  );

  return response.status(200).json(secureOutputValues);

  function getEventMetadata(originalUser, updatedUser) {
    const metadata = {
      id: originalUser.id,
      updatedFields: [],
    };

    const updatableFields = ['description', 'notifications', 'username'];
    for (const field of updatableFields) {
      if (originalUser[field] !== updatedUser[field]) {
        metadata.updatedFields.push(field);

        if (field === 'username') {
          metadata.username = {
            old: originalUser.username,
            new: updatedUser.username,
          };
        }
      }
    }

    return metadata;
  }
}

function deleteValidationHandler(request, response, next) {
  const cleanQueryValues = validator(request.query, {
    username: 'required',
  });

  request.query = cleanQueryValues;

  const cleanBodyValues = validator(request.body, {
    ban_type: 'required',
  });

  request.body = cleanBodyValues;

  return next();
}

async function deleteHandler(request, response) {
  const userTryingToDelete = request.context.user;
  const targetUsername = request.query.username;
  const targetUser = await user.findOneByUsername(targetUsername);
  const insecureInputValues = request.body;
  const secureInputValues = authorization.filterInput(userTryingToDelete, 'ban:user', insecureInputValues);

  if (targetUser.features.includes('nuked')) {
    throw new UnprocessableEntityError({
      message: 'Este usuário já está banido permanentemente.',
      action: 'Verifique se você está tentando banir permanentemente o usuário correto.',
      errorLocationCode: 'CONTROLLER:USERS:USERNAME:DELETE:USER_ALREADY_NUKED',
    });
  }

  const transaction = await database.transaction();
  let nukedUser;

  try {
    await transaction.query('BEGIN');

    const currentEvent = await event.create(
      {
        type: 'ban:user',
        originator_user_id: request.context.user.id,
        originator_ip: request.context.clientIp,
        metadata: {
          ban_type: secureInputValues.ban_type,
          user_id: targetUser.id,
        },
      },
      {
        transaction: transaction,
      },
    );

    if (secureInputValues.ban_type === 'nuke') {
      nukedUser = await ban.nuke(targetUser.id, {
        event: currentEvent,
        transaction: transaction,
      });
    }

    await transaction.query('COMMIT');
    await transaction.release();
  } catch (error) {
    await transaction.query('ROLLBACK');
    await transaction.release();
    throw error;
  }

  const secureOutputValues = authorization.filterOutput(userTryingToDelete, 'read:user', nukedUser);

  return response.status(200).json(secureOutputValues);
}
</file>

<file path="pages/api/v1/users/index.public.js">
import { createRouter } from 'next-connect';
import { randomUUID as uuidV4 } from 'node:crypto';

import { ValidationError } from 'errors';
import activation from 'models/activation.js';
import authentication from 'models/authentication.js';
import authorization from 'models/authorization.js';
import cacheControl from 'models/cache-control';
import controller from 'models/controller.js';
import event from 'models/event.js';
import firewall from 'models/firewall';
import removeMarkdown from 'models/remove-markdown';
import user from 'models/user.js';
import validator from 'models/validator.js';

export default createRouter()
  .use(controller.injectRequestMetadata)
  .use(authentication.injectAnonymousOrUser)
  .use(controller.logRequest)
  .use(cacheControl.noCache)
  .get(getValidationHandler, authorization.canRequest('read:user:list'), getHandler)
  .post(postValidationHandler, authorization.canRequest('create:user'), firewall.canRequest('create:user'), postHandler)
  .handler(controller.handlerOptions);

function getValidationHandler(request, response, next) {
  const cleanValues = validator(request.query, {
    page: 'optional',
    per_page: 'optional',
  });

  request.query = cleanValues;

  return next();
}

async function getHandler(request, response) {
  const userTryingToList = request.context.user;

  const results = await user.findAllWithPagination({
    page: request.query.page,
    per_page: request.query.per_page,
  });

  const userList = results.rows;

  const secureOutputValues = authorization.filterOutput(userTryingToList, 'read:user:list', userList);

  for (const userObject of secureOutputValues) {
    userObject.description = removeMarkdown(userObject.description, { maxLength: 255 });
  }

  controller.injectPaginationHeaders(results.pagination, '/api/v1/users', request, response);

  return response.status(200).json(secureOutputValues);
}

function postValidationHandler(request, response, next) {
  const cleanValues = validator(request.body, {
    username: 'required',
    email: 'required',
    password: 'required',
  });

  request.body = cleanValues;

  return next();
}

async function postHandler(request, response) {
  const userTryingToCreate = request.context.user;
  const insecureInputValues = request.body;
  const secureInputValues = authorization.filterInput(userTryingToCreate, 'create:user', insecureInputValues);

  let newUser;
  try {
    newUser = await user.create(secureInputValues);

    await event.create({
      type: 'create:user',
      originator_user_id: request.context.user.id || newUser.id,
      originator_ip: request.context.clientIp,
      metadata: {
        id: newUser.id,
      },
    });

    await activation.createAndSendActivationEmail(newUser);
  } catch (error) {
    if (error instanceof ValidationError && error.key === 'email') {
      const now = new Date();
      newUser = {
        id: uuidV4(),
        username: secureInputValues.username,
        description: secureInputValues.description || '',
        features: ['read:activation_token'],
        tabcoins: 0,
        tabcash: 0,
        created_at: now,
        updated_at: now,
      };
    } else {
      throw error;
    }
  }

  const secureOutputValues = authorization.filterOutput(newUser, 'read:user', newUser);

  return response.status(201).json(secureOutputValues);
}
</file>

<file path="pages/cadastro/ativar/[token].public.js">
import { useRouter } from 'next/router';
import { useEffect, useState } from 'react';

import { Box, Confetti, DefaultLayout, Flash } from '@/TabNewsUI';
import { createErrorMessage } from 'pages/interface';

export default function ActiveUser() {
  const router = useRouter();
  const { token } = router.query;

  const [globalMessage, setGlobalMessage] = useState(false);
  const [isSuccess, setIsSuccess] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  const handleActivateUser = async (token) => {
    try {
      setIsLoading(true);

      const response = await fetch(`/api/v1/activation`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          token_id: token,
        }),
      });

      if (response.status === 200) {
        setIsSuccess(true);
        setGlobalMessage('Sua conta foi ativada com sucesso!');

        return;
      }

      if (response.status >= 400 && response.status <= 503) {
        const responseBody = await response.json();
        setGlobalMessage(createErrorMessage(responseBody));
        setIsSuccess(false);
        return;
      }

      setIsSuccess(false);
      throw new Error(response.statusText);
    } catch (error) {
      setGlobalMessage(error.message);
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    if (token) {
      handleActivateUser(token);
    }
  }, [token]);

  return (
    <>
      {isSuccess && <Confetti />}
      <DefaultLayout containerWidth="medium" metadata={{ title: 'Ativar cadastro' }}>
        <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', width: '100%', mt: 10 }}>
          {isLoading ? (
            <Flash variant="default">Verificando Token de Ativação...</Flash>
          ) : (
            <Flash variant={isSuccess ? 'success' : 'danger'}>{globalMessage}</Flash>
          )}
        </Box>
      </DefaultLayout>
    </>
  );
}
</file>

<file path="pages/cadastro/confirmar/index.public.js">
import { useEffect, useState } from 'react';

import { Box, DefaultLayout, Heading, Text } from '@/TabNewsUI';

export default function ConfirmSignup() {
  const [email, setEmail] = useState('');

  useEffect(() => {
    const userEmail = localStorage.getItem('registrationEmail');
    localStorage.removeItem('registrationEmail');
    setEmail(userEmail);
  }, []);

  return (
    <DefaultLayout containerWidth="medium" metadata={{ title: 'Confirme seu email' }}>
      <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', width: '100%', mt: 10 }}>
        <Heading as="h1">Confira seu e-mail: {email}</Heading>
        <Text>
          Caso o e-mail esteja disponível, você receberá um link para confirmar seu cadastro e ativar a sua conta.
        </Text>
      </Box>
    </DefaultLayout>
  );
}
</file>

<file path="pages/cadastro/recuperar/sucesso/index.public.js">
import { Box, DefaultLayout, Heading, Link, Text } from '@/TabNewsUI';

export default function ConfirmRecoverPassword() {
  return (
    <DefaultLayout containerWidth="medium" metadata={{ title: 'Nova senha definida com sucesso!' }}>
      <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', width: '100%', mt: 10 }}>
        <Heading as="h1">Nova senha definida com sucesso!</Heading>
        <Text>
          Agora você pode fazer o <Link href="/login">Login</Link> utilizando esta nova senha.
        </Text>
      </Box>
    </DefaultLayout>
  );
}
</file>

<file path="pages/cadastro/recuperar/[token].public.js">
import { passwordConfirmable, passwordConfirmation, useForm } from '@tabnews/forms';
import { FormField } from '@tabnews/ui';
import { useRouter } from 'next/router';

import { ButtonWithLoader, DefaultLayout, Flash, Heading } from '@/TabNewsUI';
import { createErrorMessage } from 'pages/interface';

const formConfig = {
  passwordConfirmable,
  passwordConfirmation,
  globalMessage: '',
  loading: false,
};

export default function RecoverPassword() {
  return (
    <DefaultLayout containerWidth="small" metadata={{ title: 'Recuperação de Senha' }}>
      <Heading as="h1" sx={{ mb: 3 }}>
        Defina uma nova senha
      </Heading>

      <RecoverPasswordForm />
    </DefaultLayout>
  );
}

function RecoverPasswordForm() {
  const router = useRouter();
  const { token } = router.query;
  const { getFieldProps, handleSubmit, state, updateState } = useForm(formConfig);
  const globalErrorMessage = state.globalMessage.error;

  async function onSubmit(data) {
    updateState({
      globalMessage: { error: null },
      loading: { value: true },
    });

    const password = data.passwordConfirmable;

    try {
      const response = await fetch(`/api/v1/recovery`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          token_id: token,
          password,
        }),
      });

      const responseBody = await response.json();

      if (response.status === 200) {
        router.push('/cadastro/recuperar/sucesso');
        return;
      }

      if (response.status === 400) {
        const key = responseBody.key === 'password' ? 'passwordConfirmable' : 'globalMessage';

        updateState({
          [key]: { error: createErrorMessage(responseBody) },
          loading: { value: false },
        });
        return;
      }

      updateState({
        globalMessage: { error: createErrorMessage(responseBody) },
        loading: { value: false },
      });
    } catch (error) {
      updateState({
        globalMessage: { error: 'Não foi possível se conectar ao TabNews. Por favor, verifique sua conexão.' },
        loading: { value: false },
      });
    }
  }

  return (
    <form style={{ width: '100%' }} onSubmit={handleSubmit(onSubmit)}>
      <FormField {...getFieldProps('passwordConfirmable')} />
      <FormField {...getFieldProps('passwordConfirmation')} />

      {globalErrorMessage && (
        <Flash variant="danger" sx={{ mt: 3 }}>
          {globalErrorMessage}
        </Flash>
      )}

      <ButtonWithLoader
        variant="primary"
        size="large"
        type="submit"
        sx={{ width: '100%', mt: 3 }}
        aria-label="Alterar senha"
        isLoading={state.loading.value}>
        Alterar senha
      </ButtonWithLoader>
    </form>
  );
}
</file>

<file path="pages/cadastro/recuperar/index.public.js">
import { useEffect, useRef, useState } from 'react';

import { Box, ButtonWithLoader, DefaultLayout, Flash, FormControl, Heading, TextInput } from '@/TabNewsUI';
import { createErrorMessage, useUser } from 'pages/interface';

export default function RecoverPassword() {
  return (
    <DefaultLayout containerWidth="small" metadata={{ title: 'Recuperação de senha' }}>
      <Heading as="h1" sx={{ mb: 3 }}>
        Recuperação de senha
      </Heading>

      <RecoverPasswordForm />
    </DefaultLayout>
  );
}

function RecoverPasswordForm() {
  const { user, isLoading: userIsLoading } = useUser();

  const userInputRef = useRef('');

  useEffect(() => {
    if (user && !userIsLoading) {
      userInputRef.current.value = user.email;
    }
  }, [user, userIsLoading]);

  const [globalMessageObject, setGlobalMessageObject] = useState(undefined);
  const [isLoading, setIsLoading] = useState(false);
  const [errorObject, setErrorObject] = useState(undefined);

  function clearErrors() {
    setErrorObject(undefined);
  }

  async function handleSubmit(event) {
    event.preventDefault();
    let email;
    let username;
    const userInput = userInputRef.current.value;

    if (!userInput) {
      setErrorObject({
        key: 'userInput',
        message: 'Campo obrigatório',
      });
      return;
    }

    if (userInput.includes('@')) {
      email = userInput;
    } else {
      username = userInput;
    }
    setIsLoading(true);
    setErrorObject(undefined);

    try {
      const response = await fetch(`/api/v1/recovery`, {
        method: 'POST',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email,
          username,
        }),
      });

      setGlobalMessageObject(undefined);
      const responseBody = await response.json();

      if (response.status === 201) {
        const message =
          userInput === user?.email || username
            ? `Um e-mail será enviado para "${userInput}" com um link para definir uma nova senha.`
            : `Caso o e-mail "${userInput}" esteja cadastrado, um link será enviado para definir uma nova senha.`;

        setGlobalMessageObject({
          message: message,
          type: 'success',
        });
        setIsLoading(false);
        return;
      }

      if (response.status === 400) {
        setErrorObject(responseBody);
        setIsLoading(false);
        return;
      }

      if (response.status >= 401) {
        setGlobalMessageObject({ type: 'danger', message: createErrorMessage(responseBody) });
        setIsLoading(false);
        return;
      }
    } catch (error) {
      setGlobalMessageObject({
        type: 'danger',
        message: 'Não foi possível se conectar ao TabNews. Por favor, verifique sua conexão.',
      });
      setIsLoading(false);
    }
  }

  return (
    <form style={{ width: '100%' }} onSubmit={handleSubmit}>
      <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
        {globalMessageObject && <Flash variant={globalMessageObject.type}>{globalMessageObject.message}</Flash>}

        {user?.features.includes('create:recovery_token:username') && (
          <Flash variant="default">
            Você pode ajudar outra pessoa a recuperar sua senha, é só digitar o nome de usuário dela.
          </Flash>
        )}

        {user?.features.includes('create:recovery_token:username') && (
          <FormControl id="userInput">
            <FormControl.Label>Digite seu e-mail ou o nome de usuário da pessoa que deseja ajudar</FormControl.Label>
            <TextInput
              contrast
              sx={{ px: 2, '&:focus-within': { backgroundColor: 'canvas.default' } }}
              ref={userInputRef}
              onChange={clearErrors}
              name="userInput"
              size="large"
              autoCorrect="off"
              autoCapitalize="off"
              spellCheck={false}
              block={true}
              aria-label="Digite seu e-mail ou o nome de usuário de outra pessoa"
            />
            {['userInput', 'email', 'username'].includes(errorObject?.key) && (
              <FormControl.Validation variant="error">{errorObject.message}</FormControl.Validation>
            )}

            {errorObject?.type === 'string.alphanum' && (
              <FormControl.Caption>
                Dica: use somente letras e números, por exemplo: nomeSobrenome4{' '}
              </FormControl.Caption>
            )}
          </FormControl>
        )}

        {!user?.features.includes('create:recovery_token:username') && (
          <FormControl id="userInput">
            <FormControl.Label>Digite seu e-mail</FormControl.Label>
            <TextInput
              contrast
              sx={{ px: 2, '&:focus-within': { backgroundColor: 'canvas.default' } }}
              ref={userInputRef}
              onChange={clearErrors}
              name="userInput"
              size="large"
              autoCorrect="off"
              autoCapitalize="off"
              spellCheck={false}
              block={true}
              aria-label="Seu e-mail"
            />
            {['userInput', 'email'].includes(errorObject?.key) && (
              <FormControl.Validation variant="error">{errorObject.message}</FormControl.Validation>
            )}

            {errorObject?.key === 'username' && (
              <FormControl.Validation variant="error">Insira um endereço de email válido.</FormControl.Validation>
            )}
          </FormControl>
        )}

        <FormControl>
          <FormControl.Label visuallyHidden>Recuperar</FormControl.Label>
          <ButtonWithLoader
            variant="primary"
            size="large"
            type="submit"
            sx={{ width: '100%' }}
            aria-label="Recuperar"
            isLoading={isLoading}>
            Recuperar
          </ButtonWithLoader>
        </FormControl>
      </Box>
    </form>
  );
}
</file>

<file path="pages/cadastro/index.public.js">
import { email, password, useForm, username } from '@tabnews/forms';
import { FormField, Text } from '@tabnews/ui';
import { useRouter } from 'next/router';

import { ButtonWithLoader, DefaultLayout, Flash, Heading, Link } from '@/TabNewsUI';
import { createErrorMessage } from 'pages/interface';

const formConfig = {
  username,
  email,
  password,
  termsAccepted: { checked: false },
  globalMessage: '',
  loading: false,
};

export default function Register() {
  return (
    <DefaultLayout containerWidth="small" metadata={{ title: 'Cadastro' }}>
      <Heading as="h1" sx={{ mb: 3 }}>
        Cadastro
      </Heading>

      <SignUpForm />
    </DefaultLayout>
  );
}

function SignUpForm() {
  const router = useRouter();
  const { getFieldProps, handleSubmit, state, updateState } = useForm(formConfig);
  const globalErrorMessage = state.globalMessage.error;

  async function onSubmit(data) {
    updateState({
      globalMessage: { error: null },
      loading: { value: true },
    });

    const { username, email, password } = data;

    try {
      const response = await fetch(`/api/v1/users`, {
        method: 'POST',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username: username,
          email: email,
          password: password,
        }),
      });

      const responseBody = await response.json();

      if (response.status === 201) {
        localStorage.setItem('registrationEmail', email);
        router.push('/cadastro/confirmar');
        return;
      }

      if (response.status === 400) {
        const key = ['username', 'email', 'password'].includes(responseBody.key) ? responseBody.key : 'globalMessage';

        updateState({
          [key]: { error: createErrorMessage(responseBody) },
          loading: { value: false },
        });
        return;
      }

      updateState({
        globalMessage: { error: createErrorMessage(responseBody) },
        loading: { value: false },
      });
    } catch (error) {
      updateState({
        globalMessage: { error: 'Não foi possível se conectar ao TabNews. Por favor, verifique sua conexão.' },
        loading: { value: false },
      });
    }
  }

  return (
    <form style={{ width: '100%' }} onSubmit={handleSubmit(onSubmit)}>
      <FormField {...getFieldProps('username')} name="name" autoComplete="off" />
      <FormField {...getFieldProps('email')} autoComplete="username" />
      <FormField {...getFieldProps('password')} autoComplete="new-password" />
      <FormField
        {...getFieldProps('termsAccepted')}
        sx={{ minHeight: 'auto' }}
        label={
          <Text fontSize="1">
            Li e estou de acordo com os
            <Link href="/termos-de-uso"> Termos de Uso.</Link>
          </Text>
        }
      />

      {globalErrorMessage && (
        <Flash variant="danger" sx={{ mt: 3 }}>
          {globalErrorMessage}
        </Flash>
      )}

      <ButtonWithLoader
        variant="primary"
        size="large"
        type="submit"
        sx={{ width: '100%', mt: 3 }}
        aria-label="Criar cadastro"
        disabled={!state.termsAccepted.checked}
        isLoading={state.loading.value}>
        Criar cadastro
      </ButtonWithLoader>
    </form>
  );
}
</file>

<file path="pages/contato/index.public.js">
import { Box, DefaultLayout, Heading, Viewer } from '@/TabNewsUI';

export default function Page() {
  const body = `Leia com atenção qual a melhor forma de entrar em contato:

  ## Anúncios, Publicidade e Patrocínio

  1. O TabNews é um projeto onde os anúncios são dos **próprios usuários** que criam conteúdos de valor concreto e participam ativamente do site qualificando o conteúdo de outros usuários, o que chamamos de **Fluxo completo de contribuição**.
  2. Caso você seja um anunciante, pedimos encarecidamente que não entre em contato conosco. Nosso **único interesse** é ser a plataforma onde outros usuários poderão contribuir e participar do modelo de Revenue Share (ainda não implementado).

  ## Dúvidas, sugestões e reclamações

  1. Nestes casos, pedimos que abra uma issue no [repositório do projeto](https://github.com/filipedeschamps/tabnews.com.br), pois desta forma outras pessoas poderão se beneficiar, incluindo participar adicionando novos pontos de vista ou novas dúvidas.
  2. Você também poderá criar uma [nova publicação](https://www.tabnews.com.br/publicar) no próprio TabNews para que todos possam participar.

  ## Vulnerabilidades de segurança

  1. Caso você descubra ou esbarre com alguma falha, brecha ou vulnerabilidade de segurança do serviço e encontre **informações sensíveis** (por exemplo, dados privados de outros usuários, dados sensíveis do sistema ou acesso não autorizado), pedimos que entre em contato de forma **privada** através do email \`contato@tabnews.com.br\`.
  2. Após o fechamento da falha, o TabNews se compromete em criar um **Postmortem público** com os detalhes do que aconteceu. Não temos interesse algum em esconder estes acontecimentos e queremos compartilhar todos os conhecimentos adquiridos e estratégias adotadas, mantendo em mente que iremos proteger ao máximo dados sensíveis dos usuários.
  3. Falhas que não possuem informações sensíveis e não irão prejudicar outros usuários poderão ser livremente reportados através de issues no [repositório do projeto](https://github.com/filipedeschamps/tabnews.com.br).

  ## Outros assuntos

  1. Caso você tenha algum outro assunto que não se enquadre nas categorias acima, pedimos que entre em contato através do email \`contato@tabnews.com.br\`.
  2. Em paralelo, aproveitamos para pedir que você leia os [Termos de Uso](/termos-de-uso), pois poderá esclarecer várias dúvidas suas.
  `;

  return (
    <DefaultLayout metadata={{ title: 'Contato' }}>
      <Box>
        <Heading as="h1">Contato</Heading>
        <Viewer value={body} clobberPrefix="" />
      </Box>
    </DefaultLayout>
  );
}
</file>

<file path="pages/faq/index.public.js">
import { Box, DefaultLayout, Heading, Viewer } from '@/TabNewsUI';

export default function Page() {
  const faqContent = [
    {
      id: 'tabnews',
      question: 'O que é o TabNews?',
      answer: `O TabNews é um site focado na comunidade da área de tecnologia, destinado a debates e troca de conhecimentos por meio de publicações e comentários criados pelos próprios usuários.`,
    },
    {
      id: 'proposito-tabnews',
      question: 'Qual é o propósito do TabNews?',
      answer: `O TabNews nasceu com o objetivo de ser um local com **conteúdos de valor concreto para quem trabalha com tecnologia**.

Queremos ter conteúdo de qualidade tanto na publicação principal quanto nos comentários, e algo que contribui para isso acontecer é a plataforma dar o mesmo espaço de criação para quem está publicando ambos os tipos de conteúdo. Tudo no TabNews é considerado um **conteúdo**, tanto que um comentário possui a sua própria página (basta clicar na data de publicação do comentário).`,
    },
    {
      id: 'conteudo-tabnews',
      question: 'Que tipo de conteúdo eu posso publicar no TabNews?',
      answer: `Você pode publicar notícias, artigos, tutoriais, indicações, curiosidades, sugestões de software e ferramentas, perguntas bem formuladas ou outros tipos de conteúdo, desde que o assunto da publicação seja [aceito no TabNews](#assunto-tabnews).`,
    },
    {
      id: 'assunto-tabnews',
      question: 'Que tipo de assunto é aceito no TabNews?',
      answer: `O conteúdo publicado no TabNews deve estar diretamente relacionado à tecnologia. Alguns exemplos de assuntos diretamente relacionados à tecnologia são: desenvolvimento de software, análise de dados, design, inteligência artificial, modelagem 3D, edição de vídeo, manipulação de imagens etc. Exemplos de assuntos indiretamente relacionados à tecnologia, mas que podem ser abordados do ponto de vista da tecnologia, são: produtividade, empreendedorismo, criação de conteúdo etc.`,
    },
    {
      id: 'qualidade-tabnews',
      question: 'Como criar um bom conteúdo no TabNews?',
      answer: `A forma como cada pessoa avalia a qualidade de um conteúdo é subjetiva, mas temos algumas recomendações que podem ajudar a criar uma publicação mais relevante:

- **Atenção à gramática e aos erros de digitação:** antes de publicar, confirme se precisa corrigir algum erro gramatical ou de digitação. O uso correto da língua portuguesa ajudará a transmitir a sua mensagem para os leitores.
- **Formate o conteúdo para facilitar a leitura:** o editor de texto do TabNews aceita a sintaxe Markdown, então você pode usá-la para identificar no seu texto títulos e subtítulos, trechos de código, citações, enfatizar trechos específicos, exibir diagramas etc.
- **Use imagens e fontes de apoio quando for apropriado:** nem todo conteúdo precisa de imagens ou links de referência, mas isso pode ajudar a transmitir mais credibilidade e facilitar o entendimento do seu conteúdo. Você também pode disponibilizar links para o leitor se aprofundar no assunto.
- **Transmita informações corretas:** antes de compartilhar um fato ou notícia, confirme se isso é realmente verdade. Se for algo opinativo, deixe claro que está compartilhando a sua opinião ou de um terceiro.`,
    },
    {
      id: 'tabcash',
      question: 'O que é TabCash?',
      answer: `O TabCash é uma moeda digital para recompensar pessoas que estão criando conteúdos com valor concreto e também ajudando a qualificar outros conteúdos. O saldo de TabCash pode ser utilizado no sistema de Revenue Share, onde você pode usar espaços de anúncio para compartilhar o que desejar, desde que respeite os [Termos de Uso](/termos-de-uso). Esse sistema está em desenvolvimento e você pode [acompanhar o progresso no GitHub](https://github.com/filipedeschamps/tabnews.com.br/issues/1490).`,
    },
    {
      id: 'ganhar-tabcash',
      question: 'Como ganhar TabCash?',
      answer: `Para ganhar TabCash, é necessário contribuir com a qualificação de conteúdos de outras pessoas, consumindo 2 TabCoins a cada qualificação realizada e, ao mesmo tempo, ganhando 1 TabCash.`,
    },
    {
      id: 'utilizar-tabcash',
      question: 'Como utilizar meu TabCash?',
      answer: `O TabCash pode ser utilizado para publicar o que você quiser em espaços de anúncio, desde que respeite os [Termos de Uso](/termos-de-uso).

Atualmente, o único espaço de anúncio disponível é o de [publicações patrocinadas](#publicacao-patrocinada). Para criar esse tipo de anúncio, acesse a página [Publicar novo conteúdo](/publicar) e marque a caixa de seleção "**Criar como publicação patrocinada**". Você precisa ter ao menos **100 TabCash**, que serão consumidos ao criar a publicação patrocinada.`,
    },
    {
      id: 'publicacao-patrocinada',
      question: 'Como funciona uma publicação patrocinada?',
      answer: `_Esse tipo de anúncio está em desenvolvimento, então está em constante evolução. Você pode acompanhar o que está sendo feito no [issue #1491 do GitHub](https://github.com/filipedeschamps/tabnews.com.br/issues/1491)._

No topo das listas de conteúdos [Relevantes](/) e [Recentes](/recentes/pagina/1), e também nas páginas de publicações e comentários, após o conteúdo principal, uma publicação patrocinada escolhida de forma aleatória é exibida como um _banner_. Caso a publicação tenha um link de "**fonte**", o visitante que clicar no título da publicação será redirecionado para o link. Caso o link seja para um site externo, o domínio será identificado após o título, por exemplo: \`Título da publicação patrocinada (site-externo.com.br)\`.

Para criar uma publicação patrocinada, você investirá **100 TabCash** no orçamento dela. Ainda não está definido como o orçamento será consumido e ainda não é possível alterar o valor do orçamento.

Recomendamos que o título tenha até 70 caracteres para que possa ser exibido sem reticências ao final.`,
    },
    {
      id: 'tabcoin',
      question: 'O que é TabCoin?',
      answer: `TabCoin é a moeda de troca no sistema de qualificação de conteúdos do TabNews. Você utiliza seus TabCoins para qualificar conteúdos dos outros e, por sua vez, recebe ou perde TabCoins com base nas qualificações recebidas em seus próprios conteúdos.`,
    },
    {
      id: 'ganhar-tabcoins',
      question: 'Como ganhar TabCoins?',
      answer: `As formas de ganho de TabCoins são:

- **Criando um conteúdo:** existe um algoritmo que leva em consideração os TabCoins dos seus conteúdos mais recentes para definir quantos TabCoins você ganhará ao criar um novo conteúdo.
- **Recebendo votos positivos:** quando outro usuário avalia positivamente seu conteúdo.
- **Recompensa diária:** você pode ganhar TabCoins ao acessar o TabNews pelo menos uma vez no dia. Existe um algoritmo que leva em consideração as qualificações dos seus conteúdos mais recentes e também a quantidade de TabCoins que você possui. Quanto melhor avaliados forem seus conteúdos e menos TabCoins você possuir, mais receberá na recompensa diária.`,
    },
    {
      id: 'perder-tabcoins',
      question: 'É possível perder TabCoins?',
      answer: `Sim, você pode perder TabCoins:

- **Ao apagar um conteúdo:** você perderá os TabCoins que ganhou ao criar o conteúdo, caso tenha ganhado algum TabCoin, e também perderá os TabCoins que ganhou com as avaliações positivas nessa publicação. O mesmo vale para caso um moderador apague um conteúdo seu.
- **Recebendo votos negativos:** você perderá 1 TabCoin a cada avaliação negativa recebida de outros usuários em seus conteúdos.`,
    },
    {
      id: 'utilizar-tabcoins',
      question: 'Como utilizar meus TabCoins?',
      answer: `Os TabCoins são utilizados para poder qualificar conteúdos de outros usuários e ajudar a comunidade a identificar conteúdos relevantes.

Ao avaliar uma publicação, serão consumidos 2 TabCoins e creditado 1 TabCash nos seus saldos.`,
    },
    {
      id: 'publicar-projeto-envolvido',
      question: 'Posso criar publicações divulgando projetos em que estou envolvido?',
      answer: `Sim, você pode criar uma publicação sobre um projeto que está envolvido desde que agregue valor ao leitor, por exemplo explicando detalhes técnicos do projeto, compartilhando suas experiências na criação, dificuldades e decisões tomadas.

Se você pretende fazer um pitch, ou seja, uma apresentação curta e direta com o objetivo despertar atenção das pessoas para o projeto em si, você deve colocar \`Pitch\` no título da publicação, por exemplo: \`Pitch: TabInvest — Um TabNews sobre investimentos\`. Mesmo sendo um pitch você deve contribuir com a comunidade como explicado no parágrafo anterior.

Uma divulgação de um projeto que você está envolvido deve seguir as mesmas regras de qualquer outra publicação: leia os [Termos de Uso](/termos-de-uso) e o tópico [Que tipo de conteúdo eu posso publicar no TabNews?](#publicar-tabnews). Publicações com foco exclusivo comercial são expressamente proibidas.`,
    },
    {
      id: 'publicar-mesmo-conteudo',
      question: 'Posso publicar o mesmo conteúdo várias vezes?',
      answer: `Não. Se deseja criar uma nova publicação sobre o mesmo assunto, leve em consideração há quanto tempo o conteúdo foi feito e o quão diferente será a nova publicação. Lembre-se que toda publicação está sujeita à qualificação por outros usuários através do uso de TabCoins, e casos de abuso serão tratados pela moderação. Apagar um conteúdo avaliado negativamente e republicá-lo para tentar chamar mais atenção é um exemplo de **manipulação das qualificações** e poderá resultar no banimento permanente da sua conta, como dito nos [Termos de Uso](/termos-de-uso).`,
    },
    {
      id: 'erro-nova-publicacao',
      question: 'Não consigo criar novas publicações. O que fazer?',
      answer: `Se, ao criar uma nova publicação ou comentário, você recebe uma mensagem de erro dizendo que não é possível publicar porque há outras publicações mal avaliadas que ainda não foram excluídas, revise seus conteúdos mais recentes que estão zerados ou negativados. Essa é uma proteção para o TabNews e para o usuário, impedindo a criação de muitas publicações mal recebidas e permitindo que o usuário analise o que está fazendo de errado e corrija seu comportamento.

Ao encontrar suas publicações que estão qualificadas negativamente, você poderá apagar alguma e tentar criar a publicação que deseja. O TabNews avaliará suas publicações novamente para definir se você pode ou não criar uma nova publicação. Caso receba a mesma mensagem de erro, basta realizar o processo novamente.`,
    },
    {
      id: 'como-relevantes',
      question: 'Como funciona a página "Relevantes"?',
      answer: `A página [Relevantes](/) tem como objetivo exibir as publicações recentes que foram mais relevantes para os usuários do TabNews. O algoritmo leva em consideração diferentes fatores como: há quanto tempo a publicação foi feita, quão positivamente ela foi avaliada, se a comunidade engajou por meio de comentários etc.`,
    },
    {
      id: 'sugestoes-e-bugs',
      question: 'Onde posso fazer sugestões e/ou reportar bugs?',
      answer: `Para sugestões de melhorias ou para reportar bugs que não envolvem informações sensíveis ou falhas de segurança, você pode abrir um issue no [repositório do TabNews no GitHub](https://github.com/filipedeschamps/tabnews.com.br).

Caso você descubra alguma falha, brecha ou vulnerabilidade de segurança e encontre **informações sensíveis** (por exemplo, dados privados de outros usuários, dados sensíveis do sistema ou acesso não autorizado), pedimos que [entre em contato de forma privada pelo GitHub](https://github.com/filipedeschamps/tabnews.com.br/security/advisories/new). Você pode seguir [o tutorial do GitHub](https://docs.github.com/pt/code-security/security-advisories/guidance-on-reporting-and-writing-information-about-vulnerabilities/privately-reporting-a-security-vulnerability#privately-reporting-a-security-vulnerability) sobre como fazer esse tipo de relato.

Após o fechamento da falha, o TabNews se compromete em criar um Postmortem público com os detalhes do que aconteceu. Não temos interesse algum em esconder esses acontecimentos e queremos compartilhar todos os conhecimentos adquiridos e estratégias adotadas, mantendo em mente que iremos proteger ao máximo dados sensíveis dos usuários.`,
    },
    {
      id: 'testar-tabnews',
      question: 'Como posso fazer testes no site do TabNews?',
      answer: `Testes das mais variadas formas devem ser feitos no ambiente de homologação. Você pode acessar a [lista de implantações](https://github.com/filipedeschamps/tabnews.com.br/deployments/activity_log?environment=Preview) e clicar em algum link da seção \`Active deployments\` para acessar o ambiente. Por ser um ambiente diferente, você precisará criar uma nova conta e confirmar o e-mail.      `,
    },
    {
      id: 'contribuir-tabnews',
      question: 'Como posso contribuir com o TabNews?',
      answer: `Existem diferentes formas de participação que contribuem para a evolução do TabNews:

- **Criação de conteúdo:** você pode criar publicações ou comentários com conteúdo de valor para outros leitores.
- **Qualificação de conteúdo:** você pode usar seus TabCoins para qualificar as publicações e comentários. Ao qualificar positivamente, você reforça que aquele tipo de conteúdo é relevante e desejado no TabNews. Ao qualificar negativamente, você demonstra que aquele conteúdo não é relevante ou possui algum problema.
- **Participação no repositório:** as sugestões de melhorias e reportes de bugs são realizados no [repositório do TabNews no GitHub](https://github.com/filipedeschamps/tabnews.com.br). Você pode contribuir com detalhes para a resolução de algum problema ou com ideias de implementação de algum recurso.
- **Modificações no código:** como o TabNews é um projeto de código aberto, além de sugerir melhorias e reportar bugs, você também pode contribuir com o código do projeto. Leia o [guia de contribuição](https://github.com/filipedeschamps/tabnews.com.br/blob/main/CONTRIBUTING.md) do projeto para mais detalhes.`,
    },
  ];

  const tableOfContents = faqContent.map((faq) => `- [${faq.question}](#${faq.id})`).join('\n');

  const faqMarkdown = faqContent
    .map(({ id, question, answer }) => `<h2 id="${id}">${question}</h2>\n\n${answer}`)
    .join('\n');

  const content = `${tableOfContents}\n\n${faqMarkdown}`;

  return (
    <DefaultLayout metadata={{ title: 'FAQ - Perguntas frequentes' }}>
      <Box sx={{ width: '100%' }}>
        <Heading as="h1">FAQ - Perguntas Frequentes</Heading>
        <Viewer areLinksTrusted value={content} clobberPrefix="" />
      </Box>
    </DefaultLayout>
  );
}
</file>

<file path="pages/interface/components/AdBanner/index.js">
import { getDomain, isExternalLink, isTrustedDomain, truncate } from '@tabnews/helpers';
import { useRouter } from 'next/router';
import { useEffect, useState } from 'react';

import { Box, Link, SkeletonLoader, Text, Tooltip } from '@/TabNewsUI';
import { LinkExternalIcon } from '@/TabNewsUI/icons';

export default function AdBanner({ ad: newAd, isLoading, ...props }) {
  const [ad, setAd] = useState(newAd);
  const router = useRouter();

  useEffect(() => {
    if (newAd && !ad) {
      setAd(newAd);
    }
  }, [router.asPath, newAd, ad]);

  if (isLoading || (newAd && !ad)) {
    return <AdBannerLoading />;
  }

  if (!ad) {
    return null;
  }

  const link = ad.source_url || `/${ad.owner_username}/${ad.slug}`;
  const isAdToExternalLink = isExternalLink(link);
  const domain = isAdToExternalLink ? `(${getDomain(link)})` : '';
  const title = truncate(ad.title, 70);

  return (
    <Box {...props} as="aside" sx={{ display: 'grid', ...props.sx }}>
      <Box>
        <Link
          sx={{
            overflow: 'auto',
            fontWeight: 'semibold',
            wordWrap: 'break-word',
            ':link': {
              color: 'success.fg',
            },
            ':visited': {
              color: 'success.fg',
            },
          }}
          href={link}
          rel={isTrustedDomain(link) ? undefined : 'nofollow'}>
          <Text sx={{ wordBreak: 'break-word', marginRight: 1 }}>
            {title} {domain}
          </Text>
          {isAdToExternalLink && <LinkExternalIcon verticalAlign="middle" />}
        </Link>
      </Box>

      <Text sx={{ whiteSpace: 'nowrap', overflow: 'hidden', fontSize: 0, color: 'neutral.emphasis' }}>
        Contribuindo com{' '}
        <Tooltip text={`Autor: ${ad.owner_username}`} direction="nw" sx={{ position: 'absolute', display: 'grid' }}>
          <Link
            sx={{ overflow: 'hidden', textOverflow: 'ellipsis', color: 'neutral.emphasis', mr: 2 }}
            href={`/${ad.owner_username}`}>
            {ad.owner_username}
          </Link>
        </Tooltip>
      </Text>
    </Box>
  );
}

function AdBannerLoading() {
  const spaceBetweenRows = 8;
  const titleHeight = 16;
  const titleY = 2;

  return (
    <SkeletonLoader
      title="Carregando publicação patrocinada..."
      style={{ height: '2.3rem', width: '100%' }}
      uniqueKey="ad-loading">
      <rect x="28" y={titleY} rx="5" ry="5" width="600" height={titleHeight} />
      <rect x="28" y={titleY + spaceBetweenRows + titleHeight} rx="5" ry="5" width="180" height="12" />
    </SkeletonLoader>
  );
}
</file>

<file path="pages/interface/components/Analytics/index.js">
import Script from 'next/script';

export default function Analytics() {
  return (
    <Script
      id="umami-script"
      src={process.env.NEXT_PUBLIC_UMAMI_ENDPOINT + '/script.js'}
      data-website-id={process.env.NEXT_PUBLIC_UMAMI_WEBSITE_ID}
      data-exclude-search="true"
      strategy="lazyOnload"
    />
  );
}
</file>

<file path="pages/interface/components/ButtonWithLoader/index.js">
import { Box, Button, Spinner } from '@/TabNewsUI';

function SpinnerWrapper({ children, isLoading }) {
  const scaleValue = isLoading ? 1 : 0;
  const transformValue = isLoading ? 'translateX(0)' : 'translateX(-12px)';

  return (
    <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
      <Box
        sx={{
          display: 'flex',
          marginRight: '8px',
          transform: `scale(${scaleValue})`,
          transition: 'all 500ms ease',
        }}>
        <Spinner size="small" />
      </Box>
      <Box sx={{ transform: transformValue, transition: 'transform 500ms ease' }}>{children}</Box>
    </Box>
  );
}

export default function ButtonWithLoader({ children, disabled, isLoading, ...props }) {
  return (
    <Button {...props} disabled={isLoading || disabled}>
      <SpinnerWrapper isLoading={isLoading}>{children}</SpinnerWrapper>
    </Button>
  );
}
</file>

<file path="pages/interface/components/CharacterCount/index.js">
import { Text } from '@tabnews/ui';

export default function CharacterCount({ maxLength, value }) {
  return (
    <Text
      sx={{
        ml: 'auto',
        fontSize: 0,
        pl: 1,
        color: value.length > maxLength ? 'danger.fg' : undefined,
        fontWeight: value.length > maxLength ? 'bold' : undefined,
      }}>
      {value.length}/{maxLength}
    </Text>
  );
}
</file>

<file path="pages/interface/components/Charts/index.js">
import { Bar, BarChart as RechartsBarChart, ResponsiveContainer, Tooltip, XAxis } from 'recharts';

import { Box, useTheme } from '@/TabNewsUI';

export function BarChart({ title, data, yDataKey, name, fill = '#2da44e', xDataKey = 'date' }) {
  const { theme } = useTheme();
  const { colors } = theme;

  return (
    <Box>
      <h2>{title}</h2>
      <Box width="100%" height="140px">
        <ResponsiveContainer>
          <RechartsBarChart height={400} data={data}>
            <XAxis dataKey={xDataKey} tick={{ fontSize: 10 }} />
            <Tooltip contentStyle={{ backgroundColor: colors.canvas.default }} />
            <Bar type="monotone" dataKey={yDataKey} name={name} fill={fill} />
          </RechartsBarChart>
        </ResponsiveContainer>
      </Box>
    </Box>
  );
}
</file>

<file path="pages/interface/components/Confetti/index.js">
import { useEffect, useState } from 'react';
import ReactConfetti from 'react-confetti';

export default function Confetti({
  width = 0,
  height = 0,
  recycle = false,
  numberOfPieces = 800,
  tweenDuration = 15000,
  gravity = 0.15,
  ...props
}) {
  const [confettiWidth, setConfettiWidth] = useState(width);
  const [confettiHeight, setConfettiHeight] = useState(height);

  useEffect(() => {
    function handleResize() {
      setConfettiWidth(document.body.clientWidth);
      setConfettiHeight(window.innerHeight);
    }

    window.addEventListener('resize', handleResize);
    handleResize();

    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return (
    <ReactConfetti
      width={confettiWidth}
      height={confettiHeight}
      recycle={recycle}
      numberOfPieces={numberOfPieces}
      tweenDuration={tweenDuration}
      gravity={gravity}
      {...props}
    />
  );
}
</file>

<file path="pages/interface/components/Content/index.js">
import { isTrustedDomain } from '@tabnews/helpers';
import { useRouter } from 'next/router';
import { useCallback, useEffect, useMemo, useState } from 'react';

import {
  ActionList,
  ActionMenu,
  Box,
  BranchName,
  Button,
  ButtonWithLoader,
  CharacterCount,
  Checkbox,
  Editor,
  Flash,
  FormControl,
  Heading,
  IconButton,
  Label,
  LabelGroup,
  Link,
  PastTime,
  ReadTime,
  Text,
  TextInput,
  Tooltip,
  useConfirm,
  Viewer,
} from '@/TabNewsUI';
import { KebabHorizontalIcon, LinkIcon, PencilIcon, ShareIcon, TrashIcon } from '@/TabNewsUI/icons';
import webserver from 'infra/webserver';
import { createErrorMessage, isValidJsonString, processNdJsonStream, useUser } from 'pages/interface';

const CONTENT_TITLE_PLACEHOLDER_EXAMPLES = [
  'e.g. Nova versão do Python é anunciada com melhorias de desempenho',
  'e.g. Desafios ao empreender como desenvolvedor',
  'e.g. Como funciona o conceito de ownership em Rust',
  'e.g. 5 livros fundamentais para desenvolvedores',
  'e.g. Como os jogos de Atari eram desenvolvidos',
  'e.g. Ferramentas para melhorar sua produtividade',
  'e.g. Como renomear uma branch local no Git?',
];

const BODY_MAX_LENGTH = 20_000;

export default function Content({ content, isPageRootOwner, mode = 'view', rootContent, viewFrame = false }) {
  const [componentMode, setComponentMode] = useState(mode);
  const [contentObject, setContentObject] = useState(content);
  const { user } = useUser();

  useEffect(() => {
    setComponentMode(mode);
  }, [mode]);

  useEffect(() => {
    setContentObject((contentObject) => {
      return { ...contentObject, ...content };
    });
  }, [content]);

  const localStorageKey = useMemo(() => {
    if (contentObject?.id) {
      return `content-edit-${contentObject.id}`;
    } else if (contentObject?.parent_id) {
      return `content-new-parent-${contentObject.parent_id}`;
    } else {
      return `content-new`;
    }
  }, [contentObject]);

  useEffect(() => {
    if (user && contentObject?.owner_id === user.id) {
      const localStorageContent = localStorage.getItem(localStorageKey);
      if (isValidJsonString(localStorageContent)) {
        setComponentMode('edit');
      }
    }
  }, [localStorageKey, user, contentObject]);

  if (componentMode === 'view') {
    return (
      <ViewMode
        setComponentMode={setComponentMode}
        contentObject={contentObject}
        isPageRootOwner={isPageRootOwner}
        viewFrame={viewFrame}
      />
    );
  } else if (componentMode === 'compact') {
    return <CompactMode setComponentMode={setComponentMode} contentObject={contentObject} rootContent={rootContent} />;
  } else if (componentMode === 'edit') {
    return (
      <EditMode
        contentObject={contentObject}
        setComponentMode={setComponentMode}
        setContentObject={setContentObject}
        localStorageKey={localStorageKey}
      />
    );
  } else if (componentMode === 'deleted') {
    return <DeletedMode viewFrame={viewFrame} />;
  }
}

function ViewModeOptionsMenu({ onDelete, onComponentModeChange }) {
  return (
    <Box sx={{ position: 'relative', minWidth: '28px' }}>
      <Box sx={{ position: 'absolute', right: 0 }}>
        {/* I've wrapped ActionMenu with this additional divs, to stop content from vertically
        flickering after this menu appears, because without `position: absolute` it increases the row height */}
        <ActionMenu>
          <ActionMenu.Anchor>
            <IconButton size="small" icon={KebabHorizontalIcon} aria-label="Editar conteúdo" />
          </ActionMenu.Anchor>

          <ActionMenu.Overlay>
            <ActionList>
              <ActionList.Item onSelect={() => onComponentModeChange('edit')}>
                <ActionList.LeadingVisual>
                  <PencilIcon />
                </ActionList.LeadingVisual>
                Editar
              </ActionList.Item>
              <ActionList.Item variant="danger" onSelect={onDelete}>
                <ActionList.LeadingVisual>
                  <TrashIcon />
                </ActionList.LeadingVisual>
                Apagar
              </ActionList.Item>
            </ActionList>
          </ActionMenu.Overlay>
        </ActionMenu>
      </Box>
    </Box>
  );
}

function ViewMode({ setComponentMode, contentObject, isPageRootOwner, viewFrame }) {
  const { user, fetchUser } = useUser();
  const [globalErrorMessage, setGlobalErrorMessage] = useState(null);
  const confirm = useConfirm();

  const handleClickDelete = async () => {
    const confirmDelete = await confirm({
      title: 'Você tem certeza?',
      content: 'Deseja realmente apagar essa publicação?',
      cancelButtonContent: 'Cancelar',
      confirmButtonContent: 'Sim',
    });

    if (!confirmDelete) return;

    const data = {
      status: 'deleted',
    };

    const response = await fetch(`/api/v1/contents/${contentObject.owner_username}/${contentObject.slug}`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });

    const responseBody = await response.json();

    fetchUser();

    if (response.status === 200) {
      setComponentMode('deleted');
    } else {
      setGlobalErrorMessage({ error: responseBody });
    }
  };

  const isOptionsMenuVisible = user?.id === contentObject.owner_id || user?.features?.includes('update:content:others');

  return (
    <Box
      as="article"
      id={`${contentObject.owner_username}-${contentObject.slug}`}
      sx={{
        display: 'flex',
        flexDirection: 'column',
        gap: 1,
        width: '100%',
        borderWidth: viewFrame ? 1 : 0,
        p: viewFrame ? 4 : 0,
        borderRadius: '6px',
        borderColor: 'border.default',
        borderStyle: 'solid',
        wordBreak: 'break-word',
      }}>
      <Box>
        {globalErrorMessage && <ErrorMessage {...globalErrorMessage} sx={{ mb: 4 }} />}

        <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
          <Box
            sx={{
              display: 'flex',
              flexWrap: 'wrap',
              alignItems: 'center',
              whiteSpace: 'nowrap',
              gap: 1,
              color: 'fg.muted',
            }}>
            <BranchName as="address" sx={{ fontStyle: 'normal', pt: 1 }}>
              <Link href={`/${contentObject.owner_username}`}>{contentObject.owner_username}</Link>
            </BranchName>
            <LabelGroup>
              {isPageRootOwner && (
                <Tooltip text="Autor do conteúdo principal da página" direction="n" sx={{ position: 'absolute' }}>
                  <Label>Autor</Label>
                </Tooltip>
              )}
              {contentObject.type === 'ad' && (
                <Tooltip text="Patrocinado com TabCash" direction="n" sx={{ position: 'absolute' }}>
                  <Label variant="success">Patrocinado</Label>
                </Tooltip>
              )}
            </LabelGroup>
            {!contentObject.parent_id && (
              <>
                <ReadTime text={contentObject.body} />
                {' · '}
              </>
            )}
            <Link
              href={`/${contentObject.owner_username}/${contentObject.slug}`}
              prefetch={false}
              sx={{ fontSize: 0, color: 'fg.muted' }}>
              <PastTime direction="n" date={contentObject.published_at} sx={{ position: 'absolute' }} />
            </Link>
          </Box>
          {isOptionsMenuVisible && (
            <ViewModeOptionsMenu onComponentModeChange={setComponentMode} onDelete={handleClickDelete} />
          )}
        </Box>

        {!contentObject.parent_id && contentObject.title && (
          <Heading sx={{ overflow: 'auto', wordWrap: 'break-word' }} as="h1">
            {contentObject.title}
          </Heading>
        )}
      </Box>
      <Box sx={{ overflow: 'hidden' }}>
        <Viewer value={contentObject.body} clobberPrefix={`${contentObject.owner_username}-content-`} />
      </Box>
      {contentObject.source_url && (
        <Box>
          <Text as="p" fontWeight="bold" sx={{ wordBreak: 'break-all' }}>
            <LinkIcon size={16} /> Fonte:{' '}
            <Link
              href={contentObject.source_url}
              rel={isTrustedDomain(contentObject.source_url) ? undefined : 'nofollow'}>
              {contentObject.source_url}
            </Link>
          </Text>
        </Box>
      )}
    </Box>
  );
}

function EditMode({ contentObject, setContentObject, setComponentMode, localStorageKey }) {
  const { user, fetchUser } = useUser();
  const router = useRouter();
  const [globalErrorMessage, setGlobalErrorMessage] = useState(false);
  const [isPosting, setIsPosting] = useState(false);
  const [errorObject, setErrorObject] = useState(undefined);
  const [newData, setNewData] = useState({
    title: contentObject?.title || '',
    body: contentObject?.body || '',
    source_url: contentObject?.source_url || '',
    isSponsoredContent: contentObject?.type === 'ad',
  });
  const [titlePlaceholder, setTitlePlaceholder] = useState('');

  const confirm = useConfirm();

  useEffect(() => {
    const loadLocalStorage = (oldData) => {
      const data = localStorage.getItem(localStorageKey);

      if (!isValidJsonString(data)) {
        localStorage.removeItem(localStorageKey);
        return oldData;
      }

      return JSON.parse(data);
    };

    setNewData((data) => loadLocalStorage(data));

    function onFocus() {
      setNewData((oldData) => loadLocalStorage(oldData));
    }

    addEventListener('focus', onFocus);
    return () => removeEventListener('focus', onFocus);
  }, [localStorageKey]);

  useEffect(() => {
    setTitlePlaceholder(randomTitlePlaceholder());
  }, []);

  const handleSubmit = useCallback(
    async (event) => {
      event.preventDefault();
      if (!user) {
        router.push(`/login?redirect=${router.asPath}`);
        return;
      }

      const confirmBodyValue =
        newData.body.split(/[a-z]{5,}/i, 6).length < 6
          ? await confirm({
              title: 'Tem certeza que deseja publicar essa mensagem curta?',
              content: (
                <Flash variant="warning">
                  ⚠ Atenção: Pedimos encarecidamente que{' '}
                  <Link href="https://www.tabnews.com.br/filipedeschamps/tentando-construir-um-pedaco-de-internet-mais-massa">
                    leia isso antes
                  </Link>{' '}
                  de fazer essa publicação.
                </Flash>
              ),
              cancelButtonContent: 'Cancelar',
              confirmButtonContent: 'Publicar',
              confirmButtonType: 'danger',
            })
          : true;

      if (!confirmBodyValue) return;

      setIsPosting(true);
      setErrorObject(undefined);

      const title = newData.title;
      const body = newData.body;
      const sourceUrl = newData.source_url;

      const requestMethod = contentObject?.id ? 'PATCH' : 'POST';
      const requestUrl = contentObject?.id
        ? `/api/v1/contents/${contentObject.owner_username}/${contentObject.slug}`
        : `/api/v1/contents`;
      const requestBody = {
        status: 'published',
        type: newData.isSponsoredContent ? 'ad' : 'content',
      };

      if (title || contentObject?.title) {
        requestBody.title = title;
      }

      if (body || contentObject?.body) {
        requestBody.body = body;
      }

      if (sourceUrl || contentObject?.source_url) {
        requestBody.source_url = sourceUrl || null;
      }

      if (contentObject?.parent_id) {
        requestBody.parent_id = contentObject.parent_id;
      }

      fetch(requestUrl, {
        method: requestMethod,
        headers: {
          Accept: 'application/json, application/x-ndjson',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody),
      })
        .then(processResponse)
        .catch(() => {
          setGlobalErrorMessage({
            error: { message: 'Não foi possível se conectar ao TabNews. Por favor, verifique sua conexão.' },
          });
          setIsPosting(false);
        });

      function processResponse(response) {
        setGlobalErrorMessage(undefined);
        fetchUser();

        if (response.ok) {
          localStorage.removeItem(localStorageKey);
        } else {
          setIsPosting(false);
        }

        processNdJsonStream(response.body, getResponseBodyCallback(response));
      }

      function getResponseBodyCallback(response) {
        if (response.status === 200) {
          return (responseBody) => {
            setContentObject(responseBody);
            setComponentMode('view');
          };
        }

        if (response.status === 201) {
          return (responseBody) => {
            if (responseBody.message) {
              setGlobalErrorMessage({ error: responseBody });
              console.error(responseBody);
              return;
            }

            if (!responseBody.parent_id) {
              localStorage.setItem('justPublishedNewRootContent', true);
              router.push(`/${responseBody.owner_username}/${responseBody.slug}`);
              return;
            }

            setContentObject(responseBody);
            setComponentMode('view');
          };
        }

        if (response.status === 400) {
          return (responseBody) => {
            setErrorObject(responseBody);

            if (responseBody.key === 'slug') {
              setGlobalErrorMessage({ error: responseBody, omitErrorId: true });
            }
          };
        }

        if (response.status >= 401) {
          return (responseBody) => {
            setGlobalErrorMessage({ error: responseBody });
          };
        }
      }
    },
    [confirm, contentObject, localStorageKey, newData, router, setComponentMode, setContentObject, user, fetchUser],
  );

  const handleChange = useCallback(
    (event) => {
      setErrorObject(undefined);
      setNewData((oldData) => {
        const value =
          event.target?.name === 'isSponsoredContent' ? event.target.checked : (event.target?.value ?? event);
        const newData = { ...oldData, [event.target?.name || 'body']: value };
        localStorage.setItem(localStorageKey, JSON.stringify(newData));
        return newData;
      });
    },
    [localStorageKey],
  );

  const handleCancel = useCallback(async () => {
    const confirmCancel =
      newData.title || newData.body || newData.source_url
        ? await confirm({
            title: 'Tem certeza que deseja sair da edição?',
            content: 'Os dados não salvos serão perdidos.',
            cancelButtonContent: 'Cancelar',
            confirmButtonContent: 'Sim',
          })
        : true;

    if (!confirmCancel) return;

    setErrorObject(undefined);
    localStorage.removeItem(localStorageKey);
    const isPublished = contentObject?.status === 'published';
    const isChild = !!contentObject?.parent_id;
    if (isPublished) {
      setComponentMode('view');
    } else if (isChild) {
      setComponentMode('compact');
    } else if (router) {
      router.push('/');
    }
  }, [confirm, contentObject, localStorageKey, newData, router, setComponentMode]);

  const onKeyDown = useCallback(
    (event) => {
      if (isPosting) return;
      if (event.key === 'Enter' && (event.ctrlKey || event.metaKey)) {
        handleSubmit(event);
      } else if (event.key === 'Escape') {
        handleCancel();
      }
    },
    [handleCancel, handleSubmit, isPosting],
  );

  return (
    <Box sx={{ mb: 4, width: '100%' }}>
      <form onSubmit={handleSubmit} style={{ width: '100%' }} noValidate>
        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
          {globalErrorMessage && <ErrorMessage {...globalErrorMessage} />}

          {!contentObject?.parent_id && (
            <FormControl id="title" required>
              <FormControl.Label>Título</FormControl.Label>
              <TextInput
                contrast
                sx={{ px: 2, '&:focus-within': { backgroundColor: 'canvas.default' } }}
                onChange={handleChange}
                onKeyDown={onKeyDown}
                name="title"
                size="large"
                autoCorrect="off"
                autoCapitalize="sentences"
                spellCheck={true}
                placeholder={titlePlaceholder}
                autoFocus={true}
                block={true}
                value={newData.title}
              />

              {errorObject?.key === 'title' && (
                <FormControl.Validation variant="error">{errorObject.message}</FormControl.Validation>
              )}
            </FormControl>
          )}

          <FormControl id="body" required={!contentObject?.parent_id}>
            <FormControl.Label>{contentObject?.parent_id ? 'Seu comentário' : 'Corpo da publicação'}</FormControl.Label>
            <Editor
              isInvalid={errorObject?.key === 'body' || newData.body.length > BODY_MAX_LENGTH}
              value={newData.body}
              onChange={handleChange}
              onKeyDown={onKeyDown}
              initialHeight={!contentObject?.parent_id ? 'calc(100vh - 410px)' : undefined}
              clobberPrefix={`${contentObject?.owner_username ?? user?.username}-content-`}
            />

            <Box sx={{ display: 'flex', width: '100%' }}>
              {errorObject?.key === 'body' && (
                <FormControl.Validation variant="error">{errorObject.message}</FormControl.Validation>
              )}

              <CharacterCount maxLength={BODY_MAX_LENGTH} value={newData.body} />
            </Box>
          </FormControl>

          {!contentObject?.parent_id && (
            <FormControl id="source_url">
              <FormControl.Label>Fonte</FormControl.Label>
              <TextInput
                contrast
                sx={{ px: 2, '&:focus-within': { backgroundColor: 'canvas.default' } }}
                onChange={handleChange}
                onKeyDown={onKeyDown}
                name="source_url"
                size="large"
                autoCorrect="off"
                autoCapitalize="off"
                spellCheck={false}
                placeholder="https://origem.site/noticia"
                block={true}
                value={newData.source_url}
              />

              {errorObject?.key === 'source_url' && (
                <FormControl.Validation variant="error">{errorObject.message}</FormControl.Validation>
              )}
            </FormControl>
          )}

          {!contentObject?.id && !contentObject?.parent_id && (
            <FormControl>
              <Checkbox name="isSponsoredContent" onChange={handleChange} checked={newData.isSponsoredContent} />
              <FormControl.Label>
                Criar como publicação patrocinada. <Link href="/faq#publicacao-patrocinada">Saiba mais.</Link>
              </FormControl.Label>

              <FormControl.Caption>
                Serão consumidos 100 TabCash para criar a publicação patrocinada.
              </FormControl.Caption>
            </FormControl>
          )}

          {!contentObject?.parent_id && (
            <Text sx={{ fontSize: 1 }}>Os campos marcados com um asterisco (*) são obrigatórios.</Text>
          )}

          <Box sx={{ display: 'flex', justifyContent: 'flex-end', alignItems: 'center' }}>
            {contentObject && (
              <Button
                variant="invisible"
                type="button"
                disabled={isPosting}
                sx={{ marginRight: 3, fontSize: 1, fontWeight: 'normal', cursor: 'pointer', color: 'fg.muted' }}
                aria-label="Cancelar alteração"
                onClick={handleCancel}>
                Cancelar
              </Button>
            )}
            <ButtonWithLoader
              variant="primary"
              type="submit"
              aria-label={isPosting ? 'Carregando...' : contentObject?.id ? 'Atualizar' : 'Publicar'}
              isLoading={isPosting}>
              {contentObject?.id ? 'Atualizar' : 'Publicar'}
            </ButtonWithLoader>
          </Box>
        </Box>
      </form>
    </Box>
  );
}

function CompactMode({ contentObject, rootContent, setComponentMode }) {
  const [isLinkCopied, setCopied] = useState(false);
  const router = useRouter();
  const { user, isLoading } = useUser();
  const confirm = useConfirm();

  const isRootContent = rootContent.id === contentObject.parent_id;

  const handleClick = useCallback(async () => {
    if (user && !isLoading) {
      const confirmReply =
        contentObject?.owner_id === user.id
          ? await confirm({
              title: 'Você deseja responder ao seu próprio conteúdo?',
              content:
                'Ao responder à sua própria publicação, você não acumulará TabCoins. É recomendado editar o conteúdo existente caso precise complementar informações.',
              cancelButtonContent: 'Cancelar',
              confirmButtonContent: 'Responder',
              confirmButtonType: 'danger',
            })
          : true;

      if (!confirmReply) return;

      setComponentMode('edit');
    } else if (router) {
      router.push(`/login?redirect=${router.asPath}`);
    }
  }, [confirm, contentObject, isLoading, router, setComponentMode, user]);

  const handleShare = async () => {
    const title =
      isRootContent && rootContent.title
        ? rootContent.title
        : rootContent.title
          ? `Comentário de "${contentObject.owner_username}" em "${rootContent.title}"`
          : `Conteúdo de "${contentObject.owner_username}"`;
    const url = `${webserver.host}/${contentObject.owner_username}/${contentObject.slug}`;

    try {
      await navigator.share({ title, url });
    } catch {
      try {
        await navigator.clipboard.writeText(url);
        setCopied(true);
        setTimeout(() => setCopied(false), 2000);
      } catch {
        alert('Não foi possível copiar o link. Verifique as permissões e se o navegador suporta a funcionalidade.');
      }
    }
  };

  return (
    <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap' }}>
      <Tooltip text={`Responder para ${contentObject.owner_username}`} direction="n" sx={{ position: 'absolute' }}>
        <Button onClick={handleClick}>Responder</Button>
      </Tooltip>
      <Tooltip
        text={`Compartilhar ${isRootContent ? 'publicação' : 'comentário'}`}
        direction="n"
        sx={{ position: 'absolute' }}>
        <Button onClick={handleShare}>
          {isLinkCopied ? <Text sx={{ color: 'fg.muted' }}>Link copiado!</Text> : <ShareIcon size={16} />}
        </Button>
      </Tooltip>
    </Box>
  );
}

function DeletedMode({ viewFrame }) {
  return (
    <Box
      sx={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        gap: 2,
        width: '100%',
        borderWidth: viewFrame ? 1 : 0,
        p: viewFrame ? 2 : 0,
        borderRadius: '6px',
        borderColor: 'border.default',
        borderStyle: 'solid',
      }}>
      <Box sx={{ color: 'fg.muted', textAlign: 'center' }}>Conteúdo excluído</Box>
    </Box>
  );
}

function ErrorMessage({ error, omitErrorId, ...props }) {
  const isErrorWithReadMore =
    error.error_location_code === 'MODEL:CONTENT:CREDIT_OR_DEBIT_TABCOINS:NEGATIVE_USER_EARNINGS';

  return (
    <Flash variant="danger" {...props}>
      {createErrorMessage(error, { omitErrorId: omitErrorId || isErrorWithReadMore })}

      {isErrorWithReadMore && (
        <Text sx={{ display: 'block', mt: 1 }}>
          Para mais informações, leia:{' '}
          <Link href="/faq#erro-nova-publicacao">Não consigo criar novas publicações. O que fazer?</Link>
        </Text>
      )}
    </Flash>
  );
}

function randomTitlePlaceholder() {
  return CONTENT_TITLE_PLACEHOLDER_EXAMPLES[Math.floor(Math.random() * CONTENT_TITLE_PLACEHOLDER_EXAMPLES.length)];
}
</file>

<file path="pages/interface/components/ContentList/index.js">
import {
  AdBanner,
  Box,
  EmptyState,
  Link,
  Pagination,
  PastTime,
  TabCoinBalanceTooltip,
  Text,
  Tooltip,
} from '@/TabNewsUI';
import { CommentIcon } from '@/TabNewsUI/icons';

export default function ContentList({ ad, contentList: list, pagination, paginationBasePath, emptyStateProps }) {
  const listNumberStart = pagination.perPage * (pagination.currentPage - 1) + 1;

  return (
    <>
      {list.length > 0 ? (
        <Box
          as="ol"
          sx={{
            display: 'grid',
            gap: '0.5rem',
            gridTemplateColumns: 'min-content minmax(0, 1fr)',
            padding: 0,
            margin: 0,
          }}
          key={`content-list-${listNumberStart}`}
          start={listNumberStart}>
          {ad && (
            <Box as="li" sx={{ display: 'block', gridColumnStart: 2, '::marker': 'none' }}>
              <AdBanner ad={ad} />
            </Box>
          )}

          <RenderItems />

          <EndOfRelevant pagination={pagination} paginationBasePath={paginationBasePath} />
        </Box>
      ) : (
        <EmptyState title="Nenhum conteúdo encontrado" {...emptyStateProps} />
      )}

      {list.length > 0 ? <Pagination {...pagination} basePath={paginationBasePath} /> : null}
    </>
  );

  function RenderItems() {
    function ChildrenDeepCountText({ count }) {
      return count > 1 ? `${count} comentários` : `${count} comentário`;
    }

    function TabCoinsText({ count }) {
      return count > 1 || count < -1 ? `${count} tabcoins` : `${count} tabcoin`;
    }

    return list.map((contentObject) => {
      return (
        <Box
          key={contentObject.id}
          as="li"
          sx={{
            display: 'contents',
            ':before': {
              content: 'counter(list-item) "."',
              counterIncrement: 'list-item',
              fontWeight: 'semibold',
              width: 'min-content',
              marginLeft: 'auto',
            },
          }}>
          <Box as="article">
            <Box
              sx={{
                overflow: 'auto',
                fontWeight: 'semibold',
                fontSize: 2,
                '> a': {
                  ':link': {
                    color: 'fg.default',
                  },
                  ':visited': {
                    color: 'fg.subtle',
                  },
                },
              }}>
              {contentObject.parent_id ? (
                <Link
                  sx={{ wordWrap: 'break-word', fontStyle: 'italic', fontWeight: 'normal' }}
                  href={`/${contentObject.owner_username}/${contentObject.slug}`}>
                  <CommentIcon verticalAlign="middle" size="small" />
                  {` "${contentObject.body}"`}
                </Link>
              ) : (
                <Link sx={{ wordWrap: 'break-word' }} href={`/${contentObject.owner_username}/${contentObject.slug}`}>
                  {contentObject.title}
                </Link>
              )}
            </Box>
            <Box
              sx={{
                display: 'grid',
                gap: 1,
                gridTemplateColumns:
                  'max-content max-content max-content max-content minmax(20px, max-content) max-content max-content',
                fontSize: 0,
                whiteSpace: 'nowrap',
                color: 'neutral.emphasis',
              }}>
              {contentObject.type === 'ad' ? (
                <Text sx={{ color: 'success.fg' }}>Patrocinado</Text>
              ) : (
                <TabCoinBalanceTooltip
                  direction="ne"
                  credit={contentObject.tabcoins_credit}
                  debit={contentObject.tabcoins_debit}>
                  <TabCoinsText count={contentObject.tabcoins} />
                </TabCoinBalanceTooltip>
              )}
              {' · '}
              <Text>
                <ChildrenDeepCountText count={contentObject.children_deep_count} />
              </Text>
              {' · '}
              <Tooltip text={`Autor: ${contentObject.owner_username}`}>
                <Text as="address" sx={{ fontStyle: 'normal', overflow: 'hidden', textOverflow: 'ellipsis' }}>
                  <Link sx={{ color: 'neutral.emphasis' }} href={`/${contentObject.owner_username}`}>
                    {contentObject.owner_username}
                  </Link>
                </Text>
              </Tooltip>
              {' · '}
              <Text>
                <PastTime direction="nw" date={contentObject.published_at} />
              </Text>
            </Box>
          </Box>
        </Box>
      );
    });
  }
}

function EndOfRelevant({ pagination, paginationBasePath }) {
  if (paginationBasePath == '/pagina' && !pagination.nextPage) {
    return (
      <Box key="end-of-relevant" sx={{ gridColumnStart: 2 }}>
        <Link sx={{ wordWrap: 'break-word' }} href={'/recentes/pagina/1'}>
          <Box
            sx={{
              overflow: 'auto',
              fontWeight: 'semibold',
              fontSize: 2,
            }}>
            Fim dos conteúdos relevantes mais atuais
          </Box>
          <Box sx={{ fontSize: 0 }}>Veja todos os conteúdos que já foram publicados na seção Recentes.</Box>
        </Link>
      </Box>
    );
  }

  return null;
}
</file>

<file path="pages/interface/components/DefaultLayout/index.js">
import { GoToTopButton } from '@tabnews/ui';

import { Box, Footer, Header } from '@/TabNewsUI';
import { Head } from 'pages/interface';

export default function DefaultLayout({ children, containerWidth = 'large', metadata }) {
  return (
    <Box sx={{ minHeight: '100vh', backgroundColor: 'canvas.default' }}>
      {metadata && <Head metadata={metadata} />}
      <Header />
      <Box
        as="main"
        maxWidth={containerWidth}
        sx={{
          marginX: 'auto',
          display: 'flex',
          flexWrap: 'wrap',
          padding: [2, null, null, 4],
          paddingTop: [3, null, null, 4],
        }}>
        {children}
      </Box>
      <Footer
        maxWidth={containerWidth}
        sx={{
          marginX: 'auto',
          paddingX: [2, null, null, 4],
          paddingTop: 3,
        }}
      />
      <GoToTopButton target="header" />
    </Box>
  );
}
</file>

<file path="pages/interface/components/EmptyState/index.js">
import { Box, Button, Heading, Text } from '@/TabNewsUI';
import { PlusIcon } from '@/TabNewsUI/icons';

export default function EmptyState(props) {
  const { title, description, action, icon: Icon, isLoading } = props;
  if (isLoading) return null;
  return (
    <Box
      sx={{
        margin: 'auto',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center',
        alignItems: 'center',
        textAlign: 'center',
        p: 4,
      }}>
      {Icon && <Icon size={40} sx={{ marginBottom: '1rem' }} />}
      <Heading sx={{ fontSize: 3 }}>{title}</Heading>
      {description && <Text>{description}</Text>}
      {action && (
        <Button sx={{ marginTop: '1rem' }} leadingVisual={PlusIcon} onClick={action.onClick}>
          {action.text}
        </Button>
      )}
    </Box>
  );
}
</file>

<file path="pages/interface/components/Footer/index.js">
import { Box, Link } from '@/TabNewsUI';
import { CgTab } from '@/TabNewsUI/icons';

export default function Footer(props) {
  return (
    <Box as="footer" {...props}>
      <Box
        fontSize={1}
        sx={{
          borderColor: 'border.default',
          borderTopStyle: 'solid',
          borderTopWidth: 1,
          width: '100%',
          paddingX: 2,
          paddingY: [4, null, null, 5],
          display: 'flex',
          justifyContent: 'center',
          flexWrap: 'wrap-reverse',
          gap: 3,
        }}>
        <Box
          sx={{
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            gap: 1,
            color: 'fg.subtle',
          }}>
          <Link
            sx={{
              color: 'fg.subtle',
              display: 'flex',
              justifyContent: 'center',
              alignItems: 'center',
            }}
            href="/"
            aria-label="Voltar para a página inicial">
            <CgTab size={26} />
          </Link>
          &copy; {new Date().getFullYear()} TabNews
        </Box>
        <Box
          sx={{
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            gap: [3, null, 4, 5],
            paddingX: [2, null, null, 5],
            flexWrap: 'wrap',
          }}>
          {/* Ordered alphabetically. */}
          <Link href="/contato">Contato</Link>
          <Link href="/faq">FAQ</Link>
          <Link href="https://github.com/filipedeschamps/tabnews.com.br">GitHub</Link>
          <Link href="/museu">Museu</Link>
          <Link href="/recentes/rss">RSS</Link>
          <Link href="https://www.tabnews.com.br/filipedeschamps/tentando-construir-um-pedaco-de-internet-mais-massa">
            Sobre
          </Link>
          <Link href="/status">Status</Link>
          <Link href="/termos-de-uso">Termos de Uso</Link>
        </Box>
      </Box>
    </Box>
  );
}
</file>

<file path="pages/interface/components/Graph/index.js">
import { Fragment, useEffect, useRef, useState } from 'react';
import { Network } from 'vis-network';

import {
  AnchoredOverlay,
  Box,
  Button,
  Checkbox,
  FormControl,
  IconButton,
  Link,
  Spinner,
  Text,
  useTheme,
} from '@/TabNewsUI';
import { FaPause, FaPlay } from '@/TabNewsUI/icons';
import useUser from 'pages/interface/hooks/useUser';

const border = '2px solid rgba(102, 102, 102, .5)'; // To be consistent with Charts style

function Graph({ title, data, simulationTimeout = 200 }) {
  const containerRef = useRef(null);
  const [network, setNetwork] = useState(null);
  const [isSelected, setIsSelected] = useState(false);
  const [status, setStatus] = useState();
  const [config, setConfig] = useState({
    maxVotes: 300,
    userVotesMin: 1,
    edgeVotesMin: 1,
    nuked: true,
    network: true,
    physics: true,
  });

  const { theme } = useTheme();
  const fontColor = theme.colors.fg.default;

  useEffect(() => {
    if (network || !containerRef.current) return;

    setNetwork(
      new Network(
        containerRef.current,
        {},
        {
          layout: {
            improvedLayout: false,
          },
          physics: {
            maxVelocity: 40,
            minVelocity: 1,
            barnesHut: {
              theta: 0.5,
              gravitationalConstant: -7500,
              centralGravity: 0.3,
              springLength: 5,
              springConstant: 0.03,
              damping: 0.09,
              avoidOverlap: 0,
            },
            stabilization: {
              iterations: 50,
              fit: true,
            },
          },
          locale: 'pt',
          groups: {
            users: { shape: 'icon', icon: { code: '👤' } },
            nuked: { shape: 'icon', icon: { code: '❌' } },
            IPs: { shape: 'icon', icon: { code: '🌐' } },
          },
          interaction: { hover: true },
        },
      ),
    );
  }, [network]);

  useEffect(() => {
    setStyles(data);
  }, [data]);

  useEffect(() => {
    updateData(network, data, config);
  }, [network, data, config]);

  useEffect(() => {
    network?.setOptions({ nodes: { font: { color: fontColor } } });
  }, [fontColor, network]);

  useEffect(() => {
    if (!network) return;

    const dragEnd = () =>
      setTimeout(
        () =>
          network.setOptions({
            physics: { enabled: config.physics },
          }),
        simulationTimeout,
      );

    const dragStart = () => {
      network.setOptions({
        physics: { enabled: true },
      });
    };

    const hovered = (event) => {
      if (!isSelected) setStatus(getStatusProps(event, network));
    };

    const selectEdge = (event) => {
      setIsSelected(true);
      setStatus(getStatusProps(event, network));
    };

    const deselectEdge = () => {
      setIsSelected(false);
      setStatus(null);
    };

    network.on('dragStart', dragStart);
    network.on('dragEnd', dragEnd);
    network.on('hoverEdge', hovered);
    network.on('hoverNode', hovered);
    network.on('selectEdge', selectEdge);
    network.on('deselectEdge', deselectEdge);

    return () => {
      network.off('dragStart', dragStart);
      network.off('dragEnd', dragEnd);
      network.off('hoverEdge', hovered);
      network.off('hoverNode', hovered);
      network.off('selectEdge', selectEdge);
      network.off('deselectEdge', deselectEdge);
    };
  }, [config, isSelected, network, simulationTimeout]);

  return (
    <Box>
      <Box display="flex" justifyContent="space-between" alignItems="center">
        <h2>{title}</h2>
        <Menu config={config} setConfig={setConfig} />
      </Box>
      <Box border={border} borderRadius={6} overflow="hidden">
        <Box
          ref={containerRef}
          display="flex"
          justifyContent="center"
          alignItems="center"
          width="100%"
          height="70vh"
          borderBottom={border}>
          <Spinner size="large" />
        </Box>
        <StatusBar status={status} />
        <Legend />
      </Box>
    </Box>
  );
}

export default Graph;

function updateData(network, data, config) {
  if (!network) return;

  const linkedNodes = new Set();
  const removeNodeIds = new Set();
  const addNodes = [];
  const updateNodes = [];
  const updateNodeIds = [];

  let totalVotes = 0;

  const filteredEdges = data.edges.filter((edge) => {
    if (
      (edge.type === 'network' && config.network) ||
      (edge.value >= config.edgeVotesMin && totalVotes < config.maxVotes)
    ) {
      totalVotes += edge.value || 0;
      linkedNodes.add(edge.from);
      linkedNodes.add(edge.to);
      return true;
    }

    return false;
  });

  data.nodes.forEach((node) => {
    if (
      !linkedNodes.has(node.id) ||
      (node.group === 'users' && node.votes < config.userVotesMin) ||
      (node.group === 'nuked' && !config.nuked) ||
      (node.group === 'IPs' && !config.network)
    ) {
      if (network.body.nodes[node.id]) {
        removeNodeIds.add(node.id);
      }
    } else {
      if (!network.body.nodes[node.id]) {
        addNodes.push(node.id);
      }
      updateNodes.push(node);
      updateNodeIds.push(node.id);
    }
  });

  if (!network.body.data.edges.length && !network.body.data.nodes.length) {
    network.setData({ nodes: updateNodes, edges: filteredEdges });
    return;
  }

  network.body.data.nodes.forEach((node) => {
    if (!linkedNodes.has(node.id)) {
      removeNodeIds.add(node.id);
    }
  });

  network.nodesHandler.remove([...removeNodeIds]);
  network.nodesHandler.add(addNodes, true);
  network.nodesHandler.update(updateNodeIds, updateNodes);

  if (
    filteredEdges.length !== network.body.data.edges.length ||
    filteredEdges.some((edge) => !network.body.edges[edge.id])
  ) {
    network.edgesHandler.setData(filteredEdges);
  }

  network.setOptions({
    physics: {
      enabled: config.physics,
    },
  });
}

function setStyles(data) {
  data.edges.forEach((edge) => {
    edge.color = edge.type === 'network' ? 'cyan' : edge.type === 'credit' ? 'green' : 'red';
    if (edge.type !== 'network') edge.arrows = 'to';
  });
  data.nodes.forEach((node) => {
    if (node.group === 'nuked' && node.username) node.label = node.username;
  });
}

function getStatusProps(event, network) {
  const edges =
    event.edges?.map((edgeId) => network.body.edges[edgeId]) ||
    (event.edge && [network.body.edges[event.edge]]) ||
    (event.node && network.body.nodes[event.node]?.edges) ||
    [];

  const userSelected =
    (event.nodes && network.body.nodes[event.nodes[0]]?.options.username) ||
    (event.node && network.body.nodes[event.node]?.options.username) ||
    (event.edge && network.body.edges[event.edge].from.options.username);

  const positiveVoteUsersMap = new Set();
  const negativeVoteUsersMap = new Set();
  const sharedIpsMap = new Map();
  let positives = 0;
  let negatives = 0;

  edges.forEach(({ from, to, options }) => {
    const isSharedIpNode = to.options.group === 'IPs';

    if (isSharedIpNode) {
      const ip = options.to;

      if (!sharedIpsMap.has(ip)) {
        sharedIpsMap.set(ip, new Set());

        to.edges.forEach(({ from }) => {
          const username = from.options.username;
          if (username && username !== userSelected) {
            sharedIpsMap.get(ip).add(username);
          }
        });
      }
    } else {
      const fromUsername = from.options.username !== userSelected && from.options.username;
      const toUsername = to.options.username !== userSelected && to.options.username;
      const value = options.value;
      const isPositive = options.color.color === 'green';

      if (isPositive) {
        positives += value;
        if (fromUsername) positiveVoteUsersMap.add(fromUsername);
        if (toUsername) positiveVoteUsersMap.add(toUsername);
      } else {
        negatives += value;
        if (fromUsername) negativeVoteUsersMap.add(fromUsername);
        if (toUsername) negativeVoteUsersMap.add(toUsername);
      }
    }
  });

  return {
    userSelected,
    positiveVoteUsers: [...positiveVoteUsersMap],
    positives,
    negativeVoteUsers: [...negativeVoteUsersMap],
    negatives,
    shared: [...sharedIpsMap.values()],
  };
}

function StatusBar({ status }) {
  return (
    <Box display="flex" minHeight={30} justifyContent="center" borderBottom={border} flexWrap="wrap">
      <DefaultStatusMessage status={status} />
      <UserSelected userSelected={status?.userSelected} />
      <JoinSharedNetworks {...status} />
      <JoinInteractions {...status} />
    </Box>
  );
}

function DefaultStatusMessage({ status }) {
  if (status) return null;

  return <Text>Selecione um nó ou aresta</Text>;
}

function UserSelected({ userSelected }) {
  if (!userSelected) return null;

  return <Link href={`/${userSelected}`}>{userSelected}&nbsp;</Link>;
}

function JoinSharedNetworks({ userSelected, positives, negatives, shared }) {
  if (!shared) return null;

  return shared.map((sharedFrom, i) => {
    return (
      <Fragment key={i}>
        {userSelected ? <Text>compartilha sua rede</Text> : <Text>Rede compartilhada</Text>}
        {sharedFrom.size === 1 && <Text>&nbsp;com&nbsp;</Text>}
        {sharedFrom.size > 1 && <Text>&nbsp;entre&nbsp;</Text>}
        <JoinLinksWithCommaOrAnd paths={[...sharedFrom]} />
        {i + 2 < shared.length && <Text>,&nbsp;</Text>}
        {i + 2 === shared.length && <Text>&nbsp;e&nbsp;</Text>}
        {i + 1 === shared.length && !!(positives || negatives) && <Text>&nbsp;|&nbsp;</Text>}
      </Fragment>
    );
  });
}

function JoinLinksWithCommaOrAnd({ paths }) {
  if (!paths?.length) return null;

  return paths.map((path, i) => [
    <Link key={path + i} href={`/${path}`}>
      {path}
    </Link>,
    i + 2 < paths.length && <Text key={i}>,&nbsp;</Text>,
    i + 2 == paths.length && <Text key={i}>&nbsp;e&nbsp;</Text>,
  ]);
}

function JoinInteractions({ positives, positiveVoteUsers, negatives, negativeVoteUsers }) {
  if (!positives && !negatives) return null;

  return (
    <>
      {positives > 0 && (
        <Text>{`➔ +${positives} TabCoin${positives > 1 ? 's' : ''}${
          positiveVoteUsers.length > 0 ? ' com\xA0' : ''
        }`}</Text>
      )}
      <JoinLinksWithCommaOrAnd paths={positiveVoteUsers} />
      {negatives > 0 && (
        <Text>{`${positives > 0 ? ' ' : ''}➔ -${negatives} TabCoin${negatives > 1 ? 's' : ''}${
          negativeVoteUsers.length > 0 ? ' com\xA0' : ''
        }`}</Text>
      )}
      <JoinLinksWithCommaOrAnd paths={negativeVoteUsers} />
    </>
  );
}

function Menu({ config, setConfig }) {
  const [isOpen, setIsOpen] = useState(false);
  const { user } = useUser();

  return (
    <Box sx={{ display: 'flex', gap: 2 }}>
      {user?.features?.includes('update:content:others') && (
        <AnchoredOverlay
          renderAnchor={(anchorProps) => <Button {...anchorProps}>Filtros</Button>}
          align="end"
          onOpen={() => setIsOpen(true)}
          onClose={() => setIsOpen(false)}
          open={isOpen}>
          <form
            style={{
              display: 'flex',
              flexDirection: 'column',
              width: 'max-content',
              maxWidth: '90vw',
              padding: 12,
              gap: 8,
            }}>
            <FormControl layout="horizontal" sx={{ alignItems: 'center', gap: 2 }}>
              <FormControl.Label htmlFor="Edges">Votos computados</FormControl.Label>
              <input
                type="number"
                style={{ width: '50px' }}
                id="Edges"
                value={config.maxVotes}
                onChange={(e) =>
                  setConfig({
                    ...config,
                    maxVotes: e.target.value > 1 ? (e.target.value > 1000 ? 1000 : e.target.value) : 1,
                  })
                }
              />
            </FormControl>

            <FormControl layout="horizontal" sx={{ alignItems: 'center', gap: 2 }}>
              <FormControl.Label htmlFor="UserVotes">Votos por usuário (mín.)</FormControl.Label>
              <input
                type="number"
                style={{ width: '50px' }}
                id="UserVotes"
                value={config.userVotesMin}
                onChange={(e) => setConfig({ ...config, userVotesMin: e.target.value > 1 ? e.target.value : 1 })}
              />
            </FormControl>

            <FormControl layout="horizontal" sx={{ alignItems: 'center', gap: 2 }}>
              <FormControl.Label htmlFor="EdgeVotes">Votos por aresta (mín.)</FormControl.Label>
              <input
                type="number"
                style={{ width: '50px' }}
                id="EdgeVotes"
                value={config.edgeVotesMin}
                onChange={(e) => setConfig({ ...config, edgeVotesMin: e.target.value > 1 ? e.target.value : 1 })}
              />
            </FormControl>

            <FormControl sx={{ alignItems: 'center', gap: 2, pl: '34px' }}>
              <Checkbox checked={config.nuked} onClick={(e) => setConfig({ ...config, nuked: e.target.checked })} />
              <FormControl.Label>Usuários Banidos ❌</FormControl.Label>
            </FormControl>

            <FormControl sx={{ alignItems: 'center', gap: 2, pl: '34px' }}>
              <Checkbox checked={config.network} onClick={(e) => setConfig({ ...config, network: e.target.checked })} />
              <FormControl.Label>Redes Compartilhadas 🌐</FormControl.Label>
            </FormControl>
          </form>
        </AnchoredOverlay>
      )}
      <IconButton
        onClick={() => setConfig({ ...config, physics: !config.physics })}
        icon={config.physics ? FaPause : FaPlay}
      />
    </Box>
  );
}

function Legend() {
  return (
    <Box display="flex" minHeight={30} justifyContent="space-around" alignItems="center" flexWrap="wrap">
      <Box>👤 Usuários Ativos</Box>
      <Box>❌ Usuários Banidos</Box>
      <Box>🌐 Redes Compartilhadas</Box>
    </Box>
  );
}
</file>

<file path="pages/interface/components/Head/index.js">
import NextHead from 'next/head';
import { useRouter } from 'next/router';

import webserver from 'infra/webserver.js';
import { useMediaQuery } from 'pages/interface';

const webserverHost = webserver.host;

export function DefaultHead() {
  const router = useRouter();

  const systemTheme = useMediaQuery('(prefers-color-scheme: dark)');
  const favicon = systemTheme ? '/favicon-dark.png' : '/favicon-light.png';

  const defaultMetadata = {
    title: 'TabNews: Conteúdos para quem trabalha com Programação e Tecnologia',
    image: `${webserverHost}/default-image-share.png`,
    description: 'Conteúdos com valor concreto para quem trabalha com tecnologia.',
    url: `${webserverHost}${router.asPath}`,
    type: 'website',
  };

  const { type, title, description, image, url } = defaultMetadata;

  return (
    <NextHead>
      <title>{title}</title>
      <meta name="title" content={title} key="title" />
      <meta name="description" content={description} key="description" />
      <meta name="robots" content="index follow" key="robots" />

      {(router.asPath === '/' || router.asPath === '/recentes/pagina/1') && (
        <link rel="alternate" type="application/rss+xml" title="TabNews: Recentes" href="/recentes/rss" />
      )}

      <meta property="og:site_name" content="TabNews" />
      <meta property="og:type" content={type} key="og:type" />
      <meta property="og:url" content={url} key="og:url" />
      <meta property="og:title" content={title} key="og:title" />
      <meta property="og:description" content={description} key="og:description" />
      <meta property="og:image" content={image} key="og:image" />

      <meta property="twitter:card" content="summary_large_image" key="twitter:card" />
      <meta property="twitter:url" content={url} key="twitter:url" />
      <meta property="twitter:title" content={title} key="twitter:title" />
      <meta property="twitter:description" content={description} key="twitter:description" />
      <meta property="twitter:image" content={image} key="twitter:image" />

      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <link rel="icon" href={favicon} type="image/png" />
      <link rel="manifest" href="/manifest.json" crossOrigin="use-credentials" />
      <meta name="mobile-web-app-capable" content="yes" />
      <meta name="apple-mobile-web-app-capable" content="yes" />
      {webserverHost.startsWith('https') && (
        <meta httpEquiv="Content-Security-Policy" content="upgrade-insecure-requests" />
      )}
    </NextHead>
  );
}

export default function Head({ metadata, children }) {
  const { type, title, description, image, url, noIndex, author, published_time, modified_time, canonical } =
    metadata || {};

  const canonicalUrl = canonical?.startsWith('http') ? canonical : `${webserverHost}${canonical}`;

  return (
    <NextHead>
      {title && (
        <>
          <title>{`${title} · TabNews`}</title>
          <meta name="title" content={title} key="title" />
          <meta property="og:title" content={title} key="og:title" />
          <meta property="twitter:title" content={title} key="twitter:title" />
        </>
      )}

      {description && (
        <>
          <meta name="description" content={description} key="description" />
          <meta property="og:description" content={description} key="og:description" />
          <meta property="twitter:description" content={description} key="twitter:description" />
        </>
      )}

      {canonical && <link rel="canonical" href={canonicalUrl} key="canonical" />}

      {url && (
        <>
          <meta property="og:url" content={url} key="og:url" />
          <meta property="twitter:url" content={url} key="twitter:url" />
        </>
      )}

      {image && (
        <>
          <meta property="og:image" content={image} key="og:image" />
          <meta property="twitter:image" content={image} key="twitter:image" />
        </>
      )}

      {author && (
        <>
          <meta property="article:author" content={author} />
          <meta property="article:section" content="tecnologia" />
        </>
      )}

      {noIndex && <meta name="robots" content="noindex, nofollow" key="robots" />}

      {type && <meta property="og:type" content={type} key="og:type" />}

      {published_time && <meta property="article:published_time" content={published_time} />}

      {modified_time && <meta property="article:modified_time" content={modified_time} />}

      {children}
    </NextHead>
  );
}
</file>

<file path="pages/interface/components/Header/index.js">
import { useRouter } from 'next/router';
import { useState } from 'react';

import {
  ActionList,
  ActionMenu,
  Box,
  Button,
  HeaderLink,
  NavItem,
  NavList,
  PrimerHeader,
  TabCashCount,
  TabCoinCount,
  ThemeSelector,
  ThemeSwitcher,
  Tooltip,
  Truncate,
  useSearchBox,
} from '@/TabNewsUI';
import {
  CgTab,
  GearIcon,
  ListUnorderedIcon,
  PersonIcon,
  PlusIcon,
  SignOutIcon,
  ThreeBarsIcon,
} from '@/TabNewsUI/icons';
import { useMediaQuery, useUser } from 'pages/interface';

export default function HeaderComponent() {
  const isScreenSmall = useMediaQuery('(max-width: 440px)');
  const { user, isLoading, logout } = useUser();
  const { asPath, pathname } = useRouter();
  const { SearchBarButton, SearchBarMenuItem, SearchBoxOverlay, SearchIconButton } = useSearchBox();
  const [isOpenMenu, setIsOpenMenu] = useState(false);

  const loginUrl =
    !asPath || user || pathname.startsWith('/cadastro')
      ? '/login'
      : pathname.startsWith('/login')
        ? asPath
        : `/login?redirect=${asPath}`;

  const activeLinkStyle = {
    textDecoration: 'underline',
    textUnderlineOffset: 6,
    ml: 3,
  };

  const canListUsers = user?.features.includes('read:user:list');

  return (
    <PrimerHeader as="header" id="header" sx={{ minWidth: 'max-content', px: [2, null, null, 3], overflow: 'visible' }}>
      <SearchBoxOverlay />
      <Box as="nav" sx={{ display: 'flex', flex: 1, margin: 0, padding: 0 }}>
        <PrimerHeader.Item sx={{ mr: 0 }}>
          <HeaderLink href="/" aria-label="Página inicial Relevantes" aria-current={asPath === '/' ? 'page' : false}>
            <CgTab size={32} />

            <Box sx={{ ml: 2, display: ['none', 'block'] }}>TabNews</Box>

            <Box sx={asPath === '/' || asPath.startsWith('/pagina') ? activeLinkStyle : { ml: 3 }}>Relevantes</Box>
          </HeaderLink>
        </PrimerHeader.Item>

        <PrimerHeader.Item full sx={{ mr: 0 }}>
          <HeaderLink
            href="/recentes/pagina/1"
            aria-current={asPath === '/recentes/pagina/1' ? 'page' : false}
            sx={asPath.startsWith('/recentes') ? activeLinkStyle : { ml: 3 }}>
            Recentes
          </HeaderLink>
        </PrimerHeader.Item>
      </Box>

      {!isLoading && !(isScreenSmall && user) && (
        <PrimerHeader.Item sx={{ ml: 3, mr: [1, , 3] }}>
          <SearchBarButton />
          <SearchIconButton />
        </PrimerHeader.Item>
      )}

      {!isLoading && !user && (
        <>
          <PrimerHeader.Item sx={{ mr: 1 }}>
            <ThemeSwitcher />
          </PrimerHeader.Item>

          {!isScreenSmall && (
            <>
              <PrimerHeader.Item sx={{ ml: 2 }}>
                <HeaderLink href={loginUrl}>Login</HeaderLink>
              </PrimerHeader.Item>
              <PrimerHeader.Item sx={{ mr: 1 }}>
                <HeaderLink href="/cadastro">Cadastrar</HeaderLink>
              </PrimerHeader.Item>
            </>
          )}

          {isScreenSmall && (
            <PrimerHeader.Item sx={{ ml: 2, mr: 1 }}>
              <HeaderLink href={loginUrl}>Entrar</HeaderLink>
            </PrimerHeader.Item>
          )}
        </>
      )}

      {user && (
        <>
          {!isScreenSmall && (
            <PrimerHeader.Item sx={{ m: 2 }}>
              <Tooltip text="Publicar novo conteúdo" direction="s">
                <HeaderLink href="/publicar">
                  <PlusIcon />
                </HeaderLink>
              </Tooltip>
            </PrimerHeader.Item>
          )}

          <PrimerHeader.Item
            sx={{
              mr: [0, 2],
              fontSize: 0,
              fontWeight: 'bold',
            }}>
            <TabCoinCount amount={user.tabcoins} sx={{ color: 'fg.onEmphasis', pl: 2, pr: 1 }} />
          </PrimerHeader.Item>

          <PrimerHeader.Item
            sx={{
              mr: 2,
              fontSize: 0,
              fontWeight: 'bold',
            }}>
            <TabCashCount amount={user.tabcash} sx={{ color: 'fg.onEmphasis', pr: 1 }} />
          </PrimerHeader.Item>

          <PrimerHeader.Item sx={{ mr: 0 }}>
            <ActionMenu open={isOpenMenu} onOpenChange={setIsOpenMenu}>
              <ActionMenu.Anchor>
                <Button
                  aria-label="Abrir o menu"
                  variant="invisible"
                  sx={{
                    px: 0,
                    mx: 1,
                    color: 'header.logo',
                    '&:hover': {
                      color: 'header.text',
                      backgroundColor: 'transparent',
                    },
                    '&:focus-visible': { outline: '2px solid #FFF' },
                  }}
                  style={{ background: 'transparent' }}>
                  <ThreeBarsIcon size={24} />
                </Button>
              </ActionMenu.Anchor>

              <ActionMenu.Overlay>
                <NavList>
                  <NavItem href={`/${user.username}`}>
                    <NavList.LeadingVisual>
                      <PersonIcon />
                    </NavList.LeadingVisual>
                    <Truncate>{user.username}</Truncate>
                  </NavItem>

                  {canListUsers && (
                    <NavList.Group>
                      <NavItem href="/moderacao/usuarios/1">
                        <NavList.LeadingVisual>
                          <ListUnorderedIcon />
                        </NavList.LeadingVisual>
                        Usuários
                      </NavItem>
                    </NavList.Group>
                  )}

                  <NavList.Group>
                    <NavItem href="/publicar">
                      <NavList.LeadingVisual>
                        <PlusIcon />
                      </NavList.LeadingVisual>
                      Novo conteúdo
                    </NavItem>

                    <NavItem href={`/${user.username}/conteudos/1`}>
                      <NavList.LeadingVisual>
                        <ListUnorderedIcon />
                      </NavList.LeadingVisual>
                      Meus conteúdos
                    </NavItem>

                    <NavItem href="/perfil">
                      <NavList.LeadingVisual>
                        <GearIcon />
                      </NavList.LeadingVisual>
                      Editar perfil
                    </NavItem>
                    <NavList.Divider />
                  </NavList.Group>

                  {isScreenSmall && (
                    <>
                      <SearchBarMenuItem />
                      <ActionList.Divider />
                    </>
                  )}

                  <ThemeSelector onSelect={() => setIsOpenMenu(false)} as="li" role="none" sx={{ listStyle: 'none' }} />
                  <ActionList.Divider />

                  <ActionList.Item variant="danger" onSelect={logout}>
                    <ActionList.LeadingVisual>
                      <SignOutIcon />
                    </ActionList.LeadingVisual>
                    Deslogar
                  </ActionList.Item>
                </NavList>
              </ActionMenu.Overlay>
            </ActionMenu>
          </PrimerHeader.Item>
        </>
      )}
    </PrimerHeader>
  );
}
</file>

<file path="pages/interface/components/Link/index.js">
import NextLink from 'next/link';
import { useRouter } from 'next/router';

import { NavList, PrimerHeader, PrimerLink, TabNav } from '@/TabNewsUI';

export default NextLink;

export function Link({ href, children, ...props }) {
  return (
    <PrimerLink as={NextLink} href={href} prefetch={false} {...props}>
      {children}
    </PrimerLink>
  );
}

export function HeaderLink({ href, children, ...props }) {
  return (
    <PrimerHeader.Link as={NextLink} href={href} prefetch={false} {...props}>
      {children}
    </PrimerHeader.Link>
  );
}

export function NavItem({ href, children, ...props }) {
  const router = useRouter();
  const isCurrent = typeof href === 'string' ? router.asPath === href : router.pathname === href.pathname;
  return (
    <NavList.Item as={NextLink} href={href} aria-current={isCurrent ? 'page' : false} prefetch={false} {...props}>
      {children}
    </NavList.Item>
  );
}

export function TabNavLink({ href, children, ...props }) {
  const router = useRouter();
  const isCurrent = typeof href === 'string' ? router.asPath === href : router.pathname === href.pathname;
  return (
    <TabNav.Link as={NextLink} href={href} selected={isCurrent} prefetch={false} {...props}>
      {children}
    </TabNav.Link>
  );
}
</file>

<file path="pages/interface/components/Markdown/index.js">
import { isTrustedDomain } from '@tabnews/helpers';
import { MarkdownEditor, MarkdownViewer } from '@tabnews/ui/markdown';

const shouldAddNofollow = (url) => !isTrustedDomain(url);

export default function Viewer(props) {
  return MarkdownViewer({
    shouldAddNofollow,
    ...props,
  });
}

export function Editor(props) {
  return MarkdownEditor({
    shouldAddNofollow,
    ...props,
  });
}
</file>

<file path="pages/interface/components/Pagination/index.js">
import { Box, Link, Text } from '@/TabNewsUI';
import { ChevronLeftIcon, ChevronRightIcon } from '@/TabNewsUI/icons';

export default function Pagination({ previousPage, nextPage, basePath }) {
  const previousPageUrl = `${basePath}/${previousPage}`;
  const nextPageUrl = `${basePath}/${nextPage}`;

  return (
    <Box
      sx={{
        display: 'flex',
        width: '100%',
        justifyContent: 'center',
        whiteSpace: 'nowrap',
        gap: 4,
        m: 4,
        mb: 2,
      }}>
      {previousPage ? (
        <Link href={previousPageUrl} scroll={false}>
          <ChevronLeftIcon size={16} />
          Anterior
        </Link>
      ) : (
        <Text color="fg.muted">
          <ChevronLeftIcon size={16} />
          Anterior
        </Text>
      )}

      {nextPage ? (
        <Link href={nextPageUrl}>
          Próximo
          <ChevronRightIcon size={16} />
        </Link>
      ) : (
        <Text color="fg.muted">
          Próximo
          <ChevronRightIcon size={16} />
        </Text>
      )}
    </Box>
  );
}
</file>

<file path="pages/interface/components/PastTime/index.js">
import { format, formatDistanceToNowStrict } from 'date-fns';
import { ptBR } from 'date-fns/locale';
import { useEffect, useState } from 'react';

import { Tooltip } from '@/TabNewsUI';

function formatTooltipLabel(date, gmt = false) {
  const displayFormat = gmt ? "EEEE, d 'de' MMMM 'de' yyyy 'às' HH:mm z" : "EEEE, d 'de' MMMM 'de' yyyy 'às' HH:mm";

  try {
    return format(new Date(date), displayFormat, { locale: ptBR });
  } catch (e) {
    return '';
  }
}

export default function PastTime({ date, formatText, ...props }) {
  const [tooltipLabel, setTooltipLabel] = useState(formatTooltipLabel(date, true));

  useEffect(() => {
    setTooltipLabel(formatTooltipLabel(date));
  }, [date]);

  function getText(date) {
    try {
      const formattedDate = formatDistanceToNowStrict(new Date(date), {
        locale: ptBR,
      });

      return formatText ? formatText(formattedDate) : `${formattedDate} atrás`;
    } catch (e) {
      return '';
    }
  }

  return (
    <Tooltip text={tooltipLabel} suppressHydrationWarning {...props}>
      <time dateTime={date} style={{ whiteSpace: 'nowrap' }} suppressHydrationWarning>
        {getText(date)}
      </time>
    </Tooltip>
  );
}
</file>

<file path="pages/interface/components/Progressbar/index.js">
// Original code from: https://github.com/apal21/nextjs-progressbar

import Router from 'next/router';
import NProgress from 'nprogress';
import { useEffect } from 'react';

export default function NextNProgress({
  color = '#29D',
  startPosition = 0.3,
  stopDelayMs = 200,
  height = 3,
  showOnShallow = true,
  options,
}) {
  useEffect(() => {
    let timer = null;

    if (options) {
      NProgress.configure(options);
    }

    const routeChangeStart = (url, { shallow }) => {
      if (Router.asPath === url) return;
      if (!shallow || showOnShallow) {
        NProgress.set(startPosition);
        NProgress.start();
      }
    };

    const routeChangeEnd = (_, { shallow }) => {
      if (NProgress.status === null) return;
      if (!shallow || showOnShallow) {
        if (timer) clearTimeout(timer);
        timer = setTimeout(() => {
          NProgress.done(true);
        }, stopDelayMs);
      }
    };

    Router.events.on('routeChangeStart', routeChangeStart);
    Router.events.on('routeChangeComplete', routeChangeEnd);
    Router.events.on('routeChangeError', routeChangeEnd);
    return () => {
      Router.events.off('routeChangeStart', routeChangeStart);
      Router.events.off('routeChangeComplete', routeChangeEnd);
      Router.events.off('routeChangeError', routeChangeEnd);
    };
  }, [options, showOnShallow, startPosition, stopDelayMs]);

  return (
    <style jsx global>{`
      #nprogress {
        pointer-events: none;
      }
      #nprogress .bar {
        background: ${color};
        position: fixed;
        z-index: 9999;
        top: 0;
        left: 0;
        width: 100%;
        height: ${height}px;
      }
      #nprogress .peg {
        display: block;
        position: absolute;
        right: 0px;
        width: 100px;
        height: 100%;
        box-shadow:
          0 0 10px ${color},
          0 0 5px ${color};
        opacity: 1;
        -webkit-transform: rotate(3deg) translate(0px, -4px);
        -ms-transform: rotate(3deg) translate(0px, -4px);
        transform: rotate(3deg) translate(0px, -4px);
      }
      #nprogress .spinner {
        display: block;
        position: fixed;
        z-index: 1031;
        top: 15px;
        right: 15px;
      }
      #nprogress .spinner-icon {
        width: 18px;
        height: 18px;
        box-sizing: border-box;
        border: solid 2px transparent;
        border-top-color: ${color};
        border-left-color: ${color};
        border-radius: 50%;
        -webkit-animation: nprogresss-spinner 400ms linear infinite;
        animation: nprogress-spinner 400ms linear infinite;
      }
      .nprogress-custom-parent {
        overflow: hidden;
        position: relative;
      }
      .nprogress-custom-parent #nprogress .spinner,
      .nprogress-custom-parent #nprogress .bar {
        position: absolute;
      }
      @-webkit-keyframes nprogress-spinner {
        0% {
          -webkit-transform: rotate(0deg);
        }
        100% {
          -webkit-transform: rotate(360deg);
        }
      }
      @keyframes nprogress-spinner {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    `}</style>
  );
}
</file>

<file path="pages/interface/components/ReadTime/index.js">
import { useMemo } from 'react';

import { Text } from '@/TabNewsUI';

export default function ReadTime({ text, ...props }) {
  const readTimeInMinutes = useMemo(() => {
    const wpm = 260;
    const wordsQuantity = text.split(/[^A-Za-z]+/).length;
    return `${Math.ceil(wordsQuantity / wpm)} min de leitura`;
  }, [text]);

  return (
    <Text sx={{ fontSize: 0, color: 'fg.muted' }} {...props}>
      {readTimeInMinutes}
    </Text>
  );
}
</file>

<file path="pages/interface/components/RecentTabNav/index.js">
import { TabNav, TabNavLink } from '@/TabNewsUI';

export default function RecentTabNav() {
  return (
    <TabNav sx={{ width: '100%', mb: 3 }}>
      <TabNavLink
        href={{
          pathname: '/recentes/pagina/[page]',
          query: { page: 1 },
        }}>
        Publicações
      </TabNavLink>
      <TabNavLink
        href={{
          pathname: '/recentes/comentarios/[page]',
          query: { page: 1 },
        }}>
        Comentários
      </TabNavLink>
      <TabNavLink
        href={{
          pathname: '/recentes/classificados/[page]',
          query: { page: 1 },
        }}>
        Classificados
      </TabNavLink>
      <TabNavLink
        href={{
          pathname: '/recentes/todos/[page]',
          query: { page: 1 },
        }}>
        Todos
      </TabNavLink>
    </TabNav>
  );
}
</file>

<file path="pages/interface/components/SearchBox/index.js">
import { useEffect, useRef, useState } from 'react';

import { ActionList, Box, Button, Heading, IconButton, Overlay, Spinner } from '@/TabNewsUI';
import { SearchIcon, XCircleFillIcon } from '@/TabNewsUI/icons';

const searchURL = process.env.NEXT_PUBLIC_SEARCH_URL + process.env.NEXT_PUBLIC_SEARCH_ID;

export default function useSearchBox() {
  const [isOpen, setIsOpen] = useState(false);
  const buttonRef = useRef();

  function onClickSearchButton(e) {
    buttonRef.current = e.target;
    setIsOpen(true);
  }

  function SearchIconButton({ sx, ...props }) {
    return (
      <IconButton
        aria-label="Pesquisar"
        onClick={onClickSearchButton}
        variant="invisible"
        sx={{
          display: ['flex', , 'none'],
          px: '7px',
          color: 'header.logo',
          '&:hover': {
            color: 'header.text',
            backgroundColor: 'transparent',
          },
          '&:focus-visible': {
            outline: '2px solid #FFF',
          },
          ...sx,
        }}
        icon={SearchIcon}
        size="small"
        {...props}
      />
    );
  }

  function SearchBarButton({ sx, ...props }) {
    return (
      <Button
        onClick={onClickSearchButton}
        alignContent="flex-start"
        sx={{
          display: ['none', , 'flex'],
          width: [, , '200px', '300px'],
          px: '13px',
          color: 'checks.inputPlaceholderText',
          backgroundColor: 'headerSearch.bg',
          borderColor: 'headerSearch.border',
          cursor: 'text',
          '&:focus-visible': {
            outline: '2px solid #FFF !important',
          },
          ...sx,
        }}
        leadingVisual={SearchIcon}
        {...props}>
        Pesquisar
      </Button>
    );
  }

  function SearchBarMenuItem(props) {
    return (
      <ActionList.Item onSelect={onClickSearchButton} {...props}>
        <ActionList.LeadingVisual>
          <SearchIcon />
        </ActionList.LeadingVisual>
        Pesquisar
      </ActionList.Item>
    );
  }

  function SearchBoxOverlay() {
    const [isLoading, setIsLoading] = useState(true);
    const inputRef = useRef(null);
    const suggestionsRef = useRef(null);

    const onInputRender = (input) => {
      setIsLoading(false);
      input.focus();
      inputRef.current = input;
    };

    const onSuggestionsRender = (suggestionsBox) => {
      suggestionsRef.current = suggestionsBox;
    };

    const handleClose = () => {
      setIsOpen(false);
      clearGoogleBox();
    };

    if (!isOpen) return null;

    return (
      <Overlay
        returnFocusRef={buttonRef}
        ignoreClickRefs={[suggestionsRef, buttonRef]}
        onEscape={handleClose}
        onClickOutside={handleClose}
        aria-labelledby="Pesquisar com o Google"
        top={32}
        left={'50vw'}
        anchorSide="inside-center"
        sx={{
          display: 'flex',
          position: 'relative',
          flexDirection: 'column',
          width: '90vw',
          maxWidth: '900px',
          maxHeight: ['95vh', '90vh'],
          mx: '1px',
          overflow: 'hidden',
          borderStyle: 'solid',
          borderWidth: '1px',
          borderColor: 'border.default',
          backgroundColor: '#FFF',
          transform: 'translateX(-50%)',
        }}>
        <Box sx={isLoading ? { height: '138px' } : { overflowY: 'auto', minHeight: '138px' }}>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', p: '13px', pb: '0' }}>
            <Heading sx={{ flex: 1, textAlign: 'center', fontSize: 3, color: '#444444' }}>
              Pesquisar com o Google
            </Heading>
            <IconButton icon={XCircleFillIcon} variant="invisible" onClick={handleClose} />
          </Box>

          <GoogleBox onInputRender={onInputRender} onSuggestionsRender={onSuggestionsRender} />

          <Box sx={{ display: 'flex', justifyContent: 'center', height: '26px', pt: '20px' }}>
            {isLoading && <Spinner size="medium" />}
          </Box>
        </Box>

        <style jsx global>{`
          .gsc-input-box {
            border-radius: 6px !important;
          }
          .gsc-search-button-v2 {
            border-radius: 6px !important;
            cursor: pointer;
            padding: 8px !important;
            background-color: #21262d !important;
          }
          .gsc-input {
            color-scheme: light !important;
          }
          .gssb_c {
            color: #444444;
            left: max(calc(5vw + 16px), calc(50vw - 434px)) !important;
          }
        `}</style>
      </Overlay>
    );
  }

  return {
    onClickSearchButton,
    SearchBarButton,
    SearchBarMenuItem,
    SearchBoxOverlay,
    SearchIconButton,
  };
}

function GoogleBox({ onInputRender = () => {}, onSuggestionsRender = () => {} } = {}) {
  useEffect(() => {
    const script = document.createElement('script');
    script.src = searchURL;
    document.head.append(script);

    const waitInputBox = waitForElm('.gsc-input-box');
    const waitSuggestionBox = waitForElm('.gssb_c');
    const waitAboveResultsBox = waitForElm('.gsc-above-wrapper-area');

    (async () => {
      const inputBox = await waitInputBox.start();
      const input = inputBox.querySelector('input');
      onInputRender(input);

      const suggestionBox = await waitSuggestionBox.start();
      onSuggestionsRender(suggestionBox);
    })();

    (async () => {
      const aboveResultsBox = await waitAboveResultsBox.start();
      aboveResultsBox.style.display = 'block';
    })();

    return () => {
      waitInputBox.cancel();
      waitSuggestionBox.cancel();
      waitAboveResultsBox.cancel();
    };
  }, [onInputRender, onSuggestionsRender]);

  return <div className="gcse-search" data-linktarget="_self"></div>;
}

function clearGoogleBox() {
  Array.from(document.getElementsByTagName('script')).forEach((elm) => {
    if (elm.src?.includes('google.com/')) {
      elm.remove();
    }
  });

  Array.from(document.getElementsByTagName('link')).forEach((elm) => {
    if (elm.href?.includes('google.com/')) {
      elm.remove();
    }
  });

  Array.from(document.getElementsByTagName('style')).forEach((elm) => {
    if (
      elm.href?.includes('google.com/') ||
      elm.textContent?.includes('.gsc-refinementsGradient') ||
      elm.textContent?.includes('.gsc-completion-container')
    ) {
      elm.remove();
    }
  });

  document.querySelectorAll('.gssb_c').forEach((elm) => elm.remove());

  let elm = document.getElementById('private_ratings');

  while (elm) {
    elm.parentElement?.remove();
    elm = document.getElementById('private_ratings');
  }
}

function waitForElm(selector) {
  let observer;

  const start = () => {
    return new Promise((resolve) => {
      if (document.querySelector(selector)) {
        return resolve(document.querySelector(selector));
      }

      observer = new MutationObserver(() => {
        if (document.querySelector(selector)) {
          resolve(document.querySelector(selector));
          observer.disconnect();
        }
      });

      observer.observe(document.body, {
        childList: true,
        subtree: true,
      });
    });
  };

  const cancel = () => {
    if (observer) {
      observer.disconnect();
    }
  };

  return {
    cancel,
    start,
  };
}
</file>

<file path="pages/interface/components/SkeletonLoader/index.js">
import ContentLoader from 'react-content-loader';

import { useTheme } from '@/TabNewsUI';

/**
 * @param {import('react-content-loader').IContentLoaderProps} props
 */
export default function SkeletonLoader(props) {
  const { colorScheme, theme } = useTheme();

  const foregroundColor = colorScheme === 'dark' ? theme.colors.neutral.emphasis : theme.colors.canvas.subtle;

  return (
    <ContentLoader
      backgroundColor={theme.colors.switchTrack.activeBg}
      foregroundColor={foregroundColor}
      title="Carregando..."
      speed={1}
      {...props}
    />
  );
}
</file>

<file path="pages/interface/components/TabCashCount/index.js">
import { Box, Text, Tooltip } from '@/TabNewsUI';
import { SquareFillIcon } from '@/TabNewsUI/icons';

export default function TabCashCount({ amount, direction, mode = 'tooltip', sx }) {
  const modes = {
    tooltip: {
      iconLabel: 'TabCash',
      iconSize: 16,
      text: amount?.toLocaleString('pt-BR'),
    },
    full: {
      iconSize: 20,
      text: `${amount?.toLocaleString('pt-BR')} TabCash`,
    },
  };

  const { iconLabel, iconSize, text } = modes[mode];

  const content = (
    <Box sx={{ display: 'flex', textWrap: 'nowrap', alignItems: 'center', ...sx }}>
      <SquareFillIcon aria-label={iconLabel} fill="#2da44e" size={iconSize} />
      <Text>{text}</Text>
    </Box>
  );

  if (mode === 'full') {
    return content;
  }

  return (
    <Tooltip text="TabCash" direction={direction ?? 's'}>
      {content}
    </Tooltip>
  );
}
</file>

<file path="pages/interface/components/TabCoinBalanceTooltip/index.js">
import { Tooltip } from '@/TabNewsUI';

export default function TabCoinBalanceTooltip({ children, credit, debit, ...props }) {
  function getLabel() {
    const debitCount = Math.abs(debit);
    const total = credit + debitCount;

    if (total === 0) {
      return `Nenhum voto`;
    }

    const creditPercentage = Math.round((credit / total) * 100);
    return `+${credit} | -${debitCount} (${creditPercentage}% achou relevante)`;
  }

  return (
    <Tooltip {...props} text={getLabel()}>
      {children}
    </Tooltip>
  );
}
</file>

<file path="pages/interface/components/TabCoinButtons/index.js">
import { useRouter } from 'next/router';
import { useRevalidate } from 'next-swr';
import { useEffect, useState } from 'react';
import { useReward } from 'react-rewards';

import { Box, IconButton, TabCoinBalanceTooltip, Tooltip } from '@/TabNewsUI';
import { ChevronDownIcon, ChevronUpIcon } from '@/TabNewsUI/icons';
import { createErrorMessage, useUser } from 'pages/interface';

export default function TabCoinButtons({ content }) {
  if (content?.status !== 'published') {
    return <DisabledButtons />;
  }

  return <ActiveButtons content={content} />;
}

function ActiveButtons({ content }) {
  const router = useRouter();
  const { user, isLoading, fetchUser } = useUser();

  const [contentObject, setContentObject] = useRevalidate(content);
  const [isPosting, setIsPosting] = useState(false);

  useEffect(() => {
    setContentObject(content);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [content.id]);

  const { reward: rewardCredit, isAnimating: isAnimatingCredit } = useReward(`reward-${contentObject.id}`, 'confetti', {
    position: 'absolute',
    lifetime: 100,
    decay: 0.9,
    spread: 60,
    elementCount: 100,
  });

  const { reward: rewardDebit, isAnimating: isAnimatingDebit } = useReward(`reward-${contentObject.id}`, 'emoji', {
    position: 'absolute',
    lifetime: 100,
    angle: 90,
    startVelocity: 10,
    decay: 0.94,
    spread: 60,
    elementCount: 4,
    emoji: ['😡'],
  });

  async function transactTabCoin(transactionType) {
    setIsPosting(true);

    if (!user && !isLoading) {
      router.push(`/login?redirect=${router.asPath}`);
      return;
    }

    try {
      const response = await fetch(`/api/v1/contents/${contentObject.owner_username}/${contentObject.slug}/tabcoins`, {
        method: 'POST',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          transaction_type: transactionType,
        }),
      });

      const responseBody = await response.json();

      if (response.status === 201) {
        fetchUser();
        setContentObject({ ...contentObject, ...responseBody });
        setIsPosting(false);
        if (transactionType === 'credit') {
          rewardCredit();
        }

        if (transactionType === 'debit') {
          rewardDebit();
        }
        return;
      }

      alert(
        createErrorMessage(responseBody, {
          omitErrorId: response.status == 422,
        }),
      );

      setIsPosting(false);
    } catch (error) {
      setIsPosting(false);
    }
  }

  const isInAction = isPosting || isAnimatingCredit || isAnimatingDebit;

  return (
    <Box
      sx={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
      }}>
      <Tooltip text="Achei relevante" direction="ne">
        <IconButton
          variant="invisible"
          aria-label="Creditar TabCoin"
          icon={ChevronUpIcon}
          size="small"
          sx={{ color: 'fg.subtle', lineHeight: '18px' }}
          onClick={() => transactTabCoin('credit')}
          disabled={isInAction}
        />
      </Tooltip>
      <TabCoinBalanceTooltip
        direction="ne"
        sx={{
          width: '100%',
          textAlign: 'center',
          fontSize: 0,
          fontWeight: 'bold',
          my: 2,
          py: 1,
          color: 'accent.emphasis',
        }}
        credit={contentObject.tabcoins_credit}
        debit={contentObject.tabcoins_debit}>
        <div id={`reward-${contentObject.id}`} style={{ marginLeft: '-10px' }} aria-hidden></div>
        {contentObject.tabcoins}
      </TabCoinBalanceTooltip>
      <Tooltip text="Não achei relevante" direction="ne">
        <IconButton
          variant="invisible"
          aria-label="Debitar TabCoin"
          icon={ChevronDownIcon}
          size="small"
          sx={{ color: 'fg.subtle', lineHeight: '18px', mb: 2 }}
          onClick={() => transactTabCoin('debit')}
          disabled={isInAction}
        />
      </Tooltip>
    </Box>
  );
}

function DisabledButtons() {
  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', color: 'border.muted', mt: 1, gap: 4, mb: 2 }}>
      <ChevronUpIcon />
      <ChevronDownIcon />
    </Box>
  );
}
</file>

<file path="pages/interface/components/TabCoinCount/index.js">
import { Box, Text, Tooltip } from '@/TabNewsUI';
import { SquareFillIcon } from '@/TabNewsUI/icons';

export default function TabCoinCount({ amount, direction, mode = 'tooltip', sx }) {
  const modes = {
    tooltip: {
      iconLabel: 'TabCoins',
      iconSize: 16,
      text: amount?.toLocaleString('pt-BR'),
    },
    full: {
      iconSize: 20,
      text: `${amount?.toLocaleString('pt-BR')} TabCoin${amount > 1 || amount < -1 ? 's' : ''}`,
    },
  };

  const { iconLabel, iconSize, text } = modes[mode];

  const content = (
    <Box sx={{ display: 'flex', textWrap: 'nowrap', alignItems: 'center', ...sx }}>
      <SquareFillIcon aria-label={iconLabel} fill="#0969da" size={iconSize} />
      <Text>{text}</Text>
    </Box>
  );

  if (mode === 'full') {
    return content;
  }

  return (
    <Tooltip text="TabCoins" direction={direction ?? 's'}>
      {content}
    </Tooltip>
  );
}
</file>

<file path="pages/interface/components/TabNewsUI/icons/index.js">
export { CgTab } from 'react-icons/cg';
export { FaPause, FaPlay, FaTree, FaUser } from 'react-icons/fa';
export {
  AlertFillIcon,
  ChevronDownIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
  ChevronUpIcon,
  CircleSlashIcon,
  CommentDiscussionIcon,
  CommentIcon,
  EyeClosedIcon,
  EyeIcon,
  FoldIcon,
  GearIcon,
  HomeIcon,
  KebabHorizontalIcon,
  LinkExternalIcon,
  LinkIcon,
  ListUnorderedIcon,
  MoonIcon,
  PencilIcon,
  PersonIcon,
  PlusIcon,
  SearchIcon,
  SignOutIcon,
  ShareIcon,
  SquareFillIcon,
  SunIcon,
  ThreeBarsIcon,
  TrashIcon,
  UnfoldIcon,
  XCircleFillIcon,
} from '@primer/octicons-react';
</file>

<file path="pages/interface/components/TabNewsUI/index.js">
export { default as AdBanner } from '@/AdBanner';
export { default as ButtonWithLoader } from '@/ButtonWithLoader';
export { default as CharacterCount } from '@/CharacterCount';
export { default as Confetti } from '@/Confetti';
export { default as Content } from '@/Content';
export { default as ContentList } from '@/ContentList';
export { default as DefaultLayout } from '@/DefaultLayout';
export { default as EmptyState } from '@/EmptyState';
export { default as Footer } from '@/Footer';
export { default as Header } from '@/Header';
export { HeaderLink, Link, NavItem, default as NextLink, TabNavLink } from '@/Link';
export { Editor, default as Viewer } from '@/Markdown';
export { default as Pagination } from '@/Pagination';
export { default as PastTime } from '@/PastTime';
export { default as NextNProgress } from '@/Progressbar';
export { default as ReadTime } from '@/ReadTime';
export { default as RecentTabNav } from '@/RecentTabNav';
export { default as useSearchBox } from '@/SearchBox';
export { default as SkeletonLoader } from '@/SkeletonLoader';
export { default as TabCashCount } from '@/TabCashCount';
export { default as TabCoinBalanceTooltip } from '@/TabCoinBalanceTooltip';
export { default as TabCoinButtons } from '@/TabCoinButtons';
export { default as TabCoinCount } from '@/TabCoinCount';
export { default as ThemeProvider } from '@/ThemeProvider';
export { default as ThemeSelector, ThemeSwitcher } from '@/ThemeSelector';
export { default as Tooltip } from '@/Tooltip';
export { default as Turnstile } from '@/Turnstile';
export { default as UserHeader } from '@/UserHeader';
export { default as UserList } from '@/UserList';
export {
  ActionList,
  ActionMenu,
  AnchoredOverlay,
  AutoThemeProvider,
  Box,
  BranchName,
  Button,
  Checkbox,
  CounterLabel,
  Flash,
  FormControl,
  Heading,
  IconButton,
  Label,
  LabelGroup,
  NavList,
  Overlay,
  SegmentedControl,
  Spinner,
  TabNav,
  Text,
  TextInput,
  TooltipV1,
  Truncate,
  useConfirm,
  useTheme,
} from '@tabnews/ui';

export { Header as PrimerHeader, Link as PrimerLink } from '@tabnews/ui/primer';
</file>

<file path="pages/interface/components/ThemeProvider/index.js">
import { AutoThemeProvider, NextNProgress } from '@/TabNewsUI';

export default function ThemeProvider({ children, ...props }) {
  return (
    <AutoThemeProvider {...props}>
      <NextNProgress options={{ showSpinner: false }} />
      {children}
    </AutoThemeProvider>
  );
}
</file>

<file path="pages/interface/components/ThemeSelector/index.js">
import { Box, Button, SegmentedControl, useTheme } from '@/TabNewsUI';
import { MoonIcon, SunIcon } from '@/TabNewsUI/icons';

export default function ThemeSelector({ onSelect, sx, ...props }) {
  const { colorMode, setColorMode } = useTheme();

  const handleChangeColorMode = (index) => {
    const mode = ['dark', 'auto', 'light'][index];
    setColorMode(mode);
    onSelect?.(mode);
    localStorage.setItem('colorMode', mode);
  };

  return (
    <Box sx={{ maxWidth: '160px', mx: 'auto', color: 'accent.emphasis', ...sx }} {...props}>
      <SegmentedControl
        aria-label="Seletor de tema: claro, automático ou escuro"
        size="small"
        onChange={handleChangeColorMode}
        fullWidth>
        <SegmentedControl.IconButton
          aria-label="Tema escuro"
          selected={['night', 'dark'].includes(colorMode)}
          icon={MoonIcon}
          size="small"
        />
        <SegmentedControl.Button aria-label="Tema automático" selected={'auto' === colorMode} size="small">
          Auto
        </SegmentedControl.Button>
        <SegmentedControl.IconButton
          aria-label="Tema claro"
          selected={['day', 'light'].includes(colorMode)}
          icon={SunIcon}
          size="small"
        />
      </SegmentedControl>
    </Box>
  );
}

export function ThemeSwitcher({ ...props }) {
  const { resolvedColorMode: mode, setColorMode } = useTheme();
  const isLight = ['day', 'light'].includes(mode);

  const handleSwitchMode = () => {
    const newMode = isLight ? 'dark' : 'light';
    setColorMode(newMode);
    localStorage.setItem('colorMode', newMode);
  };

  return (
    <Button
      aria-label='Alternar tema entre "claro" e "escuro"'
      onClick={handleSwitchMode}
      variant="invisible"
      sx={{
        color: isLight ? '#e7dfc3' : '#ecdc0f99',
        '&:hover': {
          color: isLight ? '#e7dfc370' : '#ecdc0f',
          backgroundColor: 'transparent',
        },
        '&:focus-visible': {
          outline: '2px solid #FFF',
        },
        px: '7px',
        pb: '3px',
      }}
      {...props}>
      {isLight ? <MoonIcon size={16} /> : <SunIcon size={16} />}
    </Button>
  );
}
</file>

<file path="pages/interface/components/Tooltip/index.js">
import { Box, TooltipV1 } from '@/TabNewsUI';

const gap = '2px';

const replaceMargin = {
  '&.tooltipped-s, &.tooltipped-se, &.tooltipped-sw': {
    '&::after': {
      marginTop: gap,
    },
  },
  '&.tooltipped-e, &.tooltipped-se, &.tooltipped-ne': {
    '&::after': {
      marginLeft: gap,
    },
  },
  '&.tooltipped-n, &.tooltipped-ne, &.tooltipped-nw': {
    '&::after': {
      marginBottom: gap,
    },
  },
  '&.tooltipped-w, &.tooltipped-sw, &.tooltipped-nw': {
    '&::after': {
      marginRight: gap,
    },
  },
};

export default function Tooltip({ children, sx, ...props }) {
  const { position, ...sxRest } = sx || {};

  if (position === 'absolute')
    return (
      <Box sx={{ display: 'inline-flex' }}>
        <Box sx={{ ...sxRest, visibility: 'hidden' }}>{children}</Box>
        <TooltipV1 sx={{ ...replaceMargin, ...sx }} {...props}>
          {children}
        </TooltipV1>
      </Box>
    );

  return (
    <TooltipV1 sx={{ ...replaceMargin, ...sx }} {...props}>
      {children}
    </TooltipV1>
  );
}
</file>

<file path="pages/interface/components/Turnstile/index.js">
import Script from 'next/script';
import { useCallback, useEffect, useRef, useState } from 'react';

import { Box, Text, useConfirm } from '@/TabNewsUI';
import webserver from 'infra/webserver';

const BLOCKED_RESPONSE_MESSAGE = 'Requisição bloqueada pelo Firewall.';
const BLOCKED_RESPONSE_ACTION = 'Verifique seu equipamento e os dados enviados.';

const sitekey = process.env.NEXT_PUBLIC_CLOUDFLARE_TURNSTILE_SITE_KEY;

const turnstile = {
  ignore: false,
  queue: [],
  check: () => {},
};

export default function Turnstile() {
  const [isInteractive, setIsInteractive] = useState(false);
  const widgetRef = useRef(null);
  const widgetIdRef = useRef(null);

  useEffect(() => {
    if (!sitekey || window.onloadTurnstileCallback) return;

    replaceOriginalFetch();

    const turnstileOptions = {
      sitekey,
      theme: 'dark',
      language: 'pt-BR',
      appearance: 'interaction-only',
      execution: 'execute',
      callback: refetchQueue,
      'before-interactive-callback': () => setIsInteractive(true),
      'after-interactive-callback': () => setIsInteractive(false),
      'error-callback': rejectQueue,
      'unsupported-callback': rejectQueue,
      'timeout-callback': rejectQueue,
    };

    window.onloadTurnstileCallback = () => {
      turnstile.check = () => {
        if (turnstile.ignore) rejectQueue(new Error('Ignorado pelo usuário.'));

        if (!widgetIdRef.current) {
          widgetIdRef.current = window.turnstile.render(widgetRef.current, turnstileOptions);
        }

        window.turnstile.execute(widgetRef.current, turnstileOptions);
      };

      if (turnstile.queue.length) turnstile.check();
    };
  }, []);

  const confirm = useConfirm();

  const handleCancel = useCallback(async () => {
    if (
      !(await confirm({
        title: 'Executando verificação de segurança!',
        content: 'Recomendamos continuar para não bloquear funcionalidades do TabNews.',
        confirmButtonContent: 'Continuar',
        cancelButtonContent: 'Ignorar',
      }))
    ) {
      turnstile.ignore = true;
      setIsInteractive(false);
      window.turnstile.remove(widgetIdRef.current);
      turnstile.check();
    }
  }, [confirm]);

  return (
    <Box
      sx={{
        display: isInteractive ? 'block' : 'none',
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.7)',
        border: '1px solid grey',
        zIndex: '1',
      }}
      onClick={handleCancel}>
      <Box sx={{ position: 'relative', height: '50vh' }}>
        <Text
          sx={{
            color: 'white',
            position: 'absolute',
            textAlign: 'center',
            width: '100%',
            fontSize: 2,
            fontWeight: 'bold',
            bottom: 4,
          }}>
          Executando verificação de segurança...
        </Text>
      </Box>
      <Box
        ref={widgetRef}
        sx={{
          display: 'flex',
          flexWrap: 'nowrap',
          alignItems: 'center',
          justifyContent: 'center',
        }}></Box>
      <Script src="https://challenges.cloudflare.com/turnstile/v0/api.js?onload=onloadTurnstileCallback&render=explicit" />
    </Box>
  );
}

function replaceOriginalFetch() {
  const originalFetch = window.fetch;

  window.fetch = async function (...args) {
    let response = await originalFetch(...args);

    if (isChallenged(response)) {
      await new Promise((resolve, reject) => {
        turnstile.queue.push({ resolve, reject });
        if (turnstile.queue.length === 1) turnstile.check();
      })
        .then(() => (response = originalFetch(...args)))
        .catch((error) => {
          const errorMessage = typeof error === 'string' ? error : error.message;
          console.warn(`[Turnstile] ${errorMessage}`);
        });
    }

    return checkFirewallResponse(response);
  };
}

function checkFirewallResponse(response) {
  if (!isBlocked(response)) return response;

  const { headers } = response;

  return new Response(
    JSON.stringify({
      message: BLOCKED_RESPONSE_MESSAGE,
      action: BLOCKED_RESPONSE_ACTION,
      error_id: headers?.has('cf-ray') ? `cf-ray: ${headers.get('cf-ray')}` : '',
      blocked: true,
    }),
    response,
  );
}

function isChallenged({ headers }) {
  // Cloudflare returns a 403 status code with a `cf-mitigated: challenge`
  // header when the request fails the challenge.
  // Return `true` for simulate interactive challenges in development mode.
  // return true;
  return headers?.has('cf-mitigated') && headers.get('cf-mitigated') === 'challenge';
}

function isBlocked({ status, headers }) {
  // Cloudflare returns a 403 status code without Vercel headers when the request is blocked.
  return status === 403 && webserver.isProduction && !headers?.has('x-vercel-id');
}

function refetchQueue() {
  while (turnstile.queue.length) {
    turnstile.queue.shift().resolve();
  }
}

function rejectQueue(e) {
  while (turnstile.queue.length) {
    turnstile.queue.shift().reject(e);
  }
}
</file>

<file path="pages/interface/components/UserHeader/index.js">
import { Box, CounterLabel, Heading, TabNav, TabNavLink } from '@/TabNewsUI';

export default function UserHeader({ username, children, rootContentCount, childContentCount, adContentCount }) {
  return (
    <>
      <Box sx={{ width: '100%', display: 'flex', flexWrap: 'wrap', gap: 2, mb: 3 }}>
        <Heading as="h1" sx={{ wordBreak: 'break-word' }}>
          {username}
        </Heading>
        {children}
      </Box>

      <TabNav sx={{ width: '100%', mb: 3 }}>
        <TabNavLink href={`/${username}`}>Perfil</TabNavLink>

        <TabNavLink
          href={{
            pathname: '/[username]/conteudos/[page]',
            query: { username, page: 1 },
          }}>
          Publicações {!!rootContentCount && <CounterLabel>{rootContentCount}</CounterLabel>}
        </TabNavLink>

        <TabNavLink
          href={{
            pathname: '/[username]/comentarios/[page]',
            query: { username, page: 1 },
          }}>
          Comentários {!!childContentCount && <CounterLabel>{childContentCount}</CounterLabel>}
        </TabNavLink>

        <TabNavLink
          href={{
            pathname: '/[username]/classificados/[page]',
            query: { username, page: 1 },
          }}>
          Classificados {!!adContentCount && <CounterLabel>{adContentCount}</CounterLabel>}
        </TabNavLink>
      </TabNav>
    </>
  );
}
</file>

<file path="pages/interface/components/UserList/index.js">
import { Box, Label, Link, Pagination, PastTime, SkeletonLoader, Text } from '@/TabNewsUI';

export default function UserListPaginated({ userList, pagination }) {
  const listNumberStart = pagination.perPage * (pagination.currentPage - 1) + 1;

  return (
    <>
      {userList?.length ? (
        <UserList userList={userList} listNumberStart={listNumberStart} />
      ) : (
        <UserListLoading pagination={pagination} />
      )}

      <Pagination {...pagination} />
    </>
  );
}

function UserList({ userList, listNumberStart }) {
  return (
    <Box
      as="ol"
      sx={{
        display: 'grid',
        gap: '0.5rem',
        gridTemplateColumns: 'min-content minmax(0, 1fr)',
        padding: 0,
        margin: 0,
      }}
      key={`user-list-${listNumberStart}`}
      start={listNumberStart}>
      {userList.map((userObject) => (
        <UserListItem key={userObject.id} user={userObject} />
      ))}
    </Box>
  );
}

function UserListItem({ user }) {
  function getTabCoinsText(count) {
    return count > 1 || count < -1 ? `${count} tabcoins` : `${count} tabcoin`;
  }

  function formatUpdatedAt(date) {
    return `Atualizado há ${date}`;
  }

  return (
    <Box
      as="li"
      sx={{
        display: 'contents',
        ':before': {
          content: 'counter(list-item) "."',
          counterIncrement: 'list-item',
          fontWeight: 'semibold',
          width: 'min-content',
          marginLeft: 'auto',
        },
      }}>
      <Box>
        <Box sx={{ wordBreak: 'break-word' }}>
          <Link
            sx={{
              fontWeight: 'semibold',
              ':link': {
                color: 'fg.default',
              },
              ':visited': {
                color: 'fg.subtle',
              },
            }}
            href={`/${user.username}`}>
            {user.username}
            {user.features.includes('nuked') && (
              <Label variant="danger" sx={{ ml: 1 }}>
                nuked
              </Label>
            )}
          </Link>
        </Box>
        {user.description && (
          <Text
            sx={{
              display: 'block',
              overflow: 'auto',
              wordWrap: 'break-word',
              fontWeight: 'normal',
              fontStyle: 'italic',
              fontSize: 1,
            }}>
            {user.description}
          </Text>
        )}
        <Box
          sx={{
            display: 'grid',
            gap: 1,
            gridTemplateColumns:
              'max-content max-content max-content max-content minmax(20px, max-content) max-content max-content',
            fontSize: 0,
            whiteSpace: 'nowrap',
            color: 'neutral.emphasis',
          }}>
          <PastTime formatText={formatUpdatedAt} direction="ne" date={user.updated_at} />
          {' · '}
          <Text>{getTabCoinsText(user.tabcoins)}</Text>
          {' · '}
          <Text>{user.tabcash} tabcash</Text>
        </Box>
      </Box>
    </Box>
  );
}

function UserListLoading({ pagination }) {
  const itemHeightRem = 3.13;
  const listHeightRem = itemHeightRem * pagination.perPage;

  return (
    <SkeletonLoader
      title="Carregando usuários..."
      style={{ height: `${listHeightRem}rem`, width: '100%' }}
      uniqueKey="user-list-loading">
      {Array.from({ length: pagination.perPage }).map((_, i) => (
        <UserListItemLoading key={i} index={i} />
      ))}
    </SkeletonLoader>
  );
}

function UserListItemLoading({ index }) {
  const spaceBetweenItems = 9;
  const spaceBetweenRows = 8;
  const textHeight = 16;
  const usernameY = index * (textHeight + spaceBetweenItems) * 2 + 4;

  return (
    <>
      <rect x="28" y={usernameY} rx="5" ry="5" width="140" height={textHeight} />
      <rect x="28" y={usernameY + spaceBetweenRows + textHeight} rx="5" ry="5" width="240" height="12" />
    </>
  );
}
</file>

<file path="pages/interface/hooks/useCollapse/index.js">
import { useState } from 'react';

export default function useCollapse({
  childrenDeepCount = 0,
  childrenList,
  renderIntent = 20,
  renderIncrement = 10,
  minimalSubTree = 3,
}) {
  const [childrenState, setChildrenState] = useState(() =>
    computeStates({
      children: childrenList,
      renderIntent,
      childrenDeepCount,
      minimalSubTree,
    }),
  );

  function handleExpand(id) {
    setChildrenState((lastState) => {
      const childIndex = lastState.findIndex((child) => child.id === id);
      let grouperIndex = childIndex;
      const childrenToExpand = [];

      while (lastState[grouperIndex]?.renderIntent === 0) {
        childrenToExpand.push(lastState[grouperIndex]);
        grouperIndex += 1;
      }

      return [
        ...lastState.slice(0, childIndex),
        ...computeStates({
          children: childrenToExpand,
          renderIntent: renderIncrement,
          childrenDeepCount: lastState[childIndex].groupedCount,
        }),
        ...lastState.slice(grouperIndex),
      ];
    });
  }

  function handleCollapse(id) {
    setChildrenState((lastState) => {
      const childIndex = lastState.findIndex((child) => child.id === id);
      const children = [...lastState];

      if (childIndex < 0) return children;

      children[childIndex].renderIntent = 0;
      children[childIndex].renderShowMore = true;

      if (lastState[childIndex + 1]?.renderIntent === 0) {
        children[childIndex].groupedCount += lastState[childIndex + 1].groupedCount;
        children[childIndex + 1].renderShowMore = false;
      }

      let groupedIndex = childIndex - 1;

      while (lastState[groupedIndex]?.renderIntent === 0) {
        if (groupedIndex === childIndex - 1) {
          children[childIndex].renderShowMore = false;
        }

        children[groupedIndex].groupedCount += children[childIndex].groupedCount;
        groupedIndex -= 1;
      }

      return children;
    });
  }

  return {
    childrenState,
    handleCollapse,
    handleExpand,
  };
}

function computeStates({ children, renderIntent, childrenDeepCount, lastState = [], minimalSubTree = 3 }) {
  if (!children?.length && childrenDeepCount === 0) return [];

  let remaining = renderIntent;
  let treeIntent = minimalSubTree;
  let grouperIndex = null;
  let groupedCount = 0;
  let deltaIndex = 0;

  const newStates = children.map((child, index) => {
    if (lastState.length > 0) {
      if (lastState[index + deltaIndex]?.id === child.id && child.id) {
        const childLastState = lastState[index + deltaIndex];
        remaining -= childLastState.renderIntent;
        if (childLastState.renderShowMore) grouperIndex = index;
        if (childLastState.renderIntent) grouperIndex = null;

        return { ...childLastState, ...child };
      }

      // in case any child has changed order
      const childLastStateIndex = lastState.findIndex((childLastState) => childLastState.id === child.id && child.id);

      if (childLastStateIndex > -1) {
        deltaIndex = childLastStateIndex - index;
        remaining -= lastState[childLastStateIndex].renderIntent;
        if (lastState[childLastStateIndex].renderShowMore) grouperIndex = index;
        if (lastState[childLastStateIndex].renderIntent) grouperIndex = null;

        return { ...lastState[childLastStateIndex], ...child };
      }
    }

    if (remaining > 0) {
      if (remaining < treeIntent) {
        treeIntent = remaining;
      }
      const renderIntent = treeIntent > child.children_deep_count ? 1 + child.children_deep_count : treeIntent;
      remaining -= renderIntent;

      return {
        ...child,
        renderIntent: renderIntent,
        groupedCount: 1 + child.children_deep_count,
        renderShowMore: false,
      };
    }

    if (grouperIndex === null) {
      grouperIndex = index;
      remaining -= 1;

      return {
        ...child,
        renderIntent: 0,
        groupedCount: 1 + child.children_deep_count,
        renderShowMore: true,
      };
    }

    groupedCount += 1 + child.children_deep_count;

    return {
      ...child,
      renderIntent: 0,
      groupedCount: 1 + child.children_deep_count,
      renderShowMore: false,
    };
  });

  for (const child of newStates) {
    if (remaining < 1) break;

    if (child.groupedCount - child.renderIntent > remaining) {
      child.renderIntent += remaining;
      remaining = 0;
    } else {
      remaining -= child.groupedCount - child.renderIntent;
      child.renderIntent = child.groupedCount;
    }
  }

  if (grouperIndex !== null) {
    newStates[grouperIndex].groupedCount += groupedCount;
  }

  return newStates;
}
</file>

<file path="pages/interface/hooks/useMediaQuery/index.js">
import { useEffect, useState } from 'react';

export default function useMediaQuery(query) {
  const [matches, setMatches] = useState(false);

  useEffect(() => {
    const media = window.matchMedia(query);
    setMatches(media.matches);
    const listener = () => setMatches(media.matches);
    window.addEventListener('resize', listener);
    return () => window.removeEventListener('resize', listener);
  }, [query]);

  return matches;
}
</file>

<file path="pages/interface/hooks/useUser/index.js">
import { createContext, useCallback, useContext, useEffect, useState } from 'react';

const userEndpoint = '/api/v1/user';
const sessionEndpoint = '/api/v1/sessions';
const refreshInterval = 600000; // 10 minutes

const UserContext = createContext({
  user: null,
  isLoading: true,
  error: undefined,
  fetchUser: async () => {},
  logout: async () => {},
});

export function UserProvider({ children }) {
  const [user, setUser] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(undefined);

  const fetchUser = useCallback(async () => {
    try {
      const response = await fetch(userEndpoint);
      const responseBody = await response.json();

      if (response.status === 200) {
        const fetchedUser = responseBody;

        const cachedUserProperties = {
          id: responseBody.id,
          username: responseBody.username,
          description: responseBody.description,
          features: responseBody.features,
          tabcoins: responseBody.tabcoins,
          tabcash: responseBody.tabcash,
          cacheTime: Date.now(),
        };

        setUser(fetchedUser);
        localStorage.setItem('user', JSON.stringify(cachedUserProperties));
      } else if ([401, 403].includes(response.status) && !responseBody?.blocked) {
        setUser(null);
        localStorage.removeItem('user');
      } else {
        const error = new Error(responseBody.message);
        error.status = response.status;
        throw error;
      }
    } catch (error) {
      setError(error);
    }
  }, []);

  useEffect(() => {
    const storedUser = localStorage.getItem('user');
    (async () => {
      if (storedUser && isLoading) {
        setUser(JSON.parse(storedUser));
        await fetchUser();
      }
      setIsLoading(false);
    })();

    if (isLoading) return;

    function onFocus() {
      const cachedUser = JSON.parse(localStorage.getItem('user'));
      setUser((user) => (cachedUser?.username ? { ...user, ...cachedUser } : null));
      if (refreshInterval < Date.now() - cachedUser?.cacheTime) fetchUser();
    }
    addEventListener('focus', onFocus);

    return () => removeEventListener('focus', onFocus);
  }, [fetchUser, isLoading]);

  const logout = useCallback(async () => {
    try {
      const response = await fetch(sessionEndpoint, {
        method: 'DELETE',
      });

      if (response.status === 200) {
        localStorage.clear();
        setUser(null);
      }
    } catch (error) {
      setError(error);
    }
  }, []);

  const userContextValue = {
    user,
    isLoading,
    error,
    fetchUser,
    logout,
  };

  return <UserContext.Provider value={userContextValue}>{children}</UserContext.Provider>;
}

export default function useUser() {
  return useContext(UserContext);
}
</file>

<file path="pages/interface/utils/email-suggestion.js">
const domains = {
  'bol.com': 'bol.com.br',
  'dmail.com': 'gmail.com',
  'gail.com': 'gmail.com',
  'gail.com.ar': 'gmail.com',
  'gamail.com': 'gmail.com',
  'gamail.com.ar': 'gmail.com',
  'gamial.com': 'gmail.com',
  'gamial.com.ar': 'gmail.com',
  'gamil.com': 'gmail.com',
  'gamil.com.ar': 'gmail.com',
  'gemail.com': 'gmail.com',
  'ggmail.com': 'gmail.com',
  'ggmail.com.ar': 'gmail.com',
  'gil.com': 'gmail.com',
  'gimail.com': 'gmail.com',
  'gmad.com,': 'gmail.com',
  'gmai.com': 'gmail.com',
  'gmai.com.ar': 'gmail.com',
  'gmaiil.com': 'gmail.com',
  'gmaiil.com.ar': 'gmail.com',
  gmail: 'gmail.com',
  'gmail.': 'gmail.com',
  'gmail.c': 'gmail.com',
  'gmail.cim': 'gmail.com',
  'gmail.cin': 'gmail.com',
  'gmail.cm': 'gmail.com',
  'gmail.cm.ar': 'gmail.com',
  'gmail.cm.br': 'gmail.com',
  'gmail.co': 'gmail.com',
  'gmail.cok': 'gmail.com',
  'gmail.com.': 'gmail.com',
  'gmail.com.ar': 'gmail.com',
  'gmail.com.b': 'gmail.com',
  'gmail.com.br': 'gmail.com',
  'gmail.comm': 'gmail.com',
  'gmail.con': 'gmail.com',
  'gmail.coom': 'gmail.com',
  'gmail.cpm': 'gmail.com',
  'gmailc.mo': 'gmail.com',
  'gmailc.om': 'gmail.com',
  'gmaild.com': 'gmail.com',
  'gmaild.com.ar': 'gmail.com',
  'gmaile.com': 'gmail.com',
  'gmaile.com.ar': 'gmail.com',
  'gmailee.com': 'gmail.com',
  'gmaill.com': 'gmail.com',
  'gmaill.com.ar': 'gmail.com',
  'gmain.com': 'gmail.com',
  'gmain.com.ar': 'gmail.com',
  'gmaio.com': 'gmail.com',
  'gmaio.com.ar': 'gmail.com',
  'gmaiq.com': 'gmail.com',
  'gmakl.com': 'gmail.com',
  'gmal.com': 'gmail.com',
  'gmal.com.ar': 'gmail.com',
  'gmali.com': 'gmail.com',
  'gmali.com.ar': 'gmail.com',
  'gmanil.com': 'gmail.com',
  'gmanil.com.ar': 'gmail.com',
  'gmaol.com': 'gmail.com',
  'gmaol.com.ar': 'gmail.com',
  'gmaqil.com': 'gmail.com',
  'gmaqil.com.ar': 'gmail.com',
  'gmaul.com': 'gmail.com',
  'gmeil.com': 'gmail.com',
  'gmeil.com.ar': 'gmail.com',
  'gmiail.com': 'gmail.com',
  'gmial.com': 'gmail.com',
  'gmial.com.ar': 'gmail.com',
  'gmil.co': 'gmail.com',
  'gmil.com': 'gmail.com',
  'gmil.com.ar': 'gmail.com',
  'gmmail.com': 'gmail.com',
  'gmmail.com.ar': 'gmail.com',
  'gmnail.com': 'gmail.com',
  'gmol.com': 'gmail.com',
  'gmsil.com': 'gmail.com',
  'gmsil.com.ar': 'gmail.com',
  'gnail.com': 'gmail.com',
  'hatmail.com': 'hotmail.com',
  'hitmail.com': 'hotmail.com',
  'hmail.com': 'gmail.com',
  'hmail.com.ar': 'gmail.com',
  'hoimail.com': 'hotmail.com',
  'hoitmail.com': 'hotmail.com',
  'homail.com': 'hotmail.com',
  'homtail.com': 'hotmail.com',
  'homtmail.com': 'hotmail.com',
  'hootmail.com': 'hotmail.com',
  'hormail.com': 'hotmail.com',
  'hotail.com': 'hotmail.com',
  'hotamail.com': 'hotmail.com',
  'hotamil.com': 'hotmail.com',
  'hotma.com': 'hotmail.com',
  'hotmaail.com': 'hotmail.com',
  'hotmai.com': 'hotmail.com',
  'hotmaiil.com': 'hotmail.com',
  'hotmail.cim': 'hotmail.com',
  'hotmail.cin': 'hotmail.com',
  'hotmail.cm': 'hotmail.com',
  'hotmail.co': 'hotmail.com',
  'hotmail.com.com': 'hotmail.com',
  'hotmail.comm': 'hotmail.com',
  'hotmail.con': 'hotmail.com',
  'hotmail.coom': 'hotmail.com',
  'hotmail.net': 'hotmail.com',
  'hotmail.ocm': 'hotmail.com',
  'hotmaill.com': 'hotmail.com',
  'hotmailt.com': 'hotmail.com',
  'hotmal.com': 'hotmail.com',
  'hotmali.com': 'hotmail.com',
  'hotmi.com': 'hotmail.com',
  'hotmiail.com': 'hotmail.com',
  'hotmial.com': 'hotmail.com',
  'hotmil.co': 'hotmail.com',
  'hotmil.com': 'hotmail.com',
  'hotmmail.com': 'hotmail.com',
  'hotmqil.com': 'hotmail.com',
  'hotmsil.com': 'hotmail.com',
  'hotnail.ckm': 'hotmail.com',
  'hotnail.com': 'hotmail.com',
  'hotomail.com': 'hotmail.com',
  'hotrmail.com': 'hotmail.com',
  'hoymail.com': 'hotmail.com',
  'htmail.com': 'hotmail.com',
  'htoamil.com': 'hotmail.com',
  'htomail.com': 'hotmail.com',
  'mail.com': 'gmail.com',
  'mgil.com': 'gmail.com',
  'otmail.com': 'hotmail.com',
  'outlok.com': 'outlook.com',
  'outloo.com': 'outlook.com',
  'outlook.cm': 'outlook.com',
  'outlook.co': 'outlook.com',
  'outlook.comm': 'outlook.com',
  'outlook.con': 'outlook.com',
  'prontomail.com': 'protonmail.com',
  'protonmil.com': 'protonmail.com',
  'yaho.com': 'yahoo.com',
  'yahoo.comm': 'yahoo.com',
  'yahoo.con': 'yahoo.com',
  'yahoo.coom': 'yahoo.com',
  'ygmail.com': 'gmail.com',
  'ygmail.com.ar': 'gmail.com',
  'zipmail.combr': 'zipmail.com.br',
};

export default function suggestEmail(typedEmail) {
  const userName = typedEmail.split('@')[0];
  const typedDomain = typedEmail.split('@')[1];

  const rightDomain = domains[typedDomain];

  if (rightDomain) {
    return `${userName}@${rightDomain}`;
  }

  return false;
}
</file>

<file path="pages/interface/utils/error-message.js">
export default function createErrorMessage(responseBody, { omitErrorId = false } = {}) {
  const { message, action, error_id } = responseBody || {};
  const errorMessages = [];

  if (message) {
    errorMessages.push(message);
  }

  if (action && action !== "Informe ao suporte o valor encontrado no campo 'error_id'.") {
    errorMessages.push(action);
  }

  if (error_id && !omitErrorId) {
    errorMessages.push(`Informe ao suporte o valor (${error_id})`);
  }

  return errorMessages.join(' ') || 'Erro desconhecido. Tente novamente mais tarde.';
}
</file>

<file path="pages/interface/utils/is-valid-json-string.js">
export default function isValidJsonString(jsonString) {
  if (!(jsonString && typeof jsonString === 'string')) {
    return false;
  }

  try {
    JSON.parse(jsonString);
    return true;
  } catch (error) {
    return false;
  }
}
</file>

<file path="pages/interface/utils/nd-json-stream.js">
import { isValidJsonString } from 'pages/interface';

export default function processNdJsonStream(stream, cb) {
  const reader = stream.getReader();
  const decoder = new TextDecoder();
  let partialData = '';

  const readChunk = () => {
    reader.read().then(({ done, value }) => {
      if (done) return;
      partialData += decoder.decode(value, { stream: true });

      partialData = processChunk(partialData, cb);

      readChunk();
    });
  };

  readChunk();
}

function processChunk(chunk, cb) {
  let partialData = chunk;
  let delimiterIndex = -1;

  if (isValidJsonString(partialData)) {
    cb(JSON.parse(partialData));
    return '';
  }

  while ((delimiterIndex = partialData.lastIndexOf('\n')) !== -1) {
    partialData = partialData.slice(0, delimiterIndex);

    if (isValidJsonString(partialData)) {
      cb(JSON.parse(partialData));

      return processChunk(chunk.slice(delimiterIndex + 1), cb);
    }
  }

  return chunk;
}
</file>

<file path="pages/interface/index.js">
export { default as Analytics } from './components/Analytics';
export { DefaultHead, default as Head } from './components/Head';
export { default as useCollapse } from './hooks/useCollapse';
export { default as useMediaQuery } from './hooks/useMediaQuery';
export { UserProvider, default as useUser } from './hooks/useUser';
export { default as suggestEmail } from './utils/email-suggestion';
export { default as createErrorMessage } from './utils/error-message';
export { default as isValidJsonString } from './utils/is-valid-json-string';
export { default as processNdJsonStream } from './utils/nd-json-stream';
</file>

<file path="pages/login/index.public.js">
import { email, password, useForm } from '@tabnews/forms';
import { tryParseUrl } from '@tabnews/helpers';
import { FormField } from '@tabnews/ui';
import { useRouter } from 'next/router';
import { useEffect } from 'react';

import { Box, ButtonWithLoader, DefaultLayout, Flash, Heading, Link, Text } from '@/TabNewsUI';
import { createErrorMessage, useUser } from 'pages/interface';

const formConfig = {
  email,
  password,
  globalMessage: '',
  loading: false,
};

export default function Login() {
  const { user } = useUser();
  const router = useRouter();

  useEffect(() => {
    if (!router.isReady || !user?.id) return;

    const url = tryParseUrl(router.query.redirect);

    if (url.origin === location?.origin) {
      router.replace(url.pathname);
    } else {
      router.replace('/');
    }
  }, [user, router]);

  return (
    <DefaultLayout containerWidth="small" metadata={{ title: 'Login', canonical: '/login' }}>
      <Heading as="h1" sx={{ mb: 3 }}>
        Login
      </Heading>
      <LoginForm />
    </DefaultLayout>
  );
}

function LoginForm() {
  const { fetchUser } = useUser();
  const { getFieldProps, handleSubmit, state, updateState } = useForm(formConfig);
  const globalErrorMessage = state.globalMessage.error;

  async function onSubmit(data) {
    updateState({
      globalMessage: { error: null },
      loading: { value: true },
    });

    const { email, password } = data;

    try {
      const response = await fetch(`/api/v1/sessions`, {
        method: 'POST',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: email,
          password: password,
        }),
      });

      const responseBody = await response.json();

      if (response.status === 201) {
        fetchUser();
        return;
      }

      if (response.status === 400) {
        const key = ['email', 'password'].includes(responseBody.key) ? responseBody.key : 'globalMessage';

        updateState({
          [key]: { error: createErrorMessage(responseBody) },
          loading: { value: false },
        });
        return;
      }

      updateState({
        globalMessage: { error: createErrorMessage(responseBody) },
        loading: { value: false },
      });
    } catch (error) {
      updateState({
        globalMessage: { error: 'Não foi possível se conectar ao TabNews. Por favor, verifique sua conexão.' },
        loading: { value: false },
      });
    }
  }

  return (
    <form style={{ width: '100%' }} onSubmit={handleSubmit(onSubmit)}>
      <FormField {...getFieldProps('email')} />
      <FormField {...getFieldProps('password')} />

      {globalErrorMessage && (
        <Flash variant="danger" sx={{ mt: 3 }}>
          {globalErrorMessage}
        </Flash>
      )}

      <ButtonWithLoader
        variant="primary"
        size="large"
        type="submit"
        sx={{ width: '100%', mt: 3 }}
        aria-label="Login"
        isLoading={state.loading.value}>
        Login
      </ButtonWithLoader>

      <Box sx={{ mt: 6, width: '100%', textAlign: 'center', fontSize: 1 }} display="flex" flexDirection="column">
        <Text>
          Novo no TabNews? <Link href="/cadastro">Crie sua conta aqui.</Link>
        </Text>
        <Text>
          Esqueceu sua senha? <Link href="/cadastro/recuperar">Clique aqui.</Link>
        </Text>
      </Box>
    </form>
  );
}
</file>

<file path="pages/moderacao/usuarios/[page]/index.public.js">
import { useRouter } from 'next/router';
import parseLinkHeader from 'parse-link-header';
import { useEffect, useState } from 'react';
import useSWR from 'swr';

import { DefaultLayout, UserList } from '@/TabNewsUI';
import { useUser } from 'pages/interface';

const basePath = '/moderacao/usuarios';

export default function UsersPage() {
  const { user, isLoading: userIsLoading } = useUser();
  const router = useRouter();
  const [pagination, setPagination] = useState({
    currentPage: 1,
    lastPage: 1,
    previousPage: null,
    nextPage: null,
    perPage: 30,
    basePath,
  });

  const { page } = router.query;
  const isLoading = userIsLoading || !page;
  const shouldFetch = !isLoading && user?.features?.includes('read:user:list');

  const {
    data: { body: userListFound, headers },
  } = useSWR(shouldFetch ? `/api/v1/users?page=${page}` : null, {
    fallbackData: { body: [], headers: {} },
    revalidateOnFocus: false,
  });

  useEffect(() => {
    if (isLoading || shouldFetch) return;

    router.replace('/');
  }, [isLoading, router, shouldFetch]);

  useEffect(() => {
    if (!shouldFetch) return;

    const linkHeader = parseLinkHeader(headers.get?.('Link'));

    const newPagination = {
      currentPage: page || 1,
      lastPage: linkHeader?.last?.page,
      previousPage: linkHeader?.prev?.page,
      nextPage: linkHeader?.next?.page,
      perPage: linkHeader?.last?.per_page || 30,
      basePath,
    };

    if (linkHeader && userListFound.length === 0 && newPagination.currentPage > 1) {
      router.replace(`${basePath}/${newPagination.lastPage}`);
      return;
    }

    if (linkHeader && newPagination.currentPage !== pagination.currentPage) {
      setPagination(newPagination);
    }
  }, [headers, page, pagination.currentPage, router, shouldFetch, userListFound.length]);

  return (
    <DefaultLayout
      metadata={{
        title: `Página ${pagination.currentPage} · Usuários`,
        description: 'Lista de usuários do TabNews.',
      }}>
      <UserList userList={userListFound} pagination={pagination} />
    </DefaultLayout>
  );
}
</file>

<file path="pages/museu/evolucao-do-tabnews/index.public.js">
import { Box, DefaultLayout, Heading, Link, Text, Viewer } from '@/TabNewsUI';

export default function Page() {
  const body = `Muitas pessoas conheceram o TabNews após o [vídeo de lançamento oficial no YouTube](https://www.youtube.com/watch?v=bYBVCxVwrdY), no dia 21/12/2022. Nesta página você encontrará a história anterior. Verá como foi que o TabNews surgiu e evoluiu, quais foram as ideias iniciais, quem participou do processo, quanto tempo levou e até onde conseguiu chegar no momento do lançamento oficial.

  ## 1. Antes de 17/10/2020
  Aqui é onde tudo começa, a origem do projeto. Este foi o <a href="https://github.com/filipedeschamps/tabnews.com.br/wiki/001.-Um-grande-problema">texto</a> que o Filipe Deschamps fez sobre a ideia do TabNews:

  > Tenho uma [Newsletter](https://filipedeschamps.com.br/newsletter) gratuita que faço com meu irmão [Gustavo Deschamps](https://github.com/gustavodeschamps), onde apesar de ter uma aceitação [muito acima do que a gente esperava](https://youtu.be/Jau0Rn_ADxo), ao mesmo tempo é um material que dá **muito trabalho** para ser produzido e ficamos **extremamente frustrados** quando, por exemplo, um mesmo provedor de email decide entregar esse material para alguns usuários, mas não para outros, e sem padrão algum. E por conta disso, decidimos criar o **TabNews** para resolver esse problema, mas **spoiler alert**, não resolve, continue lendo para entender.

  ## 2. 17/10/2020
  No mesmo dia, houve a [compra do domínio](https://github.com/filipedeschamps/tabnews.com.br/wiki/002.-Registro-do-dom%C3%ADnio) [tabnews.com.br](https://www.tabnews.com.br):
  
  > Como todo bom nerd, sem nem mesmo a ideia ter sido completamente formada, a gente foi lá e comprou o domínio [tabnews.com.br](https://tabnews.com.br). Numa breve conversa, chegamos numa ideia de um site que fique atualizado e trazendo **notícias** (news) em tempo-real para que a pessoa deixe ele aberto numa **aba** (tab) no navegador, e com isso o Gustavo sugeriu o nome **TabNews**. O engraçado é que toda hora a gente tentava fugir desse nome, mas a gente não conseguia, é muito simples de entender, decorar e escrever.  
  
  ## 3. 25/12/2020
  A data oficial da criação do [repositório do TabNews no GitHub](https://github.com/filipedeschamps/tabnews.com.br).

  ## 4. 30/12/2020
  A [primeira issue](https://github.com/filipedeschamps/tabnews.com.br/issues/1) foi criada no repositório. Foi uma issue de origem, fala sobre porque o projeto foi criado, de onde o nome veio e outras coisas.

  ## 5. 07/05/2021
  A primeira sugestão de layout para o TabNews:

  ![Uma lista de cards simples, ocupando apenas o lado esquerdo da página. Cada card com título, TabCoins e a data da publicação.](https://user-images.githubusercontent.com/4248081/117865517-e6891680-b24a-11eb-8ba8-fddd4f3f26de.png)
  
  ## 6. 11/05/2021
  O [primeiro pull request](https://github.com/filipedeschamps/tabnews.com.br/pull/2) no repositório: \`layout: trying a more "Twitter" style\`.
  ![Uma lista de cards, cada um com o título e um parágrafo do corpo, TabCoins, quantidade de comentários, data de publicação e autor.](https://i.imgur.com/dXACkkr.png) 
  
  ## 7. Entre 11/05 e 18/05/2021
  Sugestão de layout número 4, desenvolvido pelo Filipe:
  ![Uma lista na metade esquerda da tela, cada item com o título da publicação, TabCoins, data de publicação e autor. Do lado direito, a publicação selecionada e seus comentários.](https://user-images.githubusercontent.com/4248081/118160451-2c70e680-b3d3-11eb-9f6e-96cd1b579811.png)

  No dia 13/05/2021, ao mostrar o layout acima para o Guga e a Renata, [que mencionaram a simplicidade do Hacker News](https://github.com/filipedeschamps/tabnews.com.br/wiki/014.-Guga-e-Renata-tiveram-excelentes-ideias):
  > (...) ao mostrar o HackerNews para a Renata, ela falou que de fato uma coisa legal é ler de forma **linear** as notícias, e não há quebra de linha, o que de fato faz o scan das notícias ser muito rápido. E em cima disso, o Guga tocou em algo muito importante: **o valor dos comentários**.

  Então vieram as próximas sugestões de layout do Filipe, mais próximas da [interface presente no dia do lançamento oficial](https://web.archive.org/web/20221123031951/https://www.tabnews.com.br/).
  ![Uma lista de itens de conteúdos. À esquerda de cada item, a quantidade de TabCoins dentro de um quadrado amarelo. Em cada item, o título, quantidade de comentários, data de lançamento e autor.](https://user-images.githubusercontent.com/4248081/118731117-8ca9c300-b7ed-11eb-8724-dbe921e1c877.png)
  ![Similar à proposta anterior, porém com o início do melhor comentário aparecendo na mesma linha de informações da data de publicação, autor e quantidade de comentaŕios.](https://user-images.githubusercontent.com/4248081/118731136-96332b00-b7ed-11eb-8b94-4835b294b108.png)
  ![Similar à proposta anterior, porém agora existe uma ordem nos conteúdos. O primeiro está em destaque com a quantidade de TabCoins em um retângulo amarelo, o segundo em um retângulo escuro, o terceiro em um marrom e o quarto em diante num cinza claro. Isso faz menção às medalhas de ouro, prata e bronze.](https://user-images.githubusercontent.com/4248081/118731162-a3e8b080-b7ed-11eb-83ba-dcf7229d0ffc.png)
  ![Similar à proposta anterior, porém apenas o primeiro conteúdo está com os TabCoins em destaque (amarelo), os outros são todos cinza claro.](https://user-images.githubusercontent.com/4248081/118731182-b1059f80-b7ed-11eb-9cc0-46559ddf9871.png)

  ## 8. 20/05/2021
  O [primeiro design de dentro da publicação](https://github.com/filipedeschamps/tabnews.com.br/wiki/016.-Layout-de-dentro-da-not%C3%ADcia), numa página própria.
  > Fazendo o layout de dentro da notícia, eu aproveitei para deixar o layout do TabCoins e XP mais discretos e próximos ao que aparece ao lado esquerdo de cada notícia e comentário. E um ponto importante desse layout é que o comentário possui o mesmo espaço e peso que o conteúdo da própria notícia. É importante ser assim, principalmente ter um espaço grande para a pessoa digitar o seu comentário (ter o mesmo espaço que a pessoa teve para criar a notícia principal), como em fóruns antigamente, para que a pessoa possa **trabalhar adequadamente** na criação do conteúdo. Note como o Facebook dá pouco espaço para colocar uma resposta, é um filete, é péssimo para criar conteúdos bem aprofundados e bem pensados. Próximo passo é começar a programar pra valer.
  
  ![Uma página simples, contendo a publicação e os comentários abaixo. A única diferença entre a publicação e cada comentário é que a publicação possui um título. Todos os itens possuem a quantidade de TabCoins ao lado, o autor e data de publicação acima, e um botão para comentar abaixo.](https://user-images.githubusercontent.com/4248081/120021790-61b73000-bfa0-11eb-9fc1-8af0cfafed31.png)
 
  ## 9. 28/05/2021
  Convite feito para os [membros do canal do Filipe no YouTube](https://www.youtube.com/@FilipeDeschamps/membership). Nesse dia, o Filipe postou um vídeo para os membros da turma e até o dia 04/06/2021 **101 pessoas já haviam pedido o acesso ao repositório**, que na época era privado. Destas, 82 pessoas já haviam aceitado. Além disso, várias contribuições foram feitas:
  
  - Sugestão de logo e página inicial:
  ![Os logos envolvem as letras TN ou o símbolo de Tab do teclado, uma seta para a esquerda acima de uma seta para a direita. A página inicial lembra um site de notícias.](https://user-images.githubusercontent.com/4248081/123183286-1d576c80-d446-11eb-9fea-363d5b5825e3.png)
  
  - Modo noturno para o site:
  ![Uma das propostas feitas pelo Filipe, mas no modo escuro.](https://user-images.githubusercontent.com/4248081/123183178-d6697700-d445-11eb-9f3f-c6cccb3b842a.png)
 
  - [Sugestão de extensão](https://github.com/filipedeschamps/tabnews.com.br/issues/3) do TabNews pra navegadores
  - Outra sugestão da página inicial:
  ![Uma coluna à direita contendo o nome do usuário, a quantidade de TabCoins, notificações e o que está ouvindo. Do lado principal, três publicações em destaque com imagem na parte superior, e uma lista de publicações abaixo.](https://user-images.githubusercontent.com/4248081/123183605-b7b7b000-d446-11eb-9393-01dd85748d00.png)
 
  ## 10. 11/06/2021
  Mais uma série de sugestões de design:
  ![Uma lista de publicações em formatos de card, exibindo a quantidade de TabCoins, o título da notícia, o comentário principal, o autor, data de publicação e opção de comentar. Cada card é bem grande, cabendo apenas três na tela.](https://user-images.githubusercontent.com/4248081/123184246-25181080-d448-11eb-8d88-3aceb040b3c1.png)
  ![Se diferencia no fundo cinza e um destaque maior para a primeira publicação da lista, em um gradiente amarelo. As outras publicações estão num gradiente cinza e branco.](https://user-images.githubusercontent.com/4248081/123184265-2fd2a580-d448-11eb-8b0e-aede0a727538.png)
  ![Duas sugestões: a primeira é uma lista simples, apenas com cards contendo o título e a descrição; a outra é parecida, mas com TabCoins, autor, data da publicação, quantidade de comentários e reações de coração.](https://user-images.githubusercontent.com/4248081/123184461-96f05a00-d448-11eb-916d-ab931f35c5de.png)
  
  E algumas contribuições não visuais:
  - [Novos Hooks e Lazy Loading de Componentes](https://github.com/filipedeschamps/tabnews.com.br/pull/9)
  - [Sistema de TabCoins](https://github.com/filipedeschamps/tabnews.com.br/issues/11)
  - [Proposta de Arquitetura](https://github.com/filipedeschamps/tabnews.com.br/issues/12)
  - [Suporte a PWA](https://github.com/filipedeschamps/tabnews.com.br/issues/16)
  
  ## 11. 24/06/2021
  Antes do encerramento da Milestone 0, [o Filipe compartilhou](https://github.com/filipedeschamps/tabnews.com.br/wiki/021.-Cross-collaboration) como estava sendo a experiência no repositório com tantas pessoas:
  > Hoje já estamos com **224 pessoas** dentro do repositório e **muitas contribuições** aconteceram nesse meio tempo. Depois da Live de inauguração da Milestone 0, a turma atacou as issues, como por exemplo [essa em que bolamos várias ideias para a página "Em Construção"](https://github.com/filipedeschamps/tabnews.com.br/issues/23), e ideias extras sobre [fakenews](https://github.com/filipedeschamps/tabnews.com.br/issues/27), [internacionalização](https://github.com/filipedeschamps/tabnews.com.br/issues/35) e [acessibilidade](https://github.com/filipedeschamps/tabnews.com.br/issues/43). Só que algo **especial** aconteceu [nesse Pull Request](https://github.com/filipedeschamps/tabnews.com.br/pull/45) onde implemento uma sugestão para a página de "Em construção", olha que interessante: eu fiz uma implementação, o Membro [@rhandrade](https://github.com/rhandrade) encontrou e isolou um bug, e outro Membro [@rodrigoKulb](https://github.com/rodrigoKulb) implementou um fix... e foi tudo **muito rápido**. E eu pessoalmente achei especial porque se eu tivesse sozinho nesse repositório, nada disso teria acontecido. Eu sinceramente espero que esse repositório do TabNews abra mais oportunidades assim para trabalharmos juntos, cada um conseguindo observar e participar em algum ponto do serviço. Se conseguirmos manter essas coisas acontecendo, no longo prazo iremos construir algo **realmente especial**. Bom, a Live de encerramento e comemoração da Milestone 0 supostamente irá acontecer amanhã, vamos ver como vai ser... eu to empolgado e queria que fosse hoje já!!!

  E no dia 25/06/2021, houve o [encerramento da Milestone 0](https://github.com/filipedeschamps/tabnews.com.br/wiki/022.-Milestone-0-(ENCERRAMENTO)) e a primeira página oficial do TabNews. Uma página simples, mas com a foto do perfil de todos que estavam participando do projeto no GitHub naquela época. Você pode acessar essa página ainda hoje, e ela é chamada de [init](/museu/init.html).
  ![Um texto explicando a construção do TabNews e a foto de todos que colaboraram no GitHub.](https://user-images.githubusercontent.com/4248081/123689581-38402d00-d808-11eb-8def-71601dacc6b7.png)

  ## 12. 30/07/2021
  [Encerramento da Milestone 1](https://github.com/filipedeschamps/tabnews.com.br/wiki/023.-Milestone-1-(ENCERRAMENTO)).

  ## 13. 15/12/2021
  O Filipe escreveu sobre a reorganização na sua vida para conseguir continuar o TabNews, e destacou que mesmo nessa fase conturbada, os membros do repositório continuaram contribuindo:
  
  > Os últimos meses foram os mais diferentes da minha vida, tanto pelo fato de estar criando um Bebê, quanto por reorganizar todo o trabalho com o canal no YouTube para que a publicação de vídeos seja feita de uma forma mais consistente.
  > 
  > Para isso, no início de Outubro eu postei um vídeo anunciando que estava procurando uma pessoa para editar os vídeos do canal, algo que eu pensei que nunca iria terceirizar, ou que pelo menos isso era algo que estava muito distante de acontecer. E no meio do caminho, outra pessoa apareceu para ajudar na parte de roteiros, o que foi outra novidade. E trabalhar com essas duas pessoas está sendo uma ótima experiência, principalmente para **profissionalizar** a produção de conteúdo no canal, que basicamente estava sendo feita só por mim e de uma forma muito pessoal e pouco escalável, vamos colocar assim.
  >
  > Então sem a ajuda dessas pessoas, tocar 3 projetos (Bebê, Canal e TabNews) se tornou inviável, principalmente tocar de uma forma saudável. Então a batalha agora é retomar o YouTube com força total, e ainda fazer sobrar espaço e tempo de qualidade para o TabNews, que é um projeto que cada dia que passa se torna **mais necessário existir**. A importância dele **só aumentou** e é um sonho meu e do Guga ter esse espaço na internet para pessoas **boas** terem conversas **saudáveis** sobre a produção de tecnologia. O bom é que cada vez mais estou ficando empolgado porque parece que vai ser possível com essa nova organização. A ideia é sempre trabalhar em "batches", em levas, onde antes eu escrevia 1 roteiro, depois gravava ele, depois editava e publicava... e agora o que fizemos nos últimos meses foi escrever vários roteiros, depois gravar eles em sequência, editar em sequência e publicar. Todo esse material estamos acumulando para o próximo ano (2022), inclusive tem mais roteiro escrito do que gravado e editado, e isso é ótimo.
  >
  > Em paralelo, **o projeto aqui andou** com contribuições fundamentais, por exemplo:
  >
  > 1. [Padronização inicial dos Controllers](https://github.com/filipedeschamps/tabnews.com.br/pull/119)
  > 2. [Script para Migration](https://github.com/filipedeschamps/tabnews.com.br/pull/121)
  > 3. [Adiciona migration de "uuid-ossp" e "user"](https://github.com/filipedeschamps/tabnews.com.br/pull/127)
  > 4. [Padronização dos Erros](https://github.com/filipedeschamps/tabnews.com.br/pull/131)
  > 5. [Cria endpoint /status](https://github.com/filipedeschamps/tabnews.com.br/pull/136)
  > 6. [Refatora os Github Actions para aproveitar cache](https://github.com/filipedeschamps/tabnews.com.br/pull/144)
  
  ## 14. 18/03/2022
  Quando as primeiras contas foram criadas, sem uma página de cadastro, diretamente pela API em REST.

  ## 15. 05/04/2022
  A criação da página de cadastro.

  ## 16. 06/04/2022
  Sistema de recuperação de conta e ativação.

  ## 17. 07/04/2022
  A criação da página de login.

  ## 18. 20/04 a 27/04/2022
  Nesse período, muitas coisas aconteceram:
  - [CRUD de \`content\` - Primeira versão do \`GET\`](https://github.com/filipedeschamps/tabnews.com.br/pull/268).
  - [\`content\`: implementa primeira versão do \`POST\`](https://github.com/filipedeschamps/tabnews.com.br/pull/269).
  - [\`content\`: implementa primeira versão do \`PATCH\`](https://github.com/filipedeschamps/tabnews.com.br/pull/272).
  - [\`content\`: Implementa quase todos os endpoints \`GET\`](https://github.com/filipedeschamps/tabnews.com.br/pull/275).
  - [\`content\`: método e endpoint para listar conteúdos filho](https://github.com/filipedeschamps/tabnews.com.br/pull/277).
  - [Implementa Design System do GitHub (Primer)](https://github.com/filipedeschamps/tabnews.com.br/pull/278).
  - [Normaliza todos os layouts e adiciona endpoint \`/user\`](https://github.com/filipedeschamps/tabnews.com.br/pull/279).

  ## 19. 02/05/2022
  A primeira interface foi implementada, assim como outras atualizações:
  - **Remoção do \`tailwindcss\`:** Ele foi completamente substituído pelo [@primer/react](https://primer.style/react/).
  - **Padronização das páginas com o Primer:** Nesse ponto, todas as páginas passaram a usar o Primer.

  ### \`/cadastro\`
  ![A página seguindo o mesmo estilo do GitHub, com campo para nome de usuário, email e senha, e o botão para "Criar Cadastro".](https://user-images.githubusercontent.com/4248081/166298154-392d8f5f-14d7-4d4e-8e29-9316bb700ec2.png)
  
  Com erro de validação no formulário:
  ![Erro no campo de nome de usuário, com um texto em vermelho abaixo do campo.](https://user-images.githubusercontent.com/4248081/166298265-e97f6382-f658-42d8-b371-b22372a300fd.png)
  
  ### \`/publicar\`
  Com conteúdo preenchido
  ![A página de criação de conteúdo com campo para título, corpo e fonte, nenhum campo possui label, e o botão "Publicar".](https://user-images.githubusercontent.com/4248081/166298807-c60117f7-4c89-4f8c-8afb-cc7ac681d3a1.png)
  
  ### \`/[username]/[slug]\`
  Estando logado, com o botão \`...\` para editar o conteúdo:
  ![A publicação com bordas finas, contento o nome de usuário, tempo de publicação, título, conteúdo e fonte, sem TabCoins, e com botão para Responder numa seção abaixo da publicação.](https://user-images.githubusercontent.com/4248081/166298960-16eba776-5367-455c-81c6-e7977f95ec29.png)
  
  Respondendo:
  ![O botão "Responder" desapareceu, e uma caixa de edição de texto surgiu, com o botão "Publicar" abaixo.](https://user-images.githubusercontent.com/4248081/166299317-6b6525a6-c11b-4a6e-bdb5-785e8f2da928.png)
  
  Após responder:
  ![O comentário aparece como se fosse uma nova publicação, porém sem título e fonte.](https://user-images.githubusercontent.com/4248081/166299393-70f6d962-8854-4440-b576-e6ece0fc26e5.png)
  
  ### Página exclusiva da resposta
  Cada comentário tem a data em que foi publicado. Ao passar o mouse em cima, mostra o horário sem formatação de distância de tempo:
  <img alt="O texto '4 segundos atrás', com o mouse em cima mostra um Tooltip com o texto 'segunda-feira, 2 de maio de 2022 10:54'" src="https://user-images.githubusercontent.com/4248081/166299676-ffacbbd6-6276-44e2-8b28-a141d47122ac.png" width="300" />
  
  Ao clicar na data em que o comentário foi publicado, a página do próprio comentário:
  ![Uma página em que o comentário toma o lugar de destaque, como se fosse uma publicação raiz, mas acima dele existe o texto "Em resposta a <título da publicação original>"](https://user-images.githubusercontent.com/4248081/166299828-f05226aa-4b21-4020-bf06-fa42971e1904.png)
  
  ### Respondendo a resposta de uma resposta:
  ![Uma árvore de comentários, indentados para passar a noção de aninhamento, além das bordas cinzas que cada comentário possui, ficando uma caixa dentro da outra.](https://user-images.githubusercontent.com/4248081/166300415-1074823f-8405-454d-8bf9-2b700a743586.png)
  
  ### Integração com diagramas Mermaid
  ![Criando uma publicação com código para diagramas Mermaid.](https://user-images.githubusercontent.com/4248081/166302793-3df93094-cb94-4fce-8599-435027828fd2.png)
  ![A publicação criada, com um fluxograma simples.](https://user-images.githubusercontent.com/4248081/166302860-8ac165e5-7755-417e-a6cf-7860b722a65d.png)
  ![Um diagrama de sequência com o Mermaid.](https://user-images.githubusercontent.com/4248081/166302939-612a8f84-7f02-4157-aea5-53a8f0076a5c.png)
  
  ### \`/[username]\`
  Cada usuário possui um endereço na raiz do site.
  ![Página do usuário, contendo apenas sua lista de publicações.](https://user-images.githubusercontent.com/4248081/166300942-bd9e726b-db5a-4c6a-ad15-bc0f6fb39ff4.png)
  
  ### Tudo acessível pela API por padrão \`/api/v1/contents/\`
  A URL do primeiro conteúdo criado era \`/filipedeschamps/isso-daqui-e-o-titulo-de-um-novo-conteudo-raiz\`, e a chamada à API era \`/api/v1/contents/filipedeschamps/isso-daqui-e-o-titulo-de-um-novo-conteudo-raiz\`. A API retorna o exato mesmo conteúdo e isso possibilita a integração e criação de qualquer client, script ou automação que as pessoas queiram criar:
  ![O JSON retornado pela API.](https://user-images.githubusercontent.com/4248081/166302106-23060107-d543-436c-a60b-0797a24c4d0d.png)

  ## 20. Depois do dia 04/05/2022
  Dia 04/05 houve a primeira publicação em produção.
  ![A primeira publicação.](https://i.imgur.com/kQVpMyj.png)
  ![A página inicial, contendo a lista de publicações.](https://i.imgur.com/zoa4rvl.png)

  ## 21. 16/05/2022
  A primeira listagem de conteúdos não possuía paginação, então mostrava todas as publicações do TabNews.
  ![Mostrando até a publicação de número 118](https://i.imgur.com/4Tk2dWN.png) 

  E nesse dia, também foi criada a primeira publicação \`Pitch\`:
  ![Título: "Pitch: App que ajuda a identificar algoritmos de hashing feito em Rust!"](https://i.imgur.com/8nY6gtn.png)

  ## 22. 28/05/2022
  Foi adicionada paginação ao site, ou seja, cada página mostra até 30 publicações.

  ## 23. 03/06/2022
  Adição dos TabCoins e TabCash, com o anúncio na publicação [Nova melhoria: TabCoins, TabCash e Melhorias no Layout 🎉](https://www.tabnews.com.br/filipedeschamps/nova-melhoria-tabcoins-tabcash-e-melhorias-no-layout).

  ## 24. 21/11/2022
  **O dia do lançamento oficial**. Depois de 6 meses em beta, o tão esperado lançamento foi feito! Foi o primeiro dia em que o TabNews ficou com problemas de instabilidade, por causa da alta quantidade de acessos e falta de índices no banco de dados, e isso foi discutido no issue [Vídeo de lançamento conseguiu derrubar a API (mais ou menos) 🤝](https://github.com/filipedeschamps/tabnews.com.br/issues/826) no repositório do GitHub. 
  ![O site com o aviso de modo leitura: "Turma, dado ao alto volume de acessos precisamos temporariamente desativar a nossa API, mas estamos trabalhando para voltar o mais rápido possível :) então por enquanto o TabNews está somente no modo leitura, combinado? 🤝"](https://user-images.githubusercontent.com/4248081/203150458-b4ea9d2a-880f-4552-a437-4b5c689febcd.png)

  E mesmo com todas as instabilidades, API ter ficado fora do ar e o vídeo ter ficado como não listado durante um tempo, no primeiro dia foram feitos impressionantes **1884 cadastros**, mais de **130 publicações** e **506 comentários**.
  
  ## As melhorias
  Ao longo desse período, várias publicações de melhorias foram feitas pelo Filipe no TabNews:
  1. [Nova melhoria: Recuperação de Senha 🎉](https://www.tabnews.com.br/filipedeschamps/nova-melhoria-recuperacao-de-senha)
  2. [Nova melhoria: Refatoração e novos comportamentos no Editor de Markdown 🎉](https://www.tabnews.com.br/filipedeschamps/nova-melhoria-refatoracao-e-novos-comportamentos-no-editor-de-markdown)
  3. [Nova melhoria: Melhorias de tags para SEO e redes sociais (e largura das colunas) 🎉](https://www.tabnews.com.br/filipedeschamps/nova-melhoria-melhorias-de-tags-para-seo-e-redes-sociais-e-largura-das-colunas)
  4. [Nova melhoria: Paginação na API e no Site 🎉](https://www.tabnews.com.br/filipedeschamps/nova-melhoria-paginacao-na-api-e-no-site)
  5. [Novas melhorias: Remoção do "flicker" na data, posição dos números, Node.js 16 LTS, source_url, ícone Dark Mode e Nova Paginação 🎉](https://www.tabnews.com.br/filipedeschamps/novas-melhorias-remocao-do-flicker-na-data-posicao-dos-numeros-node-js-16-lts-sourceurl-e-nova-paginacao)
  6. [Novas melhorias: habilidade de apagar suas publicações (e edição pela moderação) 🎉](https://www.tabnews.com.br/filipedeschamps/novas-melhorias-habilidade-de-apagar-suas-publicacoes-e-edicao-pela-moderacao)
  7. [Novas melhorias: número de comentários nas publicações (+SEO) 🎉](https://www.tabnews.com.br/filipedeschamps/nova-melhoria-numero-de-comentarios-nas-publicacoes)
  8. [Novas melhorias: Husky, Sistema de Eventos, Firewall e Melhorias no SEO 🎉](https://www.tabnews.com.br/filipedeschamps/novas-melhorias-husky-sistema-de-eventos-firewall-e-melhorias-no-seo)
  9. [Nova melhoria: aumento de performance para usuários logados (última tarefa antes das TabCoins) 🎉](https://www.tabnews.com.br/filipedeschamps/nova-melhoria-aumento-de-performance-para-usuarios-logados-ultima-tarefa-antes-das-tabcoins)
  10. [Nova melhoria: TabCoins, TabCash e Melhorias no Layout 🎉](https://www.tabnews.com.br/filipedeschamps/nova-melhoria-tabcoins-tabcash-e-melhorias-no-layout)
  11. [Novas melhorias: Enviar publicações com "CTRL + Enter" e outras 6 melhorias 🎉](https://www.tabnews.com.br/filipedeschamps/novas-melhorias-enviar-publicacoes-com-ctrl-enter-e-outras-6-melhorias)
  12. [Novas melhorias: Thumbnail dinâmica, Ícones do Bot do TabNews e outras 5 melhorias 🎉](https://www.tabnews.com.br/filipedeschamps/novas-melhorias-thumbnail-customizada-icones-do-bot-do-tabnews-e-outras-5-melhorias)
  13. [Novas melhorias: feature de Deslogar implementada e mais 6 melhorias! 🎉](https://www.tabnews.com.br/filipedeschamps/novas-melhorias-feature-de-deslogar-implementada-e-mais-6-melhorias)
  14. [Novas melhorias: Abertura instanânea de páginas e mais 7 melhorias 🎉](https://www.tabnews.com.br/filipedeschamps/novas-melhorias-abertura-instananea-de-paginas-e-mais-7-melhorias)
  15. [Novas melhorias: RSS e mais 7 melhorias 🎉](https://www.tabnews.com.br/filipedeschamps/novas-melhorias-rss-e-mais-7-melhorias)
  16. [Novas melhorias: Mais Performance e outras 6 melhorias 🎉](https://www.tabnews.com.br/filipedeschamps/novas-melhorias-mais-performance-e-outras-6-melhorias)
  17. [Novas melhorias: Mais contexto nas notificações por Email e outras 8 melhorias 🎉](https://www.tabnews.com.br/filipedeschamps/novas-melhorias-mais-contexto-nas-notifacoes-por-email-e-outras-8-melhorias)
  18. [Novas melhorias: TabCoins mais consistentes e outras 4 melhorias 🎉](https://www.tabnews.com.br/filipedeschamps/novas-melhorias-tabcoins-mais-consistentes-e-outras-4-melhorias)
  19. [Novas melhorias: Editar Perfil e outras 4 melhorias 🎉](https://www.tabnews.com.br/filipedeschamps/novas-melhorias-editar-perfil-e-outras-4-melhorias)
  20. [Novas melhorias: Não de código, mas teve sobre o Vídeo de Lançamento do TabNews 🎉](https://www.tabnews.com.br/filipedeschamps/novas-melhorias-nao-de-codigo-mas-teve-sobre-o-video-de-lancamento-do-tabnews)
  21. [Novas melhorias: testando novo algoritmo de ranking (3 versões disponíveis) 🎉](https://www.tabnews.com.br/filipedeschamps/novas-melhorias-testando-novo-algoritmo-de-ranking-3-versoes-disponiveis)
  22. [Novas melhorias: Novo Algoritmo de Ranqueamento e mais 3 melhorias (+1 Breaking Change) 🎉](https://www.tabnews.com.br/filipedeschamps/novas-melhorias-novo-algoritmo-de-ranqueamento-e-mais-3-melhorias-1-breaking-change)
  23. [Novas melhorias: 3 ajustes + Commit no Core do Next.js 🎉 (e peguei COVID)](https://www.tabnews.com.br/filipedeschamps/novas-melhorias-3-ajustes-commit-no-core-do-next-js-e-peguei-covid)
  24. [Novas melhorias: 3 ajustes (incluindo novo Analytics) 🎉](https://www.tabnews.com.br/filipedeschamps/novas-melhorias-3-ajustes-incluindo-novo-analytics)
  25. [Repositório do TabNews no GitHub disponibilizado de forma Pública 🎉](https://www.tabnews.com.br/filipedeschamps/repositorio-do-tabnews-no-github-disponibilizado-de-forma-publica)

  ## Mais história
  Se você quiser ver como era a interface do TabNews em diferentes épocas, pode acessar a [Wayback Machine](http://web.archive.org/web/20220000000000*/tabnews.com.br) e acessar os dias em que o site do TabNews foi arquivado.

  Se deseja ver todas as sugestões de design elaboradas antes da primeira interface, pode acessar o [Museu do TabNews](/museu).

  Durante o desenvolvimento, o Filipe fez um [Diário de desenvolvimento](https://github.com/filipedeschamps/tabnews.com.br/wiki) no Wiki do GitHub compartilhando seus pensamentos e decisões tomadas. Várias informações desta página foram retiradas do diário.
`;

  return (
    <DefaultLayout metadata={{ title: 'A Evolução do TabNews — da Concepção ao Lançamento' }}>
      <Box as="article">
        <Heading as="h1">A Evolução do TabNews — da Concepção ao Lançamento</Heading>
        <Box sx={{ display: 'flex', flexDirection: 'column' }}>
          <Box sx={{ mb: 3, fontSize: 1 }}>
            <Box as="address" sx={{ display: 'inline', fontStyle: 'normal' }}>
              <Text>Autor: </Text>
              <Link href="https://github.com/gabrielsozinho">Gabriel Sozinho</Link>
            </Box>
            {' · '}
            <Text>Revisor: </Text>
            <Link href="https://github.com/rafatcb">Rafael Tavares</Link>
          </Box>
        </Box>
        <Viewer areLinksTrusted value={body} clobberPrefix="" />
      </Box>
    </DefaultLayout>
  );
}
</file>

<file path="pages/museu/index.public.js">
import { Box, DefaultLayout, PrimerLink, Text } from '@/TabNewsUI';

export default function Page() {
  return (
    <DefaultLayout
      metadata={{
        title: 'Museu',
        description: 'Esta página é humilde, porém traz coisas muito importantes da história do TabNews.',
      }}>
      <Box>
        <Text as="h1">Museu TabNews</Text>
        <Text as="p">
          Esta página é humilde, porém traz coisas <strong>muito importantes</strong> da história do TabNews.
        </Text>

        <Text as="h2">Artigo</Text>
        <Box as="ul">
          <li>
            <PrimerLink href="/museu/evolucao-do-tabnews">
              A Evolução do TabNews — da Concepção ao Lançamento
            </PrimerLink>{' '}
            feito por <PrimerLink href="https://github.com/gabrielsozinho">Gabriel Sozinho</PrimerLink>
          </li>
        </Box>

        <Text as="h2">Primeiras interfaces e Provas de Conceito (POC)</Text>

        <Box as="ul">
          <li>
            <PrimerLink href="/museu/init.html">Primeira Home Oficial (Init)</PrimerLink> feito pelos Membros da Turma
          </li>
          <li>
            <PrimerLink href="/museu/construction-01.html">Em Construção POC #01</PrimerLink> feito por{' '}
            <PrimerLink href="https://github.com/rodrigoKulb">Rodrigo Kulb</PrimerLink>
          </li>
          <li>
            <PrimerLink href="/museu/construction-03.html">Em Construção POC #03</PrimerLink> feito por{' '}
            <PrimerLink href="https://github.com/brunofamiliar">Bruno Familiar</PrimerLink>
          </li>
          <li>
            <PrimerLink href="/museu/home-01.html">Home POC #01</PrimerLink> feito por{' '}
            <PrimerLink href="https://github.com/filipedeschamps">Filipe Deschamps</PrimerLink>
          </li>
          <li>
            <PrimerLink href="/museu/home-02.html">Home POC #02</PrimerLink> feito por{' '}
            <PrimerLink href="https://github.com/filipedeschamps">Filipe Deschamps</PrimerLink>
          </li>
          <li>
            <PrimerLink href="/museu/home-03.html">Home POC #03</PrimerLink> feito por{' '}
            <PrimerLink href="https://github.com/filipedeschamps">Filipe Deschamps</PrimerLink>
          </li>
          <li>
            <PrimerLink href="/museu/home-04.html">Home POC #04</PrimerLink> feito por{' '}
            <PrimerLink href="https://github.com/filipedeschamps">Filipe Deschamps</PrimerLink>
          </li>
          <li>
            <PrimerLink href="/museu/home-05.html">Home POC #05</PrimerLink> feito por{' '}
            <PrimerLink href="https://github.com/filipedeschamps">Filipe Deschamps</PrimerLink>
          </li>
          <li>
            <PrimerLink href="/museu/home-06.html">Home POC #06</PrimerLink> feito por{' '}
            <PrimerLink href="https://github.com/filipedeschamps">Filipe Deschamps</PrimerLink>
          </li>
          <li>
            <PrimerLink href="/museu/home-07.html">Home POC #07</PrimerLink> feito por{' '}
            <PrimerLink href="https://github.com/filipedeschamps">Filipe Deschamps</PrimerLink>
          </li>
          <li>
            <PrimerLink href="/museu/home-08.html">Home POC #08</PrimerLink> feito por{' '}
            <PrimerLink href="https://github.com/filipedeschamps">Filipe Deschamps</PrimerLink>
          </li>
          <li>
            <PrimerLink href="/museu/home-09.html">Home POC #09 - Dark Mode</PrimerLink> feito por{' '}
            <PrimerLink href="https://github.com/pscruzzz">Pedro Cruz</PrimerLink>
          </li>
          <li>
            <PrimerLink href="/museu/home-10.html">Home POC #10</PrimerLink> feito por{' '}
            <PrimerLink href="https://github.com/peguimasid">Guilhermo Masid</PrimerLink>
          </li>
          <li>
            <PrimerLink href="/museu/home-10-mobile.html">Home POC #10 - Mobile</PrimerLink> feito por{' '}
            <PrimerLink href="https://github.com/rodrigoKulb">Rodrigo Kulb</PrimerLink>
          </li>
          <li>
            <PrimerLink href="/museu/home-11.html">Home POC #11</PrimerLink> feito por{' '}
            <PrimerLink href="https://github.com/pscruzzz">Pedro Cruz</PrimerLink>
          </li>
          <li>
            <PrimerLink href="/museu/home-12.html">Home POC #12</PrimerLink> feito por{' '}
            <PrimerLink href="https://github.com/luantoningalvan">Luan Tonin Galvan</PrimerLink>
          </li>
          <li>
            <PrimerLink href="/museu/post-01.html">Post POC #01</PrimerLink> feito por{' '}
            <PrimerLink href="https://github.com/filipedeschamps">Filipe Deschamps</PrimerLink>
          </li>
          <li>
            <PrimerLink href="/museu/post-02.html">Post POC #02</PrimerLink> feito por{' '}
            <PrimerLink href="https://github.com/pscruzzz">Pedro Cruz</PrimerLink>
          </li>
        </Box>
      </Box>
    </DefaultLayout>
  );
}
</file>

<file path="pages/pagina/[page]/index.public.js">
import { getStaticPropsRevalidate } from 'next-swr';

import { ContentList, DefaultLayout } from '@/TabNewsUI';
import webserver from 'infra/webserver';
import ad from 'models/advertisement';
import authorization from 'models/authorization.js';
import content from 'models/content.js';
import user from 'models/user.js';
import validator from 'models/validator.js';

export default function Home({ adFound, contentListFound, pagination }) {
  return (
    <DefaultLayout metadata={{ title: `Página ${pagination.currentPage} · Relevantes` }}>
      <ContentList ad={adFound} contentList={contentListFound} pagination={pagination} paginationBasePath="/pagina" />
    </DefaultLayout>
  );
}

export function getStaticPaths() {
  return {
    paths: [{ params: { page: '2' } }, { params: { page: '3' } }],
    fallback: 'blocking',
  };
}

export const getStaticProps = getStaticPropsRevalidate(async (context) => {
  const userTryingToGet = user.createAnonymous();

  context.params = context.params ? context.params : {};

  try {
    context.params = validator(context.params, {
      page: 'optional',
      per_page: 'optional',
    });
  } catch (error) {
    return {
      notFound: true,
    };
  }

  const results = await content.findWithStrategy({
    strategy: 'relevant',
    where: {
      parent_id: null,
      status: 'published',
    },
    page: context.params.page,
    per_page: context.params.per_page,
  });

  const contentListFound = results.rows;

  if (contentListFound.length === 0 && context.params.page !== 1 && !webserver.isBuildTime) {
    const lastValidPage = `/pagina/${results.pagination.lastPage || 1}`;
    const revalidate = context.params.page > results.pagination.lastPage + 1 ? 10 : 1;

    return {
      redirect: {
        destination: lastValidPage,
      },
      revalidate,
    };
  }

  const secureContentValues = authorization.filterOutput(userTryingToGet, 'read:content:list', contentListFound);

  const adsFound = await ad.getRandom(1);
  const secureAdValues = authorization.filterOutput(userTryingToGet, 'read:ad:list', adsFound);

  return {
    props: {
      adFound: secureAdValues[0] ?? null,
      contentListFound: secureContentValues,
      pagination: results.pagination,
    },

    // TODO: instead of `revalidate`, understand how to use this:
    // https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration#using-on-demand-revalidation
    revalidate: 10,
  };
});
</file>

<file path="pages/perfil/confirmar-email/[token].public.js">
import { useRouter } from 'next/router';
import { useEffect, useState } from 'react';

import { Box, Confetti, DefaultLayout, Flash } from '@/TabNewsUI';
import { createErrorMessage, useUser } from 'pages/interface';

export default function ConfirmEmail() {
  const router = useRouter();
  const { token } = router.query;
  const { fetchUser } = useUser();
  const [globalMessage, setGlobalMessage] = useState(false);
  const [isSuccess, setIsSuccess] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  const handleEmailConfirmation = async (token, updateUserCache) => {
    try {
      setIsLoading(true);

      const response = await fetch(`/api/v1/email-confirmation`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          token_id: token,
        }),
      });

      if (response.status === 200) {
        setIsSuccess(true);
        setGlobalMessage('Seu email foi alterado com sucesso!');
        updateUserCache();
        return;
      }

      if (response.status >= 400 && response.status <= 503) {
        const responseBody = await response.json();
        setGlobalMessage(
          createErrorMessage(responseBody, {
            omitErrorId: [400, 404].includes(response.status),
          }),
        );
        setIsSuccess(false);
        return;
      }

      setIsSuccess(false);
      throw new Error(response.statusText);
    } catch (error) {
      setGlobalMessage(error.message);
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    if (token) {
      handleEmailConfirmation(token, fetchUser);
    }
  }, [fetchUser, token]);

  return (
    <>
      {isSuccess && <Confetti />}
      <DefaultLayout containerWidth="medium" metadata={{ title: 'Confirmar alteração de email' }}>
        <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', width: '100%', mt: 10 }}>
          {isLoading ? (
            <Flash variant="default">Verificando Token de Alteração de Email...</Flash>
          ) : (
            <Flash variant={isSuccess ? 'success' : 'danger'}>{globalMessage}</Flash>
          )}
        </Box>
      </DefaultLayout>
    </>
  );
}
</file>

<file path="pages/perfil/index.public.js">
import { useRouter } from 'next/router';
import { useEffect, useRef, useState } from 'react';

import {
  Box,
  Button,
  ButtonWithLoader,
  CharacterCount,
  Checkbox,
  DefaultLayout,
  Editor,
  Flash,
  FormControl,
  Heading,
  Link,
  Text,
  TextInput,
  useConfirm,
} from '@/TabNewsUI';
import { createErrorMessage, suggestEmail, useUser } from 'pages/interface';

export default function EditProfile() {
  return (
    <DefaultLayout containerWidth="medium" metadata={{ title: 'Editar Perfil' }}>
      <Heading as="h1" sx={{ mb: 3 }}>
        Editar Perfil
      </Heading>
      <EditProfileForm />
    </DefaultLayout>
  );
}

const DESCRIPTION_MAX_LENGTH = 5_000;

function EditProfileForm() {
  const router = useRouter();
  const confirm = useConfirm();

  const { user, fetchUser, isLoading: userIsLoading } = useUser();

  const usernameRef = useRef();
  const emailRef = useRef();
  const notificationsRef = useRef();

  const [globalMessageObject, setGlobalMessageObject] = useState(undefined);
  const [isLoading, setIsLoading] = useState(false);
  const [errorObject, setErrorObject] = useState(undefined);
  const [emailDisabled, setEmailDisabled] = useState(false);
  const [description, setDescription] = useState(user?.description || '');
  const [showUsernameCaption, setShowUsernameCaption] = useState(false);

  useEffect(() => {
    if (router && !user && !userIsLoading) {
      router.push(`/login?redirect=${router.asPath}`);
    }

    if (user && !userIsLoading && !usernameRef.current.value) {
      setDescription(user.description);
      usernameRef.current.value = user.username;
      emailRef.current.value = user.email;
      notificationsRef.current.checked = user.notifications;
    }
  }, [user, router, userIsLoading]);

  function clearMessages() {
    setErrorObject(undefined);
    setGlobalMessageObject(undefined);
  }

  async function handleSubmit(event) {
    event.preventDefault();

    const username = usernameRef.current.value;
    const email = emailRef.current.value;
    const notifications = notificationsRef.current.checked;

    setIsLoading(true);
    setErrorObject(undefined);

    const payload = {};

    if (user.username !== username) {
      const confirmChangeUsername =
        user.username.toLowerCase() === username.toLowerCase() ||
        (await confirm({
          title: `Você realmente deseja alterar seu nome de usuário?`,
          content: `Isso irá quebrar todas as URLs das suas publicações e comentários.`,
          cancelButtonContent: 'Cancelar',
          confirmButtonContent: 'Sim',
        }));

      if (!confirmChangeUsername) {
        setIsLoading(false);
        return;
      }

      payload.username = username;
    }

    if (user.email !== email) {
      const suggestedEmail = suggestEmail(email);

      if (suggestedEmail) {
        setErrorObject({
          suggestion: suggestedEmail,
          key: 'email',
          type: 'typo',
        });

        setIsLoading(false);
        return;
      }

      payload.email = email;
    }

    if (user.description !== description) {
      payload.description = description;
    }

    if (user.notifications !== notifications) {
      payload.notifications = notifications;
    }

    if (Object.keys(payload).length === 0) {
      setGlobalMessageObject({
        type: 'warning',
        text: 'Nenhuma configuração foi alterada',
      });
      setIsLoading(false);
      return;
    }

    try {
      const response = await fetch(`/api/v1/users/${user.username}`, {
        method: 'PATCH',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      const responseBody = await response.json();

      if (response.status === 200) {
        await fetchUser();

        if (user.email !== email) {
          const hasSavedModifications = Object.keys(payload).length > 1;
          const text = hasSavedModifications
            ? `Alterações salvas. O email será alterado apenas após a confirmação pelo link enviado para "${email}", caso o email esteja disponível.`
            : `Alteração pendente. Um email de confirmação será enviado para "${email}", caso o email esteja disponível.`;
          setGlobalMessageObject({ text, type: 'warning' });
          setEmailDisabled(true);
        } else {
          setGlobalMessageObject({
            type: 'success',
            text: 'Salvo com sucesso!',
          });
        }

        setIsLoading(false);
        return;
      }

      if (response.status === 400) {
        setErrorObject(responseBody);
        setIsLoading(false);
        return;
      }

      if (response.status >= 403) {
        setGlobalMessageObject({
          type: 'danger',
          text: createErrorMessage(responseBody),
        });
        setIsLoading(false);
        return;
      }
    } catch (error) {
      setGlobalMessageObject({
        type: 'danger',
        text: 'Não foi possível se conectar ao TabNews. Por favor, verifique sua conexão.',
      });
      setIsLoading(false);
    }
  }

  return (
    <form style={{ width: '100%' }} onSubmit={handleSubmit} onChange={clearMessages}>
      <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
        <FormControl id="username" required>
          <FormControl.Label>Nome de usuário</FormControl.Label>
          <TextInput
            ref={usernameRef}
            name="username"
            size="large"
            autoCorrect="off"
            autoCapitalize="off"
            spellCheck={false}
            block={true}
            aria-label="Seu nome de usuário"
            contrast
            sx={{ px: 2, '&:focus-within': { backgroundColor: 'canvas.default' } }}
            onChange={() => setShowUsernameCaption(true)}
          />
          {showUsernameCaption && (
            <FormControl.Caption>
              Alterar o nome de usuário pode quebrar todas as URLs das suas publicações e comentários.
            </FormControl.Caption>
          )}

          {errorObject?.key === 'username' && errorObject?.type === 'string.alphanum' && (
            <FormControl.Validation variant="error">
              Nome de usuário deve conter apenas letras e números, por exemplo: &quot;nomeSobrenome4&quot;.
            </FormControl.Validation>
          )}

          {errorObject?.key === 'username' && (
            <FormControl.Validation variant="error">{errorObject.message}</FormControl.Validation>
          )}
        </FormControl>

        <FormControl id="email" disabled={emailDisabled} required>
          <FormControl.Label>Email</FormControl.Label>
          <TextInput
            ref={emailRef}
            name="email"
            size="large"
            autoCorrect="off"
            autoCapitalize="off"
            spellCheck={false}
            block={true}
            aria-label="Seu email"
            contrast
            sx={{ px: 2, '&:focus-within': { backgroundColor: 'canvas.default' } }}
          />
          {errorObject?.key === 'email' && errorObject.type !== 'typo' && (
            <FormControl.Validation variant="error">{errorObject.message}</FormControl.Validation>
          )}
          {errorObject?.key === 'email' && errorObject.type === 'typo' && (
            <FormControl.Validation variant="error">
              <Box sx={{ display: 'flex', alignItems: 'center' }}>
                <Box>Você quis dizer:</Box>
                <Box>
                  <Button
                    variant="invisible"
                    size="small"
                    sx={{ color: 'accent.fg', p: 1 }}
                    onClick={(event) => {
                      event.preventDefault();
                      clearMessages();
                      emailRef.current.value = errorObject.suggestion;
                    }}>
                    {errorObject.suggestion.split('@')[0]}@<u>{errorObject.suggestion.split('@')[1]}</u>
                  </Button>
                </Box>
              </Box>
            </FormControl.Validation>
          )}
        </FormControl>

        <FormControl id="description">
          <FormControl.Label>Descrição</FormControl.Label>

          <Editor
            onChange={(value) => {
              clearMessages();
              setDescription(value);
            }}
            value={description}
            isInvalid={errorObject?.key === 'description' || description.length > DESCRIPTION_MAX_LENGTH}
            clobberPrefix={`${user?.username}-content-`}
          />

          <Box sx={{ display: 'flex', width: '100%' }}>
            {errorObject?.key === 'description' && errorObject.type === 'string.max' && (
              <FormControl.Validation variant="error">{errorObject.message}</FormControl.Validation>
            )}

            <CharacterCount maxLength={DESCRIPTION_MAX_LENGTH} value={description} />
          </Box>
        </FormControl>

        <FormControl id="notifications" sx={{ gap: 2, alignItems: 'center' }}>
          <FormControl.Label>Receber notificações por email</FormControl.Label>

          <Checkbox
            sx={{ display: 'flex' }}
            ref={notificationsRef}
            name="notifications"
            aria-label="Você deseja receber notificações?"
          />

          {errorObject?.key === 'notifications' && (
            <FormControl.Validation variant="error">{errorObject.message}</FormControl.Validation>
          )}
        </FormControl>

        <FormControl id="password">
          <FormControl.Label>Senha</FormControl.Label>
          <Link href="/cadastro/recuperar" sx={{ fontSize: 0 }}>
            Utilize o fluxo de recuperação de senha →
          </Link>
        </FormControl>

        <Text sx={{ fontSize: 1 }}>Os campos marcados com um asterisco (*) são obrigatórios.</Text>

        {globalMessageObject && <Flash variant={globalMessageObject.type}>{globalMessageObject.text}</Flash>}

        <FormControl>
          <FormControl.Label visuallyHidden>Salvar</FormControl.Label>
          <ButtonWithLoader
            variant="primary"
            size="large"
            type="submit"
            sx={{ width: '100%' }}
            aria-label="Salvar"
            isLoading={isLoading}>
            Salvar
          </ButtonWithLoader>
        </FormControl>
      </Box>
    </form>
  );
}
</file>

<file path="pages/publicar/index.public.js">
import { useRouter } from 'next/router';
import { useEffect } from 'react';
import useSWR from 'swr';

import { Box, Content, DefaultLayout, Flash, Heading, Link } from '@/TabNewsUI';
import { useUser } from 'pages/interface';

export default function Post() {
  const router = useRouter();
  const { user, isLoading } = useUser();
  const {
    data: { body: contents },
  } = useSWR(user ? `/api/v1/contents/${user.username}?strategy=new&per_page=1` : null, {
    revalidateOnFocus: false,
    revalidateOnReconnect: false,
  });

  useEffect(() => {
    if (router && !user && !isLoading) {
      router.push(`/login?redirect=${router.asPath}`);
    }
  }, [user, router, isLoading]);

  return (
    <DefaultLayout metadata={{ title: 'Publicar novo conteúdo' }}>
      {contents?.length === 0 && (
        <Box sx={{ width: '100%', mb: 3 }}>
          <Flash variant="warning">
            ⚠ Atenção: Pedimos encarecidamente que{' '}
            <Link href="https://www.tabnews.com.br/filipedeschamps/tentando-construir-um-pedaco-de-internet-mais-massa">
              leia isso antes
            </Link>{' '}
            de fazer sua primeira publicação.
          </Flash>
        </Box>
      )}

      <Heading as="h1" sx={{ mb: 3 }}>
        Publicar novo conteúdo
      </Heading>
      <Content mode="edit" />
    </DefaultLayout>
  );
}
</file>

<file path="pages/recentes/classificados/[page]/index.public.js">
import { getStaticPropsRevalidate } from 'next-swr';

import { ContentList, DefaultLayout, RecentTabNav } from '@/TabNewsUI';
import webserver from 'infra/webserver';
import authorization from 'models/authorization.js';
import content from 'models/content.js';
import user from 'models/user.js';
import validator from 'models/validator.js';

export default function ContentsPage({ contentListFound, pagination }) {
  return (
    <DefaultLayout
      metadata={{
        title: `Página ${pagination.currentPage} · Classificados Recentes`,
        description: 'Classificados do TabNews ordenados pelos mais recentes.',
        noIndex: true,
      }}>
      <RecentTabNav />
      <ContentList
        contentList={contentListFound}
        pagination={pagination}
        paginationBasePath="/recentes/classificados"
      />
    </DefaultLayout>
  );
}

export const getStaticProps = getStaticPropsRevalidate(async (context) => {
  const userTryingToGet = user.createAnonymous();

  context.params = context.params ? context.params : {};

  try {
    context.params = validator(context.params, {
      page: 'optional',
      per_page: 'optional',
    });
  } catch (error) {
    return {
      notFound: true,
    };
  }

  const results = await content.findWithStrategy({
    strategy: 'new',
    where: {
      status: 'published',
      type: 'ad',
    },
    attributes: {
      exclude: ['body'],
    },
    page: context.params.page,
    per_page: context.params.per_page,
  });

  const contentListFound = results.rows;

  if (contentListFound.length === 0 && context.params.page !== 1 && !webserver.isBuildTime) {
    const lastValidPage = `/recentes/classificados/${results.pagination.lastPage || 1}`;
    const revalidate = context.params.page > results.pagination.lastPage + 1 ? 10 : 1;

    return {
      redirect: {
        destination: lastValidPage,
      },
      revalidate,
    };
  }

  const secureContentListFound = authorization.filterOutput(userTryingToGet, 'read:content:list', contentListFound);

  return {
    props: {
      contentListFound: secureContentListFound,
      pagination: results.pagination,
    },
    revalidate: 10,
  };
});

export function getStaticPaths() {
  return {
    paths: [{ params: { page: '1' } }, { params: { page: '2' } }, { params: { page: '3' } }],
    fallback: 'blocking',
  };
}
</file>

<file path="pages/recentes/comentarios/[page]/index.public.js">
import { getStaticPropsRevalidate } from 'next-swr';

import { ContentList, DefaultLayout, RecentTabNav } from '@/TabNewsUI';
import webserver from 'infra/webserver';
import ad from 'models/advertisement';
import authorization from 'models/authorization.js';
import content from 'models/content.js';
import removeMarkdown from 'models/remove-markdown';
import user from 'models/user.js';
import validator from 'models/validator.js';

export default function CommentsPage({ adFound, contentListFound, pagination }) {
  return (
    <DefaultLayout
      metadata={{
        title: `Página ${pagination.currentPage} · Comentários Recentes`,
        description: 'Comentários no TabNews ordenados pelos mais recentes.',
      }}>
      <RecentTabNav />
      <ContentList
        ad={adFound}
        contentList={contentListFound}
        pagination={pagination}
        paginationBasePath="/recentes/comentarios"
      />
    </DefaultLayout>
  );
}

export const getStaticProps = getStaticPropsRevalidate(async (context) => {
  const userTryingToGet = user.createAnonymous();

  context.params = context.params ? context.params : {};

  try {
    context.params = validator(context.params, {
      page: 'optional',
      per_page: 'optional',
    });
  } catch (error) {
    return {
      notFound: true,
    };
  }

  const results = await content.findWithStrategy({
    strategy: 'new',
    where: {
      status: 'published',
      $not_null: ['parent_id'],
    },
    page: context.params.page,
    per_page: context.params.per_page,
  });

  const contentListFound = results.rows;

  if (contentListFound.length === 0 && context.params.page !== 1 && !webserver.isBuildTime) {
    const lastValidPage = `/recentes/comentarios/${results.pagination.lastPage || 1}`;
    const revalidate = context.params.page > results.pagination.lastPage + 1 ? 10 : 1;

    return {
      redirect: {
        destination: lastValidPage,
      },
      revalidate,
    };
  }

  const secureContentListFound = authorization.filterOutput(userTryingToGet, 'read:content:list', contentListFound);

  for (const content of secureContentListFound) {
    content.body = removeMarkdown(content.body, { maxLength: 255 });
  }

  const adsFound = await ad.getRandom(1);
  const secureAdValues = authorization.filterOutput(userTryingToGet, 'read:ad:list', adsFound);

  return {
    props: {
      adFound: secureAdValues[0] ?? null,
      contentListFound: secureContentListFound,
      pagination: results.pagination,
    },
    revalidate: 1,
  };
});

export function getStaticPaths() {
  return {
    paths: [{ params: { page: '1' } }, { params: { page: '2' } }, { params: { page: '3' } }],
    fallback: 'blocking',
  };
}
</file>

<file path="pages/recentes/pagina/[page]/index.public.js">
import { getStaticPropsRevalidate } from 'next-swr';

import { ContentList, DefaultLayout, RecentTabNav } from '@/TabNewsUI';
import webserver from 'infra/webserver';
import ad from 'models/advertisement';
import authorization from 'models/authorization.js';
import content from 'models/content.js';
import user from 'models/user.js';
import validator from 'models/validator.js';

export default function Home({ adFound, contentListFound, pagination }) {
  return (
    <DefaultLayout
      metadata={{
        title: `Página ${pagination.currentPage} · Recentes`,
        description: 'Publicações no TabNews ordenadas pelas mais recentes.',
      }}>
      <RecentTabNav />
      <ContentList
        ad={adFound}
        contentList={contentListFound}
        pagination={pagination}
        paginationBasePath="/recentes/pagina"
      />
    </DefaultLayout>
  );
}

export function getStaticPaths() {
  return {
    paths: [{ params: { page: '1' } }, { params: { page: '2' } }, { params: { page: '3' } }],
    fallback: 'blocking',
  };
}

export const getStaticProps = getStaticPropsRevalidate(async (context) => {
  const userTryingToGet = user.createAnonymous();

  context.params = context.params ? context.params : {};

  try {
    context.params = validator(context.params, {
      page: 'optional',
      per_page: 'optional',
    });
  } catch (error) {
    return {
      notFound: true,
    };
  }

  const results = await content.findWithStrategy({
    strategy: 'new',
    where: {
      parent_id: null,
      status: 'published',
      type: 'content',
    },
    attributes: {
      exclude: ['body'],
    },
    page: context.params.page,
    per_page: context.params.per_page,
  });

  const contentListFound = results.rows;

  if (contentListFound.length === 0 && context.params.page !== 1 && !webserver.isBuildTime) {
    const lastValidPage = `/recentes/pagina/${results.pagination.lastPage || 1}`;
    const revalidate = context.params.page > results.pagination.lastPage + 1 ? 10 : 1;

    return {
      redirect: {
        destination: lastValidPage,
      },
      revalidate,
    };
  }

  const secureContentValues = authorization.filterOutput(userTryingToGet, 'read:content:list', contentListFound);

  const adsFound = await ad.getRandom(1);
  const secureAdValues = authorization.filterOutput(userTryingToGet, 'read:ad:list', adsFound);

  return {
    props: {
      adFound: secureAdValues[0] ?? null,
      contentListFound: secureContentValues,
      pagination: results.pagination,
    },
    revalidate: 1,
  };
});
</file>

<file path="pages/recentes/todos/[page]/index.public.js">
import { getStaticPropsRevalidate } from 'next-swr';

import { ContentList, DefaultLayout, RecentTabNav } from '@/TabNewsUI';
import webserver from 'infra/webserver';
import ad from 'models/advertisement';
import authorization from 'models/authorization.js';
import content from 'models/content.js';
import removeMarkdown from 'models/remove-markdown';
import user from 'models/user.js';
import validator from 'models/validator.js';

export default function ContentsPage({ adFound, contentListFound, pagination }) {
  return (
    <DefaultLayout
      metadata={{
        title: `Página ${pagination.currentPage} · Conteúdos Recentes`,
        description: 'Conteúdos no TabNews ordenados pelos mais recentes.',
      }}>
      <RecentTabNav />
      <ContentList
        ad={adFound}
        contentList={contentListFound}
        pagination={pagination}
        paginationBasePath="/recentes/todos"
      />
    </DefaultLayout>
  );
}

export const getStaticProps = getStaticPropsRevalidate(async (context) => {
  const userTryingToGet = user.createAnonymous();

  context.params = context.params ? context.params : {};

  try {
    context.params = validator(context.params, {
      page: 'optional',
      per_page: 'optional',
    });
  } catch (error) {
    return {
      notFound: true,
    };
  }

  const results = await content.findWithStrategy({
    strategy: 'new',
    where: {
      status: 'published',
    },
    page: context.params.page,
    per_page: context.params.per_page,
  });

  const contentListFound = results.rows;

  if (contentListFound.length === 0 && context.params.page !== 1 && !webserver.isBuildTime) {
    const lastValidPage = `/recentes/todos/${results.pagination.lastPage || 1}`;
    const revalidate = context.params.page > results.pagination.lastPage + 1 ? 10 : 1;

    return {
      redirect: {
        destination: lastValidPage,
      },
      revalidate,
    };
  }

  const secureContentListFound = authorization.filterOutput(userTryingToGet, 'read:content:list', contentListFound);

  for (const content of secureContentListFound) {
    if (content.parent_id) {
      content.body = removeMarkdown(content.body, { maxLength: 255 });
    } else {
      delete content.body;
    }
  }

  const adsFound = await ad.getRandom(1);
  const secureAdValues = authorization.filterOutput(userTryingToGet, 'read:ad:list', adsFound);

  return {
    props: {
      adFound: secureAdValues[0] ?? null,
      contentListFound: secureContentListFound,
      pagination: results.pagination,
    },
    revalidate: 1,
  };
});

export function getStaticPaths() {
  return {
    paths: [{ params: { page: '1' } }, { params: { page: '2' } }, { params: { page: '3' } }],
    fallback: 'blocking',
  };
}
</file>

<file path="pages/status/index.public.js">
import { getStaticPropsRevalidate } from 'next-swr';
import useSWR from 'swr';

import { BarChart } from '@/Charts';
import Graph from '@/Graph';
import { Box, DefaultLayout, Heading, Label, LabelGroup, Truncate } from '@/TabNewsUI';
import analytics from 'models/analytics.js';
import { useUser } from 'pages/interface';

export default function Page({ usersCreated, rootContentPublished, childContentPublished, votesGraph, votesTaken }) {
  const { user } = useUser();

  const {
    data: { body: votes },
  } = useSWR(user?.features?.includes('update:content:others') ? '/api/v1/status/votes' : null, {
    fallbackData: { body: { votesGraph } },
    refreshInterval: 60_000,
    shouldRetryOnError: false,
    dedupingInterval: 30_000,
    revalidateOnFocus: false,
  });

  const votesAmount = votes.votesGraph.edges.reduce((acc, curr) => acc + (curr.value || 0), 0);

  const {
    data: { body: statusObject },
    isLoading: statusObjectIsLoading,
  } = useSWR('/api/v1/status', {
    refreshInterval: 1000 * 10,
  });

  return (
    <DefaultLayout metadata={{ title: 'Estatísticas e Status do Site' }}>
      <Box sx={{ display: 'flex', flexDirection: 'column', width: '100%' }}>
        <Heading as="h1">Estatísticas e Status do Site</Heading>

        <BarChart title="Novos cadastros" data={usersCreated} yDataKey="cadastros" />

        <BarChart title="Novas publicações" data={rootContentPublished} yDataKey="conteudos" name="conteúdos" />

        <BarChart title="Novas respostas" data={childContentPublished} yDataKey="respostas" />

        <BarChart title="Novas qualificações" data={votesTaken} yDataKey="votos" />

        <Graph title={`Rede de qualificações (últimas ${votesAmount})`} data={votes.votesGraph} />

        <Box>
          <h2>Banco de Dados</h2>

          {!statusObjectIsLoading && (
            <Box sx={{ display: 'grid' }}>
              <Box>
                Status:{' '}
                <Label variant={statusObject?.dependencies.database.status ? 'success' : 'danger'}>
                  {statusObject?.dependencies.database.status}
                </Label>
              </Box>
              <Box>
                Conexões disponíveis:{' '}
                <Label variant={statusObject?.dependencies.database.max_connections > 70 ? 'success' : 'danger'}>
                  {statusObject?.dependencies.database.max_connections}
                </Label>
              </Box>
              <Box>
                Conexões abertas:{' '}
                <Label
                  variant={
                    statusObject?.dependencies.database.opened_connections <
                    statusObject?.dependencies.database.max_connections * 0.7
                      ? 'success'
                      : 'danger'
                  }>
                  {statusObject?.dependencies.database.opened_connections}
                </Label>
              </Box>
              <Box>
                Latência:{' '}
                <LabelGroup>
                  <Label variant={statusObject?.dependencies.database.latency.first_query < 200 ? 'success' : 'danger'}>
                    {`${Math.round(statusObject?.dependencies.database.latency.first_query)}ms`}
                  </Label>
                  <Label
                    variant={statusObject?.dependencies.database.latency.second_query < 200 ? 'success' : 'danger'}>
                    {`${Math.round(statusObject?.dependencies.database.latency.second_query)}ms`}
                  </Label>
                  <Label variant={statusObject?.dependencies.database.latency.third_query < 200 ? 'success' : 'danger'}>
                    {`${Math.round(statusObject?.dependencies.database.latency.third_query)}ms`}
                  </Label>
                </LabelGroup>
              </Box>
              <Box>
                Versão do PostgreSQL:{' '}
                <Label variant={statusObject?.dependencies.database.version ? 'success' : 'danger'}>
                  {statusObject?.dependencies.database.version}
                </Label>
              </Box>
            </Box>
          )}
        </Box>

        <Box>
          <h2>Servidor Web</h2>

          {!statusObjectIsLoading && (
            <Box sx={{ display: 'grid' }}>
              <Box>
                Status:{' '}
                <Label variant={statusObject?.dependencies.webserver.status ? 'success' : 'danger'}>
                  {statusObject?.dependencies.webserver.status}
                </Label>
              </Box>
              <Box>
                Provedor:{' '}
                <Label variant={statusObject?.dependencies.webserver.provider ? 'success' : 'danger'}>
                  {statusObject?.dependencies.webserver.provider}
                </Label>
              </Box>
              <Box>
                Ambiente:{' '}
                <Label variant={statusObject?.dependencies.webserver.environment ? 'success' : 'danger'}>
                  {statusObject?.dependencies.webserver.environment}
                </Label>
              </Box>
              <Box>
                Região na AWS:{' '}
                <Label variant={statusObject?.dependencies.webserver.aws_region ? 'success' : 'danger'}>
                  {statusObject?.dependencies.webserver.aws_region}
                </Label>
              </Box>
              <Box>
                Região na Vercel:{' '}
                <Label variant={statusObject?.dependencies.webserver.vercel_region ? 'success' : 'danger'}>
                  {statusObject?.dependencies.webserver.vercel_region}
                </Label>
              </Box>
              <Box>
                Timezone:{' '}
                <Label variant={statusObject?.dependencies.webserver.timezone ? 'success' : 'danger'}>
                  {statusObject?.dependencies.webserver.timezone}
                </Label>
              </Box>
              <Box>
                Autor do último commit:{' '}
                <Label variant={statusObject?.dependencies.webserver.last_commit_author ? 'success' : 'danger'}>
                  <Truncate inline expandable sx={{ maxWidth: '170px' }}>
                    {statusObject?.dependencies.webserver.last_commit_author}
                  </Truncate>
                </Label>
              </Box>
              <Box>
                SHA do commit:{' '}
                <Label variant={statusObject?.dependencies.webserver.last_commit_message_sha ? 'success' : 'danger'}>
                  <Truncate inline expandable sx={{ maxWidth: '170px' }}>
                    {statusObject?.dependencies.webserver.last_commit_message_sha}
                  </Truncate>
                </Label>
              </Box>
              <Box>
                Versão do Node.js:{' '}
                <Label variant={statusObject?.dependencies.webserver.version ? 'success' : 'danger'}>
                  {statusObject?.dependencies.webserver.version}
                </Label>
              </Box>
            </Box>
          )}
        </Box>

        <Box>
          <h2>Contribuidores</h2>

          <a href="https://github.com/filipedeschamps/tabnews.com.br/graphs/contributors">
            <picture>
              <img
                src="https://contributors-img.web.app/image?repo=filipedeschamps/tabnews.com.br&max=500"
                alt="Lista de contribuidores"
                width="100%"
              />
            </picture>
          </a>
        </Box>
      </Box>
    </DefaultLayout>
  );
}

export const getStaticProps = getStaticPropsRevalidate(async () => {
  const childContentPublished = await analytics.getChildContentsPublished();
  const rootContentPublished = await analytics.getRootContentsPublished();
  const usersCreated = await analytics.getUsersCreated();
  const votesGraph = await analytics.getVotesGraph();
  const votesTaken = await analytics.getVotesTaken();

  return {
    props: {
      usersCreated,
      rootContentPublished,
      childContentPublished,
      votesGraph,
      votesTaken,
    },
    revalidate: 30,
    swr: { refreshInterval: 1000 * 60 * 5 },
  };
});
</file>

<file path="pages/termos-de-uso/index.public.js">
import { Box, DefaultLayout, Heading, Viewer } from '@/TabNewsUI';

export default function Page() {
  const body = `Ao utilizar o TabNews você está de acordo com os seguintes termos:

  ## TabNews

  1. O TabNews tem como objetivo principal servir como plataforma para **conteúdos de valor concreto** para quem trabalha com **Programação** e **Tecnologia**.
  2. Consideramos conteúdos de valor concreto: notícias, artigos, tutoriais, indicações, curiosidades, perguntas bem formuladas ou qualquer outro tipo de conteúdo que poderá fazer alguma diferença na vida de quem trabalha em áreas diretamente ou indiretamente relacionadas ao **desenvolvimento de software**.
  3. Daremos preferência à **qualidade** sobre **quantidade**; neste ponto, especificamente, nosso objetivo é atingir um estágio onde **tudo o que você ler dentro do TabNews terá valido a pena**, de alguma forma.
  4. O TabNews é um **novo pedaço de internet** que **nunca** aplicará práticas malignas de engajamento, marketing, anúncios e **sempre protegerá o usuário** para que ele tenha a **clareza mental de que está navegando em um espaço livre de ameaças**.
  5. O TabNews **nunca venderá** os dados de seus usuários e **nunca compartilhará** informações com terceiros.
  6. O TabNews somente coletará dados que são fundamentalmente necessários para o **funcionamento** e **proteção** do serviço. Nosso princípio neste ponto é: quanto menos dados sobre o usuário coletarmos, menos dados sensíveis teremos em nossa base, logo, melhor estaremos posicionados no quesito proteção do serviço e usuários.

  ## Usuário

  1. O usuário do TabNews é uma pessoa brutalmente exata e empática, **simultaneamente**, onde o **termômetro** para entender se isso está sendo aplicado é simples: as pessoas estão se **afastando** ou se **aproximando** dentro de uma discussão?
  2. Qualquer usuário que através de suas publicações esteja propositalmente afastando outros usuários, que contenha posturas negativas aplicadas de forma genérica ou generalizada, que contenha sarcasmo gratuito, que esteja atacando ou sendo agressivo, poderá ter sua conta **permanentemente bloqueada**, junto com a invalidação de todas as suas publicações e ativos gerados por elas.
  3. O usuário se compromete a não manipular ou movimentar de forma artificial a qualificação das publicações e entende que, para um **ecossistema saudável**, isso precisa acontecer de forma espontânea. Qualquer manipulação, de qualquer natureza, poderá resultar no banimento permanente da conta do usuário.
  4. Da mesma forma, estão **estritamente proibidos** atos discriminatórios de qualquer tipo, como homofobia, transfobia, xenofobia, capacitismo, discriminação pelo sexo, idade, raça, cor, classe social ou qualquer outra forma de segregação.
  5. O usuário se compromete em não realizar publicações com foco **exclusivamente** comercial e se compromete em não utilizar técnicas passivas de _tracking_, como _tracking pixel_ ou qualquer outro tipo de identificação que não necessite da interação dos outros usuários do site. Apesar disto, será muito bem vindo o usuário realizar um \`Pitch\` sobre projetos em que esteja **diretamente envolvido** e que conseguirá devolver para comunidade conhecimentos sobre como o projeto foi executado, principalmente sobre a parte técnica.
  6. Caso o usuário descubra ou esbarre com alguma brecha de segurança do serviço e encontre **informações sensíveis** (por exemplo, dados privados de outros usuários, dados sensíveis do sistema ou acesso não autorizado), se compromete a reportar este caso de forma **privada** através do email \`contato@tabnews.com.br\`. Após o fechamento da falha, o TabNews se compromete em criar um **Postmortem público** com os detalhes do que aconteceu. Não temos interesse algum em esconder estes acontecimentos e queremos compartilhar todos os conhecimentos adquiridos e estratégia adotadas, mantendo em mente que protegeremos ao máximo dados sensíveis dos usuários. Falhas que não possuam informações sensíveis e não prejudicarão outros usuários poderão ser livremente reportadas no [repositório do projeto](https://github.com/filipedeschamps/tabnews.com.br).

  ## Direitos autorais e propriedade intelectual

  1. O usuário possui os direitos autorais sobre os conteúdos que publicou na plataforma e se responsabiliza integralmente por eles, declarando possuir os direitos de uso do que for publicado ou que o conteúdo está enquadrado dentro do "Fair Use" ("Limitação aos direitos de Autor" encontrado na \`LDA\`).
  2. A marca \`TabNews\`, junto ao serviço e o domínio \`tabnews.com.br\` são propriedades intelectuais pertencentes à \`Filipe Deschamps Tech Inc.\`, uma empresa localizada no Canadá.
  3. O sistema que utilizamos para o serviço do TabNews é um [projeto de código aberto](https://github.com/filipedeschamps/tabnews.com.br) e construído por esforços conjuntos e espontâneos da comunidade Open Source dentro da licença \`GPL-3.0\`.


  ## Garantias

  1. O TabNews é um projeto de natureza Open Source, com esforços feitos de forma espontânea e não oferecemos nenhuma garantia para a disponibilidade do serviço ou suporte. Apesar disto, a comunidade se esforça para entregar o melhor serviço e atenção possível.
  2. As moedas digitais \`TabCoins\` e \`TabCash\` possuem validade apenas dentro do ecossistema criado pelo próprio TabNews e não possuem vínculo ou lastro com ativos financeiros encontrados na economia real. Apesar de nossos esforços e de todas as regras estarem disponíveis em forma de código aberto, também não podemos nos responsabilizar por imprecisões neste serviço.

  ## Alterações nos Termos de Uso

  1. Os termos naturalmente poderão ser alterados quando necessário e estas alterações serão acompanhadas de publicações dentro do próprio TabNews. Iremos sempre destacar com linguajar simples e com total clareza quais alterações foram realizadas.

  ## Histórico de alterações

  * 2022-09-11 - Criação do documento através do PR [#728](https://github.com/filipedeschamps/tabnews.com.br/issues/728).
  `;

  return (
    <DefaultLayout metadata={{ title: 'Termos de Uso' }}>
      <Box>
        <Heading as="h1">Termos de Uso</Heading>
        <Viewer areLinksTrusted value={body} clobberPrefix="" />
      </Box>
    </DefaultLayout>
  );
}
</file>

<file path="pages/_app.public.js">
import { RevalidateProvider } from 'next-swr';
import { SWRConfig } from 'swr';
import '@tabnews/ui/css';

import { ThemeProvider, Turnstile } from '@/TabNewsUI';
import { Analytics, DefaultHead, UserProvider } from 'pages/interface';

async function SWRFetcher(resource, init) {
  const response = await fetch(resource, init);

  if (!response.ok) {
    throw new Error(response.statusText);
  }

  const responseBody = await response.json();

  return { body: responseBody, headers: response.headers };
}

const fallbackData = { body: null, headers: {} };

function MyApp({ Component, pageProps }) {
  return (
    <ThemeProvider>
      <Turnstile />
      <UserProvider>
        <DefaultHead />
        <SWRConfig value={{ fetcher: SWRFetcher, fallbackData }}>
          <RevalidateProvider swr={{ swrPath: '/api/v1/swr', ...pageProps.swr }}>
            <Component {...pageProps} />
          </RevalidateProvider>
        </SWRConfig>
        <Analytics />
      </UserProvider>
    </ThemeProvider>
  );
}

export default MyApp;
</file>

<file path="pages/_document.public.js">
import { configureDocument, Document } from '@tabnews/ui/document';

configureDocument({
  htmlProps: {
    lang: 'pt-BR',
  },
});

export default Document;
</file>

<file path="pages/404.public.js">
import Image from 'next/image';

import { Box, DefaultLayout, Link } from '@/TabNewsUI';
import botSleepyFaceDarkTransparent from 'public/brand/bot-sleepy-face-dark-transparent.svg';

export default function Custom404() {
  return (
    <DefaultLayout metadata={{ title: '404 - Página não encontrada' }}>
      <Box
        sx={{
          height: 'calc(90vh - 64px)',
          width: '100%',
          display: 'flex',
          alignContent: 'center',
          alignItems: 'center',
          justifyContent: 'center',
          flexDirection: 'column',
        }}>
        <Box sx={{ display: 'flex', alignItems: 'center', alignContent: 'center' }}>
          <Image
            src={botSleepyFaceDarkTransparent.src}
            height={100}
            width={100}
            sx={{ opacity: '0.7' }}
            alt="Ícone do Bot triste"
          />
          <Box
            sx={{
              height: '80px',
              margin: '10px',
              borderWidth: 0,
              borderLeftWidth: 1,
              borderColor: 'border.muted',
              borderStyle: 'solid',
              paddingRight: '10px',
            }}></Box>
          <h1>404</h1>
        </Box>
        <h2>Página não encontrada</h2>
        <Link href="/">Retornar à tela inicial</Link>
      </Box>
    </DefaultLayout>
  );
}
</file>

<file path="pages/500.public.js">
import Image from 'next/image';

import { Box, DefaultLayout, Link } from '@/TabNewsUI';
import botDeadFaceDarkTransparent from 'public/brand/bot-dead-face-dark-transparent.svg';

export default function Custom500() {
  return (
    <DefaultLayout metadata={{ title: '500 - Erro Interno Não Esperado' }}>
      <Box
        sx={{
          height: 'calc(90vh - 64px)',
          width: '100%',
          display: 'flex',
          alignContent: 'center',
          alignItems: 'center',
          justifyContent: 'center',
          flexDirection: 'column',
        }}>
        <Box sx={{ display: 'flex', alignItems: 'center', alignContent: 'center' }}>
          <Image
            src={botDeadFaceDarkTransparent.src}
            height={100}
            width={100}
            sx={{ opacity: '0.7' }}
            alt="Ícone do Bot desacordado"
          />
          <Box
            sx={{
              height: '80px',
              margin: '10px',
              borderWidth: 0,
              borderLeftWidth: 1,
              borderColor: 'border.muted',
              borderStyle: 'solid',
              paddingRight: '10px',
            }}></Box>
          <h1>500</h1>
        </Box>
        <h2>Um erro interno não esperado aconteceu.</h2>
        <Link href="/">Retornar à tela inicial</Link>
      </Box>
    </DefaultLayout>
  );
}
</file>

<file path="pages/index.public.js">
import { getStaticPropsRevalidate } from 'next-swr';

import { ContentList, DefaultLayout } from '@/TabNewsUI';
import { FaTree } from '@/TabNewsUI/icons';
import ad from 'models/advertisement';
import authorization from 'models/authorization.js';
import content from 'models/content.js';
import user from 'models/user.js';
import validator from 'models/validator.js';

export default function Home({ adFound, contentListFound, pagination }) {
  return (
    <DefaultLayout>
      <ContentList
        ad={adFound}
        contentList={contentListFound}
        pagination={pagination}
        paginationBasePath="/pagina"
        emptyStateProps={{
          title: 'Nenhum conteúdo encontrado',
          description: 'Quando eu cheguei era tudo mato...',
          icon: FaTree,
        }}
      />
    </DefaultLayout>
  );
}

export const getStaticProps = getStaticPropsRevalidate(async () => {
  const userTryingToGet = user.createAnonymous();

  const params = validator({}, { per_page: 'optional' });

  const results = await content.findWithStrategy({
    strategy: 'relevant',
    where: {
      parent_id: null,
      status: 'published',
    },
    attributes: {
      exclude: ['body'],
    },
    page: 1,
    per_page: params.per_page,
  });

  const contentListFound = results.rows;

  const secureContentValues = authorization.filterOutput(userTryingToGet, 'read:content:list', contentListFound);

  const adsFound = await ad.getRandom(1);
  const secureAdValues = authorization.filterOutput(userTryingToGet, 'read:ad:list', adsFound);

  return {
    props: {
      adFound: secureAdValues[0] ?? null,
      contentListFound: secureContentValues,
      pagination: results.pagination,
    },
    revalidate: 10,
  };
});
</file>

<file path="queries/prestigeQueries.js">
const byContentId = `
WITH content_events AS (
  SELECT
    id,
    originator_user_id,
    type
  FROM
    events
  WHERE
    metadata ->> 'id' = $1
    OR metadata ->> 'content_id' = $1
)
SELECT
  amount,
  content_events.type
FROM
  user_tabcoin_operations
INNER JOIN
  content_events
ON user_tabcoin_operations.originator_id = content_events.id
  AND (user_tabcoin_operations.recipient_id != content_events.originator_user_id
    OR content_events.type = 'create:content:text_root'
    OR content_events.type = 'create:content:text_child')
;
`;

const byUserId = `
WITH content_window AS ((
  SELECT
    id,
    published_at
  FROM contents
  WHERE
    owner_id = $1
    AND status = 'published'
    AND type = 'content'
    AND ($3 = FALSE OR parent_id IS NULL)
  ORDER BY
    published_at DESC
  LIMIT $4 OFFSET $5
)
UNION
  SELECT
    id,
    published_at
  FROM
    contents
  WHERE
    owner_id = $1
    AND status = 'published'
    AND type = 'content'
    AND published_at < $2
    AND ($3 = FALSE OR parent_id IS NULL)
  ORDER BY
    published_at DESC
  LIMIT $4
)
SELECT
  get_content_current_tabcoins(content_window.id) as tabcoins
FROM
  content_window
ORDER BY
  published_at ASC
LIMIT $4
;
`;

export default Object.freeze({
  byContentId,
  byUserId,
});
</file>

<file path="queries/rankingQueries.js">
const rankedContent = `
    WITH
    latest_published_child_contents AS (
        SELECT
            contents.owner_id,
            contents.path
        FROM contents
        WHERE
            parent_id IS NOT NULL
            AND status = 'published'
            AND published_at > NOW() - INTERVAL '1 day'
    ),
    latest_interacted_root_contents AS (
        SELECT
            contents.id,
            contents.owner_id,
            contents.published_at,
            tabcoins_count.total_balance as tabcoins,
            tabcoins_count.total_credit as tabcoins_credit,
            tabcoins_count.total_debit as tabcoins_debit
        FROM contents
        LEFT JOIN get_content_balance_credit_debit(contents.id) tabcoins_count ON true
        WHERE
            parent_id IS NULL
            AND status = 'published'
            AND published_at > NOW() - INTERVAL '7 days'
            AND type != 'ad'
        UNION
        SELECT
            contents.id,
            contents.owner_id,
            contents.published_at,
            tabcoins_count.total_balance as tabcoins,
            tabcoins_count.total_credit as tabcoins_credit,
            tabcoins_count.total_debit as tabcoins_debit
        FROM contents
        INNER JOIN latest_published_child_contents
            ON latest_published_child_contents.path[1] = contents.id
            AND latest_published_child_contents.owner_id != contents.owner_id
        LEFT JOIN get_content_balance_credit_debit(contents.id) tabcoins_count ON true
        WHERE
            parent_id IS NULL
            AND status = 'published'
            AND type != 'ad'
    ),
    ranked_published_root_contents AS (
        SELECT
            latest.*,
            (3 * tabcoins + (
                SELECT COUNT(DISTINCT all_contents.owner_id)
                FROM contents as all_contents
                WHERE all_contents.path @> ARRAY[latest.id]
                    AND all_contents.owner_id != latest.owner_id
                    AND all_contents.status = 'published'
            )) as score,
            COUNT(*) OVER()::INTEGER as total_rows
        FROM latest_interacted_root_contents AS latest
        WHERE tabcoins > 0
        ORDER BY
            tabcoins DESC,
            published_at DESC
    ),
    group_1 AS (
        SELECT
            *,
            1 as rank_group
        FROM ranked_published_root_contents
        WHERE
            published_at > NOW() - INTERVAL '36 hours'
            AND score > 16
        ORDER BY
            published_at DESC
        LIMIT 10
    ),
    group_2 AS (
        SELECT * FROM group_1
        UNION ALL
        SELECT
            *,
            2 as rank_group
        FROM ranked_published_root_contents
        WHERE
            published_at > NOW() - INTERVAL '24 hours'
            AND score > 8
            AND id NOT IN (SELECT id FROM group_1)
        ORDER BY
            rank_group,
            published_at DESC
        LIMIT 20
    ),
    group_3 AS (
        WITH new_contents_by_owner AS (
            SELECT DISTINCT ON (owner_id) *
            FROM ranked_published_root_contents
            WHERE
                published_at > NOW() - INTERVAL '12 hours'
                AND id NOT IN (SELECT id FROM group_2)
            ORDER BY
                owner_id,
                published_at DESC
        )(
            SELECT
                *,
                3 as rank_group
            FROM new_contents_by_owner
            ORDER BY published_at DESC
            LIMIT 4
        )
        UNION ALL
        SELECT * FROM group_2
    ),
    group_4 AS (
        (SELECT
            *,
            4 as rank_group
        FROM ranked_published_root_contents
        WHERE
            published_at > NOW() - INTERVAL '36 hours'
            AND score > 11
            AND id NOT IN (SELECT id FROM group_3)
        ORDER BY
            published_at DESC
        LIMIT 10)
        UNION ALL
        SELECT * FROM group_3
    ),
    group_5 AS (
        (SELECT
            *,
            5 as rank_group
        FROM ranked_published_root_contents
        WHERE
            published_at > NOW() - INTERVAL '3 days'
            AND score > 8
            AND id NOT IN (SELECT id FROM group_4)
        ORDER BY
            published_at DESC
        LIMIT 10)
        UNION ALL
        SELECT * FROM group_4
    ),
    ranked AS (
        SELECT * FROM group_5
        UNION ALL
        SELECT
            *,
            6 as rank_group
        FROM ranked_published_root_contents
        WHERE id NOT IN (SELECT id FROM group_5)
        ORDER BY
            rank_group,
            score DESC,
            published_at DESC
        LIMIT $1
        OFFSET $2
    )
    SELECT
        contents.id,
        contents.owner_id,
        contents.parent_id,
        contents.slug,
        contents.title,
        contents.status,
        contents.source_url,
        contents.created_at,
        contents.updated_at,
        contents.published_at,
        contents.deleted_at,
        ranked.tabcoins,
        ranked.tabcoins_credit,
        ranked.tabcoins_debit,
        ranked.total_rows,
        users.username as owner_username,
        (
            SELECT COUNT(*)
            FROM contents as all_contents
            WHERE all_contents.path @> ARRAY[ranked.id]
                AND all_contents.status = 'published'
        ) as children_deep_count
        FROM ranked
        INNER JOIN
          contents ON contents.id = ranked.id
        INNER JOIN users ON ranked.owner_id = users.id
        ORDER BY
            rank_group,
            score DESC,
            published_at DESC;
`;

export default Object.freeze({
  rankedContent,
});
</file>

<file path="tests/integration/api/v1/_use-cases/registration-flow.test.js">
import { version as uuidVersion } from 'uuid';

import activation from 'models/activation.js';
import password from 'models/password.js';
import session from 'models/session.js';
import user from 'models/user.js';
import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
  await orchestrator.deleteAllEmails();
});

describe('Use case: Registration Flow (all successfully)', () => {
  let postUserResponseBody;
  let tokenObjectInDatabase;
  let postSessionResponseBody;
  let parsedCookiesFromPost;

  test('Create account (successfully)', async () => {
    const postUserResponse = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        username: 'RegularRegistrationFlow',
        email: 'RegularRegistrationFlow@gmail.com',
        password: 'RegularRegistrationFlowPassword',
      }),
    });

    postUserResponseBody = await postUserResponse.json();

    expect.soft(postUserResponse.status).toBe(201);
    expect(uuidVersion(postUserResponseBody.id)).toBe(4);
    expect(postUserResponseBody.username).toBe('RegularRegistrationFlow');
    expect(postUserResponseBody.features).toStrictEqual(['read:activation_token']);
    expect(Date.parse(postUserResponseBody.created_at)).not.toBeNaN();
    expect(Date.parse(postUserResponseBody.updated_at)).not.toBeNaN();
    expect(postUserResponseBody).not.toHaveProperty('email');
    expect(postUserResponseBody).not.toHaveProperty('password');

    const createdUserInDatabase = await user.findOneByUsername('RegularRegistrationFlow');
    const passwordsMatch = await password.compare('RegularRegistrationFlowPassword', createdUserInDatabase.password);

    expect(passwordsMatch).toBe(true);

    const userInDatabase = await user.findOneById(postUserResponseBody.id);
    expect(userInDatabase.email).toBe('regularregistrationflow@gmail.com');
  });

  test('Receive email (successfully)', async () => {
    const activationEmail = await orchestrator.waitForFirstEmail();

    tokenObjectInDatabase = await activation.findOneTokenByUserId(postUserResponseBody.id);
    const activationPageEndpoint = `${activation.getActivationPageEndpoint()}/${tokenObjectInDatabase.id}`;

    expect(activationEmail.sender).toBe('<contato@tabnews.com.br>');
    expect(activationEmail.recipients).toStrictEqual(['<regularregistrationflow@gmail.com>']);
    expect(activationEmail.subject).toBe('Ative seu cadastro no TabNews');
    expect(activationEmail.text).toContain(postUserResponseBody.username);
    expect(activationEmail.html).toContain(postUserResponseBody.username);
    expect(activationEmail.text).toContain(activationPageEndpoint);
    expect(activationEmail.html).toContain(activationPageEndpoint);
  });

  test('Activate (successfully)', async () => {
    const activationApiEndpoint = activation.getActivationApiEndpoint();
    const activationApiResponse = await fetch(activationApiEndpoint, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        token_id: tokenObjectInDatabase.id,
      }),
    });
    const activationApiResponseBody = await activationApiResponse.json();

    expect.soft(activationApiResponse.status).toBe(200);
    expect(uuidVersion(activationApiResponseBody.id)).toBe(4);
    expect(activationApiResponseBody.id).toBe(tokenObjectInDatabase.id);
    expect(activationApiResponseBody.used).toBe(true);
    expect(Date.parse(activationApiResponseBody.created_at)).not.toBeNaN();
    expect(Date.parse(activationApiResponseBody.updated_at)).not.toBeNaN();
    expect(activationApiResponseBody).not.toHaveProperty('password');
    expect(activationApiResponseBody).not.toHaveProperty('email');
    expect(activationApiResponseBody).not.toHaveProperty('user_id');

    const activatedUserInDatabase = await user.findOneByUsername('RegularRegistrationFlow');
    expect(activatedUserInDatabase.features).toStrictEqual([
      'create:session',
      'read:session',
      'create:content',
      'create:content:text_root',
      'create:content:text_child',
      'update:content',
      'update:user',
    ]);
  });

  test('Login (successfully)', async () => {
    const postSessionResponse = await fetch(`${orchestrator.webserverUrl}/api/v1/sessions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        email: 'RegularRegistrationFlow@gmail.com',
        password: 'RegularRegistrationFlowPassword',
      }),
    });

    postSessionResponseBody = await postSessionResponse.json();

    expect.soft(postSessionResponse.status).toBe(201);
    expect(postSessionResponseBody.token.length).toBe(96);
    expect(uuidVersion(postSessionResponseBody.id)).toBe(4);
    expect(Date.parse(postSessionResponseBody.expires_at)).not.toBeNaN();
    expect(Date.parse(postSessionResponseBody.created_at)).not.toBeNaN();
    expect(Date.parse(postSessionResponseBody.updated_at)).not.toBeNaN();

    const sessionObjectInDatabase = await session.findOneById(postSessionResponseBody.id);
    expect(sessionObjectInDatabase.user_id).toBe(postUserResponseBody.id);

    parsedCookiesFromPost = orchestrator.parseSetCookies(postSessionResponse);
    expect(parsedCookiesFromPost.session_id.name).toBe('session_id');
    expect(parsedCookiesFromPost.session_id.value).toBe(postSessionResponseBody.token);
    expect(parsedCookiesFromPost.session_id.maxAge).toBe(60 * 60 * 24 * 30);
    expect(parsedCookiesFromPost.session_id.path).toBe('/');
    expect(parsedCookiesFromPost.session_id.httpOnly).toBe(true);
  });

  test('Get user (successfully)', async () => {
    const getUserResponse = await fetch(`${orchestrator.webserverUrl}/api/v1/user`, {
      method: 'GET',
      headers: {
        cookie: `session_id=${parsedCookiesFromPost.session_id.value}`,
      },
    });

    const getUserResponseBody = await getUserResponse.json();

    expect.soft(getUserResponse.status).toBe(200);
    expect(getUserResponseBody).toStrictEqual({
      id: postUserResponseBody.id,
      username: postUserResponseBody.username,
      email: 'regularregistrationflow@gmail.com',
      description: '',
      notifications: true,
      features: [
        'create:session',
        'read:session',
        'create:content',
        'create:content:text_root',
        'create:content:text_child',
        'update:content',
        'update:user',
      ],
      tabcoins: 0,
      tabcash: 0,
      created_at: postUserResponseBody.created_at,
      updated_at: getUserResponseBody.updated_at,
    });
  });
});
</file>

<file path="tests/integration/api/v1/activation/patch.test.js">
import { version as uuidVersion } from 'uuid';

import activation from 'models/activation.js';
import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('PATCH /api/v1/activation', () => {
  describe('Anonymous user', () => {
    test('Activating with blank body', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/activation`, {
        method: 'PATCH',
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"body" enviado deve ser do tipo Object.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('object');
    });

    test('Activating using a null token', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/activation`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: null,
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"token_id" deve ser do tipo String.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('token_id');
    });

    test('Activating using a malformatted number token', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/activation`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: 10000000,
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"token_id" deve ser do tipo String.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('token_id');
    });

    test('Activating using an empty string token', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/activation`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: '',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"token_id" não pode estar em branco.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('token_id');
    });

    test('Activating using a malformatted string token', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/activation`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: '10000000',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"token_id" deve possuir um token UUID na versão 4.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('token_id');
    });

    test('Activating using a fresh and valid token', async () => {
      const defaultUser = await orchestrator.createUser();
      const activationToken = await activation.create(defaultUser);

      expect(uuidVersion(activationToken.id)).toBe(4);
      expect(activationToken.user_id).toBe(defaultUser.id);
      expect(activationToken.used).toBe(false);
      expect(Date.parse(activationToken.expires_at)).not.toBeNaN();
      expect(Date.parse(activationToken.created_at)).not.toBeNaN();
      expect(Date.parse(activationToken.updated_at)).not.toBeNaN();
      expect(activationToken.expires_at - activationToken.created_at).toBe(900000); // 15 minutes

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/activation`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: activationToken.id,
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);
      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(responseBody.used).toBe(true);
      expect(Date.parse(activationToken.expires_at)).not.toBeNaN();
      expect(Date.parse(activationToken.created_at)).not.toBeNaN();
      expect(Date.parse(activationToken.updated_at)).not.toBeNaN();
      expect(responseBody.updated_at > responseBody.created_at).toBe(true);
    });

    test('Activating using an already used, but valid token', async () => {
      const defaultUser = await orchestrator.createUser();
      const activationToken = await activation.create(defaultUser);

      const firstTryResponde = await fetch(`${orchestrator.webserverUrl}/api/v1/activation`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: activationToken.id,
        }),
      });

      const firstTryRespondeBody = await firstTryResponde.json();

      const secondTryResponde = await fetch(`${orchestrator.webserverUrl}/api/v1/activation`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: activationToken.id,
        }),
      });

      const secondTryRespondeBody = await secondTryResponde.json();

      expect.soft(secondTryResponde.status).toBe(200);
      expect(uuidVersion(secondTryRespondeBody.id)).toBe(4);
      expect(secondTryRespondeBody.used).toBe(true);
      expect(Date.parse(activationToken.expires_at)).not.toBeNaN();
      expect(Date.parse(activationToken.created_at)).not.toBeNaN();
      expect(Date.parse(activationToken.updated_at)).not.toBeNaN();
      expect(secondTryRespondeBody.updated_at > secondTryRespondeBody.created_at).toBe(true);

      expect.soft(firstTryResponde.status).toBe(secondTryResponde.status);
      expect(firstTryRespondeBody).toStrictEqual(secondTryRespondeBody);
    });

    test('Activating using an expired token', async () => {
      const defaultUser = await orchestrator.createUser();
      const activationToken = await activation.create(defaultUser);
      await activation.update(activationToken.id, {
        expires_at: new Date(Date.now() - 1000),
      });

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/activation`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: activationToken.id,
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);
      expect.soft(responseBody.status_code).toBe(404);
      expect(responseBody.name).toBe('NotFoundError');
      expect(responseBody.message).toBe('O token de ativação utilizado não foi encontrado no sistema ou expirou.');
      expect(responseBody.action).toBe('Faça login novamente para receber um novo token por email.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:ACTIVATION:FIND_ONE_VALID_TOKEN_BY_ID:NOT_FOUND');
      expect(responseBody.key).toBe('token_id');
    });
  });

  describe('Default user', () => {
    test('Already active and trying to activate with a valid token (somehow)', async () => {
      let defaultUser = await orchestrator.createUser();
      defaultUser = await orchestrator.activateUser(defaultUser);
      const activationToken = await activation.create(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/activation`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: activationToken.id,
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(403);
      expect.soft(responseBody.status_code).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Você não pode mais ler tokens de ativação.');
      expect(responseBody.action).toBe(
        'Verifique se você já está logado ou tentando ativar novamente o seu ou outro usuário que já está ativo.',
      );
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:ACTIVATION:ACTIVATE_USER_BY_USER_ID:FEATURE_NOT_FOUND');
    });

    test('Already active, logged in and trying to activate with a valid token', async () => {
      let defaultUser = await orchestrator.createUser();
      defaultUser = await orchestrator.activateUser(defaultUser);
      const activationToken = await activation.create(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/activation`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },

        body: JSON.stringify({
          token_id: activationToken.id,
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(403);
      expect.soft(responseBody.status_code).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Usuário não pode executar esta operação.');
      expect(responseBody.action).toBe('Verifique se este usuário possui a feature "read:activation_token".');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND');
    });
  });
});
</file>

<file path="tests/integration/api/v1/contents/[username]/[slug]/children/get.test.js">
import { version as uuidVersion } from 'uuid';

import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('GET /api/v1/contents/[username]/[slug]/children', () => {
  describe('Anonymous user', () => {
    test('From "root" content with "draft" status', async () => {
      const defaultUser = await orchestrator.createUser();
      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Root content',
        status: 'draft',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${rootContent.slug}/children`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);
      expect.soft(responseBody.status_code).toBe(404);
      expect(responseBody.name).toBe('NotFoundError');
      expect(responseBody.message).toBe('O conteúdo informado não foi encontrado no sistema.');
      expect(responseBody.action).toBe('Verifique se o "slug" está digitado corretamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('CONTROLLER:CONTENT:CHILDREN:GET_HANDLER:SLUG_NOT_FOUND');
    });

    test('From "root" content with "deleted" status', async () => {
      const defaultUser = await orchestrator.createUser();
      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Root content',
        status: 'published',
      });

      await orchestrator.updateContent(rootContent.id, { status: 'deleted' });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${rootContent.slug}/children`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);
      expect.soft(responseBody.status_code).toBe(404);
      expect(responseBody.name).toBe('NotFoundError');
      expect(responseBody.message).toBe('O conteúdo informado não foi encontrado no sistema.');
      expect(responseBody.action).toBe('Verifique se o "slug" está digitado corretamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('CONTROLLER:CONTENT:CHILDREN:GET_HANDLER:SLUG_NOT_FOUND');
    });

    test('From "root" content with "published" status with no children', async () => {
      const defaultUser = await orchestrator.createUser();
      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Root content',
        status: 'published',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${rootContent.slug}/children`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);
      expect(responseBody).toStrictEqual([]);
    });

    test('From "root" content, ignore deleted child without children', async () => {
      const defaultUser = await orchestrator.createUser();

      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Root content',
        status: 'published',
      });

      const childContentDeleted = await orchestrator.createContent({
        parent_id: rootContent.id,
        owner_id: defaultUser.id,
        title: 'Child content [Deleted]',
        status: 'published',
      });
      await orchestrator.updateContent(childContentDeleted.id, { status: 'deleted' });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${rootContent.slug}/children`,
      );
      expect.soft(response.status).toBe(200);

      const responseBody = await response.json();
      expect(responseBody).toStrictEqual([]);
    });

    test('From "root" content, include child of deleted child', async () => {
      const defaultUser = await orchestrator.createUser();

      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Root content',
        status: 'published',
      });

      const childContentLevel1Deleted = await orchestrator.createContent({
        parent_id: rootContent.id,
        owner_id: defaultUser.id,
        title: 'Child content [Level 1] [Deleted]',
        status: 'published',
      });

      const childContentLevel2 = await orchestrator.createContent({
        parent_id: childContentLevel1Deleted.id,
        owner_id: defaultUser.id,
        title: 'Child content [Level 2] [Published]',
        status: 'published',
      });

      await orchestrator.updateContent(childContentLevel1Deleted.id, { status: 'deleted' });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${rootContent.slug}/children`,
      );
      expect.soft(response.status).toBe(200);

      const responseBody = await response.json();
      expect(responseBody).toStrictEqual([
        {
          id: childContentLevel1Deleted.id,
          parent_id: rootContent.id,
          children_deep_count: 1,
          type: 'content',
          children: [
            {
              id: childContentLevel2.id,
              owner_id: defaultUser.id,
              parent_id: childContentLevel1Deleted.id,
              slug: childContentLevel2.slug,
              title: childContentLevel2.title,
              body: childContentLevel2.body,
              tabcoins: 0,
              tabcoins_credit: 0,
              tabcoins_debit: 0,
              status: childContentLevel2.status,
              type: 'content',
              source_url: childContentLevel2.source_url,
              created_at: childContentLevel2.created_at.toISOString(),
              updated_at: childContentLevel2.updated_at.toISOString(),
              published_at: childContentLevel2.published_at.toISOString(),
              deleted_at: null,
              owner_username: defaultUser.username,
              children: [],
              children_deep_count: 0,
            },
          ],
        },
      ]);
    });

    test('From "root" content with "published" status with 6 "published" and 1 "draft" children', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const rootBranchLevel0 = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'root',
        status: 'published',
      });

      const childBranchALevel1 = await orchestrator.createContent({
        parent_id: rootBranchLevel0.id,
        owner_id: secondUser.id,
        title: 'Child branch A [Level 1]',
        status: 'published',
      });

      const childBranchALevel2 = await orchestrator.createContent({
        parent_id: childBranchALevel1.id,
        owner_id: firstUser.id,
        title: 'Child branch A [Level 2]',
        status: 'published',
      });

      const childBranchALevel3 = await orchestrator.createContent({
        parent_id: childBranchALevel2.id,
        owner_id: secondUser.id,
        title: 'Child branch A [Level 3]',
        status: 'published',
      });

      const childBranchBLevel1 = await orchestrator.createContent({
        parent_id: rootBranchLevel0.id,
        owner_id: secondUser.id,
        title: 'Child branch B [Level 1]',
        status: 'published',
      });

      const childBranchBLevel2Content1 = await orchestrator.createContent({
        parent_id: childBranchBLevel1.id,
        owner_id: firstUser.id,
        title: 'Child branch B [Level 2] #1',
        status: 'published',
      });

      const childBranchBLevel2Content2 = await orchestrator.createContent({
        parent_id: childBranchBLevel1.id,
        owner_id: secondUser.id,
        title: 'Child branch B [Level 2] #2',
        status: 'published',
      });

      // childBranchBLevel2Content3
      await orchestrator.createContent({
        parent_id: childBranchBLevel1.id,
        owner_id: firstUser.id,
        title: 'Child branch B [Level 2] #3 [Draft]',
        status: 'draft',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}/${rootBranchLevel0.slug}/children`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);
      expect(responseBody.length).toBe(2);
      expect(responseBody).toStrictEqual([
        {
          id: childBranchBLevel1.id,
          owner_id: secondUser.id,
          parent_id: rootBranchLevel0.id,
          slug: childBranchBLevel1.slug,
          title: childBranchBLevel1.title,
          body: childBranchBLevel1.body,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          status: childBranchBLevel1.status,
          type: 'content',
          source_url: childBranchBLevel1.source_url,
          created_at: childBranchBLevel1.created_at.toISOString(),
          updated_at: childBranchBLevel1.updated_at.toISOString(),
          published_at: childBranchBLevel1.published_at.toISOString(),
          deleted_at: null,
          owner_username: secondUser.username,
          children: [
            {
              id: childBranchBLevel2Content1.id,
              owner_id: firstUser.id,
              parent_id: childBranchBLevel1.id,
              slug: childBranchBLevel2Content1.slug,
              title: childBranchBLevel2Content1.title,
              body: childBranchBLevel2Content1.body,
              tabcoins: 1,
              tabcoins_credit: 0,
              tabcoins_debit: 0,
              status: childBranchBLevel2Content1.status,
              type: 'content',
              source_url: childBranchBLevel2Content1.source_url,
              created_at: childBranchBLevel2Content1.created_at.toISOString(),
              updated_at: childBranchBLevel2Content1.updated_at.toISOString(),
              published_at: childBranchBLevel2Content1.published_at.toISOString(),
              deleted_at: null,
              owner_username: firstUser.username,
              children: [],
              children_deep_count: 0,
            },
            {
              id: childBranchBLevel2Content2.id,
              owner_id: secondUser.id,
              parent_id: childBranchBLevel1.id,
              slug: childBranchBLevel2Content2.slug,
              title: childBranchBLevel2Content2.title,
              body: childBranchBLevel2Content2.body,
              tabcoins: 0,
              tabcoins_credit: 0,
              tabcoins_debit: 0,
              status: childBranchBLevel2Content2.status,
              type: 'content',
              source_url: childBranchBLevel2Content2.source_url,
              created_at: childBranchBLevel2Content2.created_at.toISOString(),
              updated_at: childBranchBLevel2Content2.updated_at.toISOString(),
              published_at: childBranchBLevel2Content2.published_at.toISOString(),
              deleted_at: null,
              owner_username: secondUser.username,
              children: [],
              children_deep_count: 0,
            },
          ],
          children_deep_count: 2,
        },
        {
          id: childBranchALevel1.id,
          owner_id: secondUser.id,
          parent_id: rootBranchLevel0.id,
          slug: childBranchALevel1.slug,
          title: childBranchALevel1.title,
          body: childBranchALevel1.body,
          status: childBranchALevel1.status,
          type: 'content',
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          source_url: childBranchALevel1.source_url,
          created_at: childBranchALevel1.created_at.toISOString(),
          updated_at: childBranchALevel1.updated_at.toISOString(),
          published_at: childBranchALevel1.published_at.toISOString(),
          deleted_at: null,
          owner_username: secondUser.username,
          children: [
            {
              id: childBranchALevel2.id,
              owner_id: firstUser.id,
              parent_id: childBranchALevel1.id,
              slug: childBranchALevel2.slug,
              title: childBranchALevel2.title,
              body: childBranchALevel2.body,
              status: childBranchALevel2.status,
              type: 'content',
              tabcoins: 1,
              tabcoins_credit: 0,
              tabcoins_debit: 0,
              source_url: childBranchALevel2.source_url,
              created_at: childBranchALevel2.created_at.toISOString(),
              updated_at: childBranchALevel2.updated_at.toISOString(),
              published_at: childBranchALevel2.published_at.toISOString(),
              deleted_at: null,
              owner_username: firstUser.username,
              children: [
                {
                  id: childBranchALevel3.id,
                  owner_id: secondUser.id,
                  parent_id: childBranchALevel2.id,
                  slug: childBranchALevel3.slug,
                  title: childBranchALevel3.title,
                  body: childBranchALevel3.body,
                  tabcoins: 1,
                  tabcoins_credit: 0,
                  tabcoins_debit: 0,
                  status: childBranchALevel3.status,
                  type: 'content',
                  source_url: childBranchALevel3.source_url,
                  created_at: childBranchALevel3.created_at.toISOString(),
                  updated_at: childBranchALevel3.updated_at.toISOString(),
                  published_at: childBranchALevel3.published_at.toISOString(),
                  deleted_at: null,
                  owner_username: secondUser.username,
                  children: [],
                  children_deep_count: 0,
                },
              ],
              children_deep_count: 1,
            },
          ],
          children_deep_count: 2,
        },
      ]);
    });

    test('From "child" content with "published" status with 2 "published" and 1 "draft" children', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const rootBranchLevel0 = await orchestrator.createContent({
        owner_id: secondUser.id,
        title: 'root',
        status: 'published',
      });

      const childBranchALevel1 = await orchestrator.createContent({
        parent_id: rootBranchLevel0.id,
        owner_id: firstUser.id,
        title: 'Child branch A [Level 1]',
        status: 'published',
      });

      const childBranchALevel2 = await orchestrator.createContent({
        parent_id: childBranchALevel1.id,
        owner_id: firstUser.id,
        title: 'Child branch A [Level 2]',
        status: 'published',
      });

      // childBranchALevel3
      await orchestrator.createContent({
        parent_id: childBranchALevel2.id,
        owner_id: firstUser.id,
        title: 'Child branch A [Level 3]',
        status: 'published',
      });

      const childBranchBLevel1 = await orchestrator.createContent({
        parent_id: rootBranchLevel0.id,
        owner_id: firstUser.id,
        title: 'Child branch B [Level 1]',
        status: 'published',
      });

      const childBranchBLevel2Content1 = await orchestrator.createContent({
        parent_id: childBranchBLevel1.id,
        owner_id: firstUser.id,
        title: 'Child branch B [Level 2] #1',
        status: 'published',
      });

      const childBranchBLevel2Content2 = await orchestrator.createContent({
        parent_id: childBranchBLevel1.id,
        owner_id: secondUser.id,
        title: 'Child branch B [Level 2] #2',
        status: 'published',
      });

      // childBranchBLevel2Content3
      await orchestrator.createContent({
        parent_id: childBranchBLevel1.id,
        owner_id: firstUser.id,
        title: 'Child branch B [Level 2] #3 [Draft]',
        status: 'draft',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}/${childBranchBLevel1.slug}/children`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);
      expect(responseBody.length).toBe(2);
      expect(responseBody).toStrictEqual([
        {
          id: childBranchBLevel2Content2.id,
          owner_id: secondUser.id,
          parent_id: childBranchBLevel1.id,
          slug: childBranchBLevel2Content2.slug,
          title: childBranchBLevel2Content2.title,
          body: childBranchBLevel2Content2.body,
          status: childBranchBLevel2Content2.status,
          type: 'content',
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          source_url: childBranchBLevel2Content2.source_url,
          created_at: childBranchBLevel2Content2.created_at.toISOString(),
          updated_at: childBranchBLevel2Content2.updated_at.toISOString(),
          published_at: childBranchBLevel2Content2.published_at.toISOString(),
          deleted_at: null,
          owner_username: secondUser.username,
          children: [],
          children_deep_count: 0,
        },
        {
          id: childBranchBLevel2Content1.id,
          owner_id: firstUser.id,
          parent_id: childBranchBLevel1.id,
          slug: childBranchBLevel2Content1.slug,
          title: childBranchBLevel2Content1.title,
          body: childBranchBLevel2Content1.body,
          status: childBranchBLevel2Content1.status,
          type: 'content',
          tabcoins: 0,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          source_url: childBranchBLevel2Content1.source_url,
          created_at: childBranchBLevel2Content1.created_at.toISOString(),
          updated_at: childBranchBLevel2Content1.updated_at.toISOString(),
          published_at: childBranchBLevel2Content1.published_at.toISOString(),
          deleted_at: null,
          owner_username: firstUser.username,
          children: [],
          children_deep_count: 0,
        },
      ]);
    });

    test('From published "child", ignore deleted child without children', async () => {
      const defaultUser = await orchestrator.createUser();

      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Root content',
        status: 'published',
      });

      const childContentLevel1 = await orchestrator.createContent({
        parent_id: rootContent.id,
        owner_id: defaultUser.id,
        title: 'Child content [Level 1]',
        status: 'published',
      });

      const childContentLevel2Deleted = await orchestrator.createContent({
        parent_id: childContentLevel1.id,
        owner_id: defaultUser.id,
        title: 'Child content [Level 2] [Deleted]',
        status: 'published',
      });
      await orchestrator.updateContent(childContentLevel2Deleted.id, { status: 'deleted' });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${childContentLevel1.slug}/children`,
      );
      expect.soft(response.status).toBe(200);

      const responseBody = await response.json();
      expect(responseBody).toStrictEqual([]);
    });

    test('From published "child", include child of deleted child', async () => {
      const defaultUser = await orchestrator.createUser();
      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Root content',
        status: 'published',
      });

      const childContentLevel1 = await orchestrator.createContent({
        parent_id: rootContent.id,
        owner_id: defaultUser.id,
        title: 'Child content [Level 1]',
        status: 'published',
      });

      const childContentLevel2Deleted = await orchestrator.createContent({
        parent_id: childContentLevel1.id,
        owner_id: defaultUser.id,
        title: 'Child content [Level 2] [Deleted]',
        status: 'published',
      });

      const childContentLevel3 = await orchestrator.createContent({
        parent_id: childContentLevel2Deleted.id,
        owner_id: defaultUser.id,
        title: 'Child content [Level 3]',
        status: 'published',
      });

      await orchestrator.updateContent(childContentLevel2Deleted.id, { status: 'deleted' });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${childContentLevel1.slug}/children`,
      );
      expect.soft(response.status).toBe(200);

      const responseBody = await response.json();
      expect(responseBody).toStrictEqual([
        {
          id: childContentLevel2Deleted.id,
          parent_id: childContentLevel1.id,
          children_deep_count: 1,
          type: 'content',
          children: [
            {
              id: childContentLevel3.id,
              owner_id: defaultUser.id,
              parent_id: childContentLevel2Deleted.id,
              slug: childContentLevel3.slug,
              title: childContentLevel3.title,
              body: childContentLevel3.body,
              tabcoins: 0,
              tabcoins_credit: 0,
              tabcoins_debit: 0,
              status: 'published',
              type: 'content',
              source_url: childContentLevel3.source_url,
              created_at: childContentLevel3.created_at.toISOString(),
              updated_at: childContentLevel3.updated_at.toISOString(),
              published_at: childContentLevel3.published_at.toISOString(),
              deleted_at: null,
              owner_username: defaultUser.username,
              children: [],
              children_deep_count: 0,
            },
          ],
        },
      ]);
    });

    test('From deleted "child", return "not found"', async () => {
      const defaultUser = await orchestrator.createUser();

      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Root content',
        status: 'published',
      });

      const childContentLevel1Deleted = await orchestrator.createContent({
        parent_id: rootContent.id,
        owner_id: defaultUser.id,
        title: 'Child content [Level 1] [Deleted]',
        status: 'published',
      });

      // childContentLevel2
      await orchestrator.createContent({
        parent_id: childContentLevel1Deleted.id,
        owner_id: defaultUser.id,
        title: 'Child content [Level 2]',
        status: 'published',
      });

      await orchestrator.updateContent(childContentLevel1Deleted.id, { status: 'deleted' });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${childContentLevel1Deleted.slug}/children`,
      );
      expect.soft(response.status).toBe(404);

      const responseBody = await response.json();
      expect(responseBody).toStrictEqual({
        status_code: 404,
        name: 'NotFoundError',
        message: 'O conteúdo informado não foi encontrado no sistema.',
        action: 'Verifique se o "slug" está digitado corretamente.',
        key: 'slug',
        error_id: expect.any(String),
        request_id: expect.any(String),
        error_location_code: 'CONTROLLER:CONTENT:CHILDREN:GET_HANDLER:SLUG_NOT_FOUND',
      });
    });

    test('Tree with TabCoins credits and debits', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const rootBranchLevel0 = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'root',
        status: 'published',
      });

      const childBranchALevel1 = await orchestrator.createContent({
        parent_id: rootBranchLevel0.id,
        owner_id: secondUser.id,
        title: 'Child branch A [Level 1]',
        status: 'published',
      });

      const childBranchALevel2 = await orchestrator.createContent({
        parent_id: childBranchALevel1.id,
        owner_id: firstUser.id,
        title: 'Child branch A [Level 2]',
        status: 'published',
      });

      const childBranchBLevel1 = await orchestrator.createContent({
        parent_id: rootBranchLevel0.id,
        owner_id: secondUser.id,
        title: 'Child branch B [Level 1]',
        status: 'published',
      });

      await orchestrator.createRate(childBranchALevel2, 4);

      await orchestrator.createRate(childBranchBLevel1, 2);
      await orchestrator.createRate(childBranchBLevel1, -1);

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}/${rootBranchLevel0.slug}/children`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);
      expect(responseBody.length).toBe(2);
      expect(responseBody).toStrictEqual([
        {
          id: childBranchBLevel1.id,
          owner_id: secondUser.id,
          parent_id: rootBranchLevel0.id,
          slug: childBranchBLevel1.slug,
          title: childBranchBLevel1.title,
          body: childBranchBLevel1.body,
          tabcoins: 2,
          tabcoins_credit: 2,
          tabcoins_debit: -1,
          status: childBranchBLevel1.status,
          type: 'content',
          source_url: childBranchBLevel1.source_url,
          created_at: childBranchBLevel1.created_at.toISOString(),
          updated_at: childBranchBLevel1.updated_at.toISOString(),
          published_at: childBranchBLevel1.published_at.toISOString(),
          deleted_at: null,
          owner_username: secondUser.username,
          children: [],
          children_deep_count: 0,
        },
        {
          id: childBranchALevel1.id,
          owner_id: secondUser.id,
          parent_id: rootBranchLevel0.id,
          slug: childBranchALevel1.slug,
          title: childBranchALevel1.title,
          body: childBranchALevel1.body,
          status: childBranchALevel1.status,
          type: 'content',
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          source_url: childBranchALevel1.source_url,
          created_at: childBranchALevel1.created_at.toISOString(),
          updated_at: childBranchALevel1.updated_at.toISOString(),
          published_at: childBranchALevel1.published_at.toISOString(),
          deleted_at: null,
          owner_username: secondUser.username,
          children: [
            {
              id: childBranchALevel2.id,
              owner_id: firstUser.id,
              parent_id: childBranchALevel1.id,
              slug: childBranchALevel2.slug,
              title: childBranchALevel2.title,
              body: childBranchALevel2.body,
              status: childBranchALevel2.status,
              type: 'content',
              tabcoins: 5,
              tabcoins_credit: 4,
              tabcoins_debit: 0,
              source_url: childBranchALevel2.source_url,
              created_at: childBranchALevel2.created_at.toISOString(),
              updated_at: childBranchALevel2.updated_at.toISOString(),
              published_at: childBranchALevel2.published_at.toISOString(),
              deleted_at: null,
              owner_username: firstUser.username,
              children: [],
              children_deep_count: 0,
            },
          ],
          children_deep_count: 1,
        },
      ]);
    });
  });
});
</file>

<file path="tests/integration/api/v1/contents/[username]/[slug]/parent/get.test.js">
import { version as uuidVersion } from 'uuid';

import { relevantBody } from 'tests/constants-for-tests';
import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('GET /api/v1/contents/[username]/[slug]/parent', () => {
  describe('Anonymous user', () => {
    test('From "root" content with "draft" status', async () => {
      const defaultUser = await orchestrator.createUser();
      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Root content',
        status: 'draft',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${rootContent.slug}/parent`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'O conteúdo informado não foi encontrado no sistema.',
        action: 'Verifique se o "slug" está digitado corretamente.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'CONTROLLER:CONTENT:PARENT:GET_HANDLER:SLUG_NOT_FOUND',
        key: 'slug',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('From "root" content with "deleted" status', async () => {
      const defaultUser = await orchestrator.createUser();
      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Root content',
        status: 'published',
      });

      await orchestrator.updateContent(rootContent.id, { status: 'deleted' });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${rootContent.slug}/parent`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'O conteúdo informado não foi encontrado no sistema.',
        action: 'Verifique se o "slug" está digitado corretamente.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'CONTROLLER:CONTENT:PARENT:GET_HANDLER:SLUG_NOT_FOUND',
        key: 'slug',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('From "root" content with "published" status', async () => {
      const defaultUser = await orchestrator.createUser();
      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Root content',
        status: 'published',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${rootContent.slug}/parent`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'O conteúdo requisitado é um conteúdo raiz.',
        action:
          'Busque apenas por conteúdos com "parent_id", pois este conteúdo não possui níveis superiores na árvore de conteúdos.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'CONTROLLER:CONTENT:PARENT:GET_HANDLER:ALREADY_ROOT',
        key: 'parent_id',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('From "child" content 1 level deep with "draft" status', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const rootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root content title',
        body: 'Root content body',
        status: 'published',
      });

      const childContentLevel1 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: rootContent.id,
        title: 'Child content title Level 1',
        body: 'Child content body Level 1',
        status: 'draft',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${secondUser.username}/${childContentLevel1.slug}/parent`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'O conteúdo informado não foi encontrado no sistema.',
        action: 'Verifique se o "slug" está digitado corretamente.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'CONTROLLER:CONTENT:PARENT:GET_HANDLER:SLUG_NOT_FOUND',
        key: 'slug',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('From "child" content 1 level deep with "deleted" status', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const rootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root content title',
        body: 'Root content body',
        status: 'published',
      });

      const childContentLevel1 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: rootContent.id,
        title: 'Child content title Level 1',
        body: 'Child content body Level 1',
        status: 'published',
      });

      await orchestrator.updateContent(childContentLevel1.id, {
        status: 'deleted',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${secondUser.username}/${childContentLevel1.slug}/parent`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'O conteúdo informado não foi encontrado no sistema.',
        action: 'Verifique se o "slug" está digitado corretamente.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'CONTROLLER:CONTENT:PARENT:GET_HANDLER:SLUG_NOT_FOUND',
        key: 'slug',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('From "child" content 1 level deep with "published" status', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const rootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root content title',
        body: relevantBody,
        status: 'published',
      });

      const childContentLevel1 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: rootContent.id,
        title: 'Child content title Level 1',
        body: 'Child content body Level 1 - relevant content',
        status: 'published',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${secondUser.username}/${childContentLevel1.slug}/parent`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: rootContent.id,
        parent_id: null,
        owner_id: firstUser.id,
        slug: 'root-content-title',
        title: 'Root content title',
        body: relevantBody,
        children_deep_count: 1,
        status: 'published',
        type: 'content',
        source_url: null,
        published_at: rootContent.published_at.toISOString(),
        created_at: rootContent.created_at.toISOString(),
        updated_at: rootContent.updated_at.toISOString(),
        deleted_at: null,
        owner_username: firstUser.username,
        tabcoins: 1,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
      });
    });

    test('From "child" content 3 level deep, with all "published"', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const rootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root content title',
        body: 'Root content body',
        status: 'published',
      });

      const childContentLevel1 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: rootContent.id,
        title: 'Child content title Level 1',
        body: 'Child content body Level 1',
        status: 'published',
      });

      const childContentLevel2 = await orchestrator.createContent({
        owner_id: firstUser.id,
        parent_id: childContentLevel1.id,
        title: 'Child content title Level 2',
        body: 'Child content body Level 2 - relevant content',
        status: 'published',
      });

      const childContentLevel3 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: childContentLevel2.id,
        title: 'Child content title Level 3',
        body: 'Child content body Level 3',
        status: 'published',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${secondUser.username}/${childContentLevel3.slug}/parent`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: childContentLevel2.id,
        parent_id: childContentLevel1.id,
        owner_id: firstUser.id,
        slug: 'child-content-title-level-2',
        title: 'Child content title Level 2',
        body: 'Child content body Level 2 - relevant content',
        children_deep_count: 1,
        status: 'published',
        type: 'content',
        source_url: null,
        published_at: childContentLevel2.published_at.toISOString(),
        created_at: childContentLevel2.created_at.toISOString(),
        updated_at: childContentLevel2.updated_at.toISOString(),
        deleted_at: null,
        owner_username: firstUser.username,
        tabcoins: 1,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
      });
    });

    test('From "child" content 3 level deep, but "parent" with "draft" status', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const rootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root content title',
        body: 'Root content body',
        status: 'published',
      });

      const childContentLevel1 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: rootContent.id,
        title: 'Child content title Level 1',
        body: 'Child content body Level 1',
        status: 'published',
      });

      const childContentLevel2 = await orchestrator.createContent({
        owner_id: firstUser.id,
        parent_id: childContentLevel1.id,
        title: 'Child content title Level 2',
        body: 'Child content body Level 2',
      });

      const childContentLevel2Drafted = await orchestrator.updateContent(childContentLevel2.id, {
        status: 'draft',
      });

      const childContentLevel3 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: childContentLevel2.id,
        title: 'Child content title Level 3',
        body: 'Child content body Level 3',
        status: 'published',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${secondUser.username}/${childContentLevel3.slug}/parent`,
      );

      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: childContentLevel2.id,
        parent_id: childContentLevel1.id,
        children_deep_count: 1,
        status: 'draft',
        type: 'content',
        published_at: null,
        created_at: childContentLevel2.created_at.toISOString(),
        updated_at: childContentLevel2Drafted.updated_at.toISOString(),
        deleted_at: null,
      });
    });

    test('From "child" content 3 level deep, but "parent" with "deleted" status', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const rootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root content title',
        body: 'Root content body',
        status: 'published',
      });

      const childContentLevel1 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: rootContent.id,
        title: 'Child content title Level 1',
        body: 'Child content body Level 1',
        status: 'published',
      });

      const childContentLevel2 = await orchestrator.createContent({
        owner_id: firstUser.id,
        parent_id: childContentLevel1.id,
        title: 'Child content title Level 2',
        body: 'Child content body Level 2 - deleted parent',
        status: 'published',
      });

      const childContentLevel2Deleted = await orchestrator.updateContent(childContentLevel2.id, {
        status: 'deleted',
      });

      const childContentLevel3 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: childContentLevel2.id,
        title: 'Child content title Level 3',
        body: 'Child content body Level 3',
        status: 'published',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${secondUser.username}/${childContentLevel3.slug}/parent`,
      );

      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: childContentLevel2.id,
        parent_id: childContentLevel1.id,
        children_deep_count: 1,
        status: 'deleted',
        type: 'content',
        published_at: childContentLevel2.published_at.toISOString(),
        created_at: childContentLevel2.created_at.toISOString(),
        updated_at: childContentLevel2Deleted.updated_at.toISOString(),
        deleted_at: childContentLevel2Deleted.deleted_at.toISOString(),
      });
    });

    test('Parent containing TabCoins credits and debits', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const rootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root content title',
        body: relevantBody,
        status: 'published',
      });

      const childContentLevel1 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: rootContent.id,
        title: 'Child content title Level 1',
        body: 'Child content body Level 1',
        status: 'published',
      });

      await orchestrator.createRate(rootContent, 10);
      await orchestrator.createRate(rootContent, -11);

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${secondUser.username}/${childContentLevel1.slug}/parent`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: rootContent.id,
        parent_id: null,
        owner_id: firstUser.id,
        slug: 'root-content-title',
        title: 'Root content title',
        body: relevantBody,
        children_deep_count: 1,
        status: 'published',
        type: 'content',
        source_url: null,
        published_at: rootContent.published_at.toISOString(),
        created_at: rootContent.created_at.toISOString(),
        updated_at: rootContent.updated_at.toISOString(),
        deleted_at: null,
        owner_username: firstUser.username,
        tabcoins: 0,
        tabcoins_credit: 10,
        tabcoins_debit: -11,
      });
    });
  });
});
</file>

<file path="tests/integration/api/v1/contents/[username]/[slug]/root/get.test.js">
import { version as uuidVersion } from 'uuid';

import { relevantBody } from 'tests/constants-for-tests';
import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('GET /api/v1/contents/[username]/[slug]/root', () => {
  describe('Anonymous user', () => {
    test('From "root" content with "draft" status', async () => {
      const defaultUser = await orchestrator.createUser();
      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Root content',
        status: 'draft',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${rootContent.slug}/root`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'O conteúdo informado não foi encontrado no sistema.',
        action: 'Verifique se o "slug" está digitado corretamente.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'CONTROLLER:CONTENT:ROOT:GET_HANDLER:SLUG_NOT_FOUND',
        key: 'slug',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('From "root" content with "deleted" status', async () => {
      const defaultUser = await orchestrator.createUser();
      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Root content',
        status: 'published',
      });

      await orchestrator.updateContent(rootContent.id, { status: 'deleted' });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${rootContent.slug}/root`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'O conteúdo informado não foi encontrado no sistema.',
        action: 'Verifique se o "slug" está digitado corretamente.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'CONTROLLER:CONTENT:ROOT:GET_HANDLER:SLUG_NOT_FOUND',
        key: 'slug',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('From "root" content with "published" status', async () => {
      const defaultUser = await orchestrator.createUser();
      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Root content',
        status: 'published',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${rootContent.slug}/root`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'O conteúdo requisitado é um conteúdo raiz.',
        action:
          'Busque apenas por conteúdos com "parent_id", pois este conteúdo não possui níveis superiores na árvore de conteúdos.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'CONTROLLER:CONTENT:ROOT:GET_HANDLER:ALREADY_ROOT',
        key: 'parent_id',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('From "child" content 1 level deep with "draft" status', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const rootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root content title',
        body: 'Root content body',
        status: 'published',
      });

      const childContentLevel1 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: rootContent.id,
        title: 'Child content title Level 1',
        body: 'Child content body Level 1',
        status: 'draft',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${secondUser.username}/${childContentLevel1.slug}/root`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'O conteúdo informado não foi encontrado no sistema.',
        action: 'Verifique se o "slug" está digitado corretamente.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'CONTROLLER:CONTENT:ROOT:GET_HANDLER:SLUG_NOT_FOUND',
        key: 'slug',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('From "child" content 1 level deep with "deleted" status', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const rootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root content title',
        body: 'Root content body',
        status: 'published',
      });

      const childContentLevel1 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: rootContent.id,
        title: 'Child content title Level 1',
        body: 'Child content body Level 1',
        status: 'published',
      });

      await orchestrator.updateContent(childContentLevel1.id, {
        status: 'deleted',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${secondUser.username}/${childContentLevel1.slug}/root`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'O conteúdo informado não foi encontrado no sistema.',
        action: 'Verifique se o "slug" está digitado corretamente.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'CONTROLLER:CONTENT:ROOT:GET_HANDLER:SLUG_NOT_FOUND',
        key: 'slug',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('From "child" content 1 level deep with "published" status', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const rootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root content title',
        body: relevantBody,
        status: 'published',
      });

      const childContentLevel1 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: rootContent.id,
        title: 'Child content title Level 1',
        body: 'Child content body Level 1',
        status: 'published',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${secondUser.username}/${childContentLevel1.slug}/root`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: rootContent.id,
        parent_id: null,
        owner_id: firstUser.id,
        slug: 'root-content-title',
        title: 'Root content title',
        body: relevantBody,
        children_deep_count: 1,
        status: 'published',
        type: 'content',
        source_url: null,
        published_at: rootContent.published_at.toISOString(),
        created_at: rootContent.created_at.toISOString(),
        updated_at: rootContent.updated_at.toISOString(),
        deleted_at: null,
        owner_username: firstUser.username,
        tabcoins: 1,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
      });
    });

    test('From "child" content 3 level deep, with all "published"', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const rootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root content title',
        body: relevantBody,
        status: 'published',
      });

      const childContentLevel1 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: rootContent.id,
        title: 'Child content title Level 1',
        body: 'Child content body Level 1',
        status: 'published',
      });

      const childContentLevel2 = await orchestrator.createContent({
        owner_id: firstUser.id,
        parent_id: childContentLevel1.id,
        title: 'Child content title Level 2',
        body: 'Child content body Level 2',
        status: 'published',
      });

      const childContentLevel3 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: childContentLevel2.id,
        title: 'Child content title Level 3',
        body: 'Child content body Level 3',
        status: 'published',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${secondUser.username}/${childContentLevel3.slug}/root`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: rootContent.id,
        parent_id: null,
        owner_id: firstUser.id,
        slug: 'root-content-title',
        title: 'Root content title',
        body: relevantBody,
        children_deep_count: 3,
        status: 'published',
        type: 'content',
        source_url: null,
        published_at: rootContent.published_at.toISOString(),
        created_at: rootContent.created_at.toISOString(),
        updated_at: rootContent.updated_at.toISOString(),
        deleted_at: null,
        owner_username: firstUser.username,
        tabcoins: 1,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
      });
    });

    test('From "child" content 3 level deep, with one "deleted" in the middle', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const rootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root content title',
        body: relevantBody,
        status: 'published',
      });

      const childContentLevel1 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: rootContent.id,
        title: 'Child content title Level 1',
        body: 'Child content body Level 1',
        status: 'published',
      });

      const childContentLevel2 = await orchestrator.createContent({
        owner_id: firstUser.id,
        parent_id: childContentLevel1.id,
        title: 'Child content title Level 2',
        body: 'Child content body Level 2',
        status: 'published',
      });

      await orchestrator.updateContent(childContentLevel2.id, {
        status: 'deleted',
      });

      const childContentLevel3 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: childContentLevel2.id,
        title: 'Child content title Level 3',
        body: 'Child content body Level 3',
        status: 'published',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${secondUser.username}/${childContentLevel3.slug}/root`,
      );

      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: rootContent.id,
        parent_id: null,
        owner_id: firstUser.id,
        slug: 'root-content-title',
        title: 'Root content title',
        body: relevantBody,
        children_deep_count: 2,
        status: 'published',
        type: 'content',
        source_url: null,
        published_at: rootContent.published_at.toISOString(),
        created_at: rootContent.created_at.toISOString(),
        updated_at: rootContent.updated_at.toISOString(),
        deleted_at: null,
        owner_username: firstUser.username,
        tabcoins: 1,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
      });
    });

    test('From "child" content 3 level deep, but "root" with "draft" status', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const rootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root content title',
        body: 'Root content body',
        source_url: 'https://www.tabnews.com.br/',
      });

      const childContentLevel1 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: rootContent.id,
        title: 'Child content title Level 1',
        body: 'Child content body Level 1',
        status: 'published',
      });

      const childContentLevel2 = await orchestrator.createContent({
        owner_id: firstUser.id,
        parent_id: childContentLevel1.id,
        title: 'Child content title Level 2',
        body: 'Child content body Level 2',
        status: 'published',
      });

      const childContentLevel3 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: childContentLevel2.id,
        title: 'Child content title Level 3',
        body: 'Child content body Level 3',
        status: 'published',
      });

      const rootContentDrafted = await orchestrator.updateContent(rootContent.id, {
        status: 'draft',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${secondUser.username}/${childContentLevel3.slug}/root`,
      );

      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: rootContent.id,
        parent_id: null,
        children_deep_count: 3,
        status: 'draft',
        type: 'content',
        published_at: null,
        created_at: rootContent.created_at.toISOString(),
        updated_at: rootContentDrafted.updated_at.toISOString(),
        deleted_at: null,
      });
    });

    test('From "child" content 3 level deep, but "root" with "deleted" status', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const rootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root content title',
        body: relevantBody,
        status: 'published',
        source_url: 'https://www.tabnews.com.br/',
      });

      const childContentLevel1 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: rootContent.id,
        title: 'Child content title Level 1',
        body: 'Child content body Level 1',
        status: 'published',
      });

      const childContentLevel2 = await orchestrator.createContent({
        owner_id: firstUser.id,
        parent_id: childContentLevel1.id,
        title: 'Child content title Level 2',
        body: 'Child content body Level 2',
        status: 'published',
      });

      const childContentLevel3 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: childContentLevel2.id,
        title: 'Child content title Level 3',
        body: 'Child content body Level 3',
        status: 'published',
      });

      const rootContentDeleted = await orchestrator.updateContent(rootContent.id, {
        status: 'deleted',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${secondUser.username}/${childContentLevel3.slug}/root`,
      );

      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: rootContent.id,
        parent_id: null,
        children_deep_count: 3,
        status: 'deleted',
        type: 'content',
        published_at: rootContent.published_at.toISOString(),
        created_at: rootContent.created_at.toISOString(),
        updated_at: rootContentDeleted.updated_at.toISOString(),
        deleted_at: rootContentDeleted.deleted_at.toISOString(),
      });
    });

    test('Root containing TabCoins credits and debits', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const rootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root content title',
        body: relevantBody,
        status: 'published',
      });

      await orchestrator.createRate(rootContent, 2);
      await orchestrator.createRate(rootContent, -6);

      const childContentLevel1 = await orchestrator.createContent({
        owner_id: secondUser.id,
        parent_id: rootContent.id,
        title: 'Child content title Level 1',
        body: 'Child content body Level 1',
        status: 'published',
      });

      const childContentLevel2 = await orchestrator.createContent({
        owner_id: firstUser.id,
        parent_id: childContentLevel1.id,
        title: 'Child content title Level 2',
        body: 'Child content body Level 2',
        status: 'published',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}/${childContentLevel2.slug}/root`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: rootContent.id,
        parent_id: null,
        owner_id: firstUser.id,
        slug: 'root-content-title',
        title: 'Root content title',
        body: relevantBody,
        children_deep_count: 2,
        status: 'published',
        type: 'content',
        source_url: null,
        published_at: rootContent.published_at.toISOString(),
        created_at: rootContent.created_at.toISOString(),
        updated_at: rootContent.updated_at.toISOString(),
        deleted_at: null,
        owner_username: firstUser.username,
        tabcoins: -3,
        tabcoins_credit: 2,
        tabcoins_debit: -6,
      });
    });
  });
});
</file>

<file path="tests/integration/api/v1/contents/[username]/[slug]/tabcoins/post.test.js">
import { relevantBody } from 'tests/constants-for-tests';
import orchestrator from 'tests/orchestrator.js';
import RequestBuilder from 'tests/request-builder';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('POST /api/v1/contents/tabcoins', () => {
  describe('Anonymous user', () => {
    test('Not logged in', async () => {
      const defaultUser = await orchestrator.createUser();
      await orchestrator.activateUser(defaultUser);

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Title',
        body: 'Body',
        status: 'published',
      });

      const tabcoinsRequestBuilder = new RequestBuilder(
        `/api/v1/contents/${defaultUser.username}/${defaultUserContent.slug}/tabcoins`,
      );

      const { response, responseBody } = await tabcoinsRequestBuilder.post({
        transaction_type: 'credit',
      });

      expect.soft(response.status).toBe(403);

      expect(responseBody).toStrictEqual({
        name: 'ForbiddenError',
        message: 'Usuário não pode executar esta operação.',
        action: 'Verifique se este usuário possui a feature "update:content".',
        status_code: 403,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND',
      });
    });
  });

  describe('Default user', () => {
    test('With no "transaction_type"', async () => {
      const firstUser = await orchestrator.createUser();
      const firstUserContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root',
        body: 'Body',
        status: 'published',
      });

      const tabcoinsRequestBuilder = new RequestBuilder(
        `/api/v1/contents/${firstUser.username}/${firstUserContent.slug}/tabcoins`,
      );
      await tabcoinsRequestBuilder.buildUser();

      const { response, responseBody } = await tabcoinsRequestBuilder.post({});

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"transaction_type" é um campo obrigatório.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'transaction_type',
        type: 'any.required',
      });
    });

    test('With not enough TabCoins', async () => {
      const firstUser = await orchestrator.createUser();
      const firstUserContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root',
        body: 'Body',
        status: 'published',
      });

      const tabcoinsRequestBuilder = new RequestBuilder(
        `/api/v1/contents/${firstUser.username}/${firstUserContent.slug}/tabcoins`,
      );
      await tabcoinsRequestBuilder.buildUser();

      const { response, responseBody } = await tabcoinsRequestBuilder.post({
        transaction_type: 'credit',
      });

      expect.soft(response.status).toBe(422);

      expect(responseBody).toStrictEqual({
        name: 'UnprocessableEntityError',
        message: 'Não foi possível adicionar TabCoins nesta publicação.',
        action: 'Você precisa de pelo menos 2 TabCoins para realizar esta ação.',
        status_code: 422,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:BALANCE:RATE_CONTENT:NOT_ENOUGH',
      });
    });

    test('With "transaction_type" set to "credit"', async () => {
      const firstUser = await orchestrator.createUser();
      const firstUserContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root',
        body: relevantBody,
        status: 'published',
      });

      const tabcoinsRequestBuilder = new RequestBuilder(
        `/api/v1/contents/${firstUser.username}/${firstUserContent.slug}/tabcoins`,
      );
      const secondUser = await tabcoinsRequestBuilder.buildUser();

      await orchestrator.createBalance({
        balanceType: 'user:tabcoin',
        recipientId: secondUser.id,
        amount: 2,
      });

      const { response: postTabCoinsResponse, responseBody: postTabCoinsResponseBody } =
        await tabcoinsRequestBuilder.post({
          transaction_type: 'credit',
        });

      expect.soft(postTabCoinsResponse.status).toBe(201);

      expect(postTabCoinsResponseBody).toStrictEqual({
        tabcoins: 2,
        tabcoins_credit: 1,
        tabcoins_debit: 0,
      });

      const usersRequestBuilder = new RequestBuilder('/api/v1/users');
      const { responseBody: firstUserResponseBody } = await usersRequestBuilder.get(`/${firstUser.username}`);

      expect(firstUserResponseBody.tabcoins).toBe(1);
      expect(firstUserResponseBody.tabcash).toBe(0);

      const { responseBody: secondUserResponseBody } = await usersRequestBuilder.get(`/${secondUser.username}`);

      expect(secondUserResponseBody.tabcoins).toBe(0);
      expect(secondUserResponseBody.tabcash).toBe(1);
    });

    test('With "transaction_type" set to "debit"', async () => {
      const firstUser = await orchestrator.createUser();
      const firstUserContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root',
        body: relevantBody,
        status: 'published',
      });

      const tabcoinsRequestBuilder = new RequestBuilder(
        `/api/v1/contents/${firstUser.username}/${firstUserContent.slug}/tabcoins`,
      );
      const secondUser = await tabcoinsRequestBuilder.buildUser();

      await orchestrator.createBalance({
        balanceType: 'user:tabcoin',
        recipientId: secondUser.id,
        amount: 2,
      });

      const { response: postTabCoinsResponse, responseBody: postTabCoinsResponseBody } =
        await tabcoinsRequestBuilder.post({
          transaction_type: 'debit',
        });

      expect.soft(postTabCoinsResponse.status).toBe(201);

      expect(postTabCoinsResponseBody).toStrictEqual({
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: -1,
      });

      const usersRequestBuilder = new RequestBuilder('/api/v1/users');
      const { responseBody: firstUserResponseBody } = await usersRequestBuilder.get(`/${firstUser.username}`);

      expect(firstUserResponseBody.tabcoins).toBe(-1);
      expect(firstUserResponseBody.tabcash).toBe(0);

      const { responseBody: secondUserResponseBody } = await usersRequestBuilder.get(`/${secondUser.username}`);

      expect(secondUserResponseBody.tabcoins).toBe(0);
      expect(secondUserResponseBody.tabcash).toBe(1);
    });

    test('With "transaction_type" set to "credit" four times (should be blocked)', async () => {
      const firstUser = await orchestrator.createUser();
      const firstUserContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root',
        body: 'Body',
        status: 'published',
      });

      const tabcoinsRequestBuilder = new RequestBuilder(
        `/api/v1/contents/${firstUser.username}/${firstUserContent.slug}/tabcoins`,
      );
      const secondUser = await tabcoinsRequestBuilder.buildUser();

      await orchestrator.createBalance({
        balanceType: 'user:tabcoin',
        recipientId: secondUser.id,
        amount: 8,
      });

      // ROUND 1 OF CREDIT
      const { response: postTabCoinsResponse1 } = await tabcoinsRequestBuilder.post({
        transaction_type: 'credit',
      });

      expect.soft(postTabCoinsResponse1.status).toBe(201);

      // ROUND 2 OF CREDIT
      const { response: postTabCoinsResponse2 } = await tabcoinsRequestBuilder.post({
        transaction_type: 'credit',
      });

      expect.soft(postTabCoinsResponse2.status).toBe(201);

      // ROUND 3 OF CREDIT
      const { response: postTabCoinsResponse3 } = await tabcoinsRequestBuilder.post({
        transaction_type: 'credit',
      });

      expect.soft(postTabCoinsResponse3.status).toBe(201);

      // ROUND 4 OF CREDIT
      const { response: postTabCoinsResponse4, responseBody: postTabCoinsResponse4Body } =
        await tabcoinsRequestBuilder.post({
          transaction_type: 'credit',
        });

      expect.soft(postTabCoinsResponse4.status).toBe(400);
      expect(postTabCoinsResponse4Body).toStrictEqual({
        name: 'ValidationError',
        message: 'Você está tentando qualificar muitas vezes o mesmo conteúdo.',
        action: 'Esta operação não poderá ser repetida dentro de 72 horas.',
        status_code: 400,
        error_id: postTabCoinsResponse4Body.error_id,
        request_id: postTabCoinsResponse4Body.request_id,
      });

      const usersRequestBuilder = new RequestBuilder('/api/v1/users');
      const { responseBody: firstUserResponseBody } = await usersRequestBuilder.get(`/${firstUser.username}`);

      expect(firstUserResponseBody.tabcoins).toBe(3);
      expect(firstUserResponseBody.tabcash).toBe(0);

      const { responseBody: secondUserResponseBody } = await usersRequestBuilder.get(`/${secondUser.username}`);

      expect(secondUserResponseBody.tabcoins).toBe(2);
      expect(secondUserResponseBody.tabcash).toBe(3);
    });

    test('With "transaction_type" set to "debit" four times (should be blocked)', async () => {
      const firstUser = await orchestrator.createUser();
      const firstUserContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root',
        body: 'Body',
        status: 'published',
      });

      const tabcoinsRequestBuilder = new RequestBuilder(
        `/api/v1/contents/${firstUser.username}/${firstUserContent.slug}/tabcoins`,
      );
      const secondUser = await tabcoinsRequestBuilder.buildUser();

      await orchestrator.createBalance({
        balanceType: 'user:tabcoin',
        recipientId: secondUser.id,
        amount: 8,
      });

      // ROUND 1 OF DEBIT
      const { response: postTabCoinsResponse1 } = await tabcoinsRequestBuilder.post({
        transaction_type: 'debit',
      });

      expect.soft(postTabCoinsResponse1.status).toBe(201);

      // ROUND 2 OF DEBIT
      const { response: postTabCoinsResponse2 } = await tabcoinsRequestBuilder.post({
        transaction_type: 'debit',
      });

      expect.soft(postTabCoinsResponse2.status).toBe(201);

      // ROUND 3 OF DEBIT
      const { response: postTabCoinsResponse3 } = await tabcoinsRequestBuilder.post({
        transaction_type: 'debit',
      });

      expect.soft(postTabCoinsResponse3.status).toBe(201);

      // ROUND 4 OF DEBIT
      const { response: postTabCoinsResponse4, responseBody: postTabCoinsResponse4Body } =
        await tabcoinsRequestBuilder.post({
          transaction_type: 'debit',
        });

      expect.soft(postTabCoinsResponse4.status).toBe(400);
      expect(postTabCoinsResponse4Body).toStrictEqual({
        name: 'ValidationError',
        message: 'Você está tentando qualificar muitas vezes o mesmo conteúdo.',
        action: 'Esta operação não poderá ser repetida dentro de 72 horas.',
        status_code: 400,
        error_id: postTabCoinsResponse4Body.error_id,
        request_id: postTabCoinsResponse4Body.request_id,
      });

      const usersRequestBuilder = new RequestBuilder('/api/v1/users');
      const { responseBody: firstUserResponseBody } = await usersRequestBuilder.get(`/${firstUser.username}`);

      expect(firstUserResponseBody.tabcoins).toBe(-3);
      expect(firstUserResponseBody.tabcash).toBe(0);

      const { responseBody: secondUserResponseBody } = await usersRequestBuilder.get(`/${secondUser.username}`);

      expect(secondUserResponseBody.tabcoins).toBe(2);
      expect(secondUserResponseBody.tabcash).toBe(3);
    });

    test('With "transaction_type" set to "debit" twice to make content "tabcoins" negative', async () => {
      const firstUser = await orchestrator.createUser();
      const firstUserContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root',
        body: relevantBody,
        status: 'published',
      });

      const tabcoinsRequestBuilder = new RequestBuilder(
        `/api/v1/contents/${firstUser.username}/${firstUserContent.slug}/tabcoins`,
      );
      const secondUser = await tabcoinsRequestBuilder.buildUser();

      await orchestrator.createBalance({
        balanceType: 'user:tabcoin',
        recipientId: secondUser.id,
        amount: 4,
      });

      // ROUND 1 OF DEBIT
      const { response: postTabCoinsResponse1, responseBody: postTabCoinsResponse1Body } =
        await tabcoinsRequestBuilder.post({
          transaction_type: 'debit',
        });

      expect.soft(postTabCoinsResponse1.status).toBe(201);

      expect(postTabCoinsResponse1Body).toStrictEqual({
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: -1,
      });

      const usersRequestBuilder = new RequestBuilder('/api/v1/users');
      const { responseBody: firstUserResponse1Body } = await usersRequestBuilder.get(`/${firstUser.username}`);

      expect(firstUserResponse1Body.tabcoins).toBe(-1);
      expect(firstUserResponse1Body.tabcash).toBe(0);

      const { responseBody: secondUserResponse1Body } = await usersRequestBuilder.get(`/${secondUser.username}`);

      expect(secondUserResponse1Body.tabcoins).toBe(2);
      expect(secondUserResponse1Body.tabcash).toBe(1);

      // ROUND 2 OF DEBIT
      const { response: postTabCoinsResponse2, responseBody: postTabCoinsResponse2Body } =
        await tabcoinsRequestBuilder.post({
          transaction_type: 'debit',
        });

      expect.soft(postTabCoinsResponse2.status).toBe(201);

      expect(postTabCoinsResponse2Body).toStrictEqual({
        tabcoins: -1,
        tabcoins_credit: 0,
        tabcoins_debit: -2,
      });

      const { responseBody: firstUserResponse2Body } = await usersRequestBuilder.get(`/${firstUser.username}`);

      expect(firstUserResponse2Body.tabcoins).toBe(-2);
      expect(firstUserResponse2Body.tabcash).toBe(0);

      const { responseBody: secondUserResponse2Body } = await usersRequestBuilder.get(`/${secondUser.username}`);

      expect(secondUserResponse2Body.tabcoins).toBe(0);
      expect(secondUserResponse2Body.tabcash).toBe(2);
    });

    test('With 20 simultaneous posts, but enough TabCoins for 1', async () => {
      const timesToFetch = 20;
      const firstUser = await orchestrator.createUser();
      const firstUserContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root',
        body: 'Body',
        status: 'published',
      });

      const tabcoinsRequestBuilder = new RequestBuilder(
        `/api/v1/contents/${firstUser.username}/${firstUserContent.slug}/tabcoins`,
      );
      const secondUser = await tabcoinsRequestBuilder.buildUser();

      await orchestrator.createBalance({
        balanceType: 'user:tabcoin',
        recipientId: secondUser.id,
        amount: 2,
      });

      const postTabCoinsPromises = Array(timesToFetch)
        .fill()
        .map(() => tabcoinsRequestBuilder.post({ transaction_type: 'credit' }));

      const postTabCoinsResponses = await Promise.all(postTabCoinsPromises);

      const postTabCoinsResponsesBody = postTabCoinsResponses.map(({ responseBody }) => responseBody);

      const postTabCoinsResponsesStatus = postTabCoinsResponses.map(({ response }) => response.status);

      const successPostIndex1 = postTabCoinsResponsesStatus.indexOf(201);
      const successPostIndex2 = postTabCoinsResponsesStatus.indexOf(201, successPostIndex1 + 1);

      expect(successPostIndex1).not.toBe(-1);
      expect(successPostIndex2).toBe(-1);
      expect(postTabCoinsResponsesStatus[successPostIndex1]).toBe(201);

      expect(postTabCoinsResponsesBody[successPostIndex1]).toStrictEqual({
        tabcoins: 1,
        tabcoins_credit: 1,
        tabcoins_debit: 0,
      });

      postTabCoinsResponsesStatus.splice(successPostIndex1, 1);
      postTabCoinsResponsesBody.splice(successPostIndex1, 1);

      postTabCoinsResponsesStatus.forEach((status) => expect.soft(status).toBe(422));

      expect(postTabCoinsResponsesBody).toContainEqual({
        name: 'UnprocessableEntityError',
        message: 'Não foi possível adicionar TabCoins nesta publicação.',
        action: 'Você precisa de pelo menos 2 TabCoins para realizar esta ação.',
        status_code: 422,
        error_id: postTabCoinsResponsesBody[timesToFetch - 2].error_id,
        request_id: postTabCoinsResponsesBody[timesToFetch - 2].request_id,
        error_location_code: 'MODEL:BALANCE:RATE_CONTENT:NOT_ENOUGH',
      });

      const usersRequestBuilder = new RequestBuilder('/api/v1/users');
      const { responseBody: firstUserResponseBody } = await usersRequestBuilder.get(`/${firstUser.username}`);

      expect(firstUserResponseBody.tabcoins).toBe(1);
      expect(firstUserResponseBody.tabcash).toBe(0);

      const { responseBody: secondUserResponseBody } = await usersRequestBuilder.get(`/${secondUser.username}`);

      expect(secondUserResponseBody.tabcoins).toBe(0);
      expect(secondUserResponseBody.tabcash).toBe(1);
    });

    // This tests are being temporarily skipped because of the new feature of not allowing
    // to credit/debit four times the same content. This feature is just a temporary test
    // to a more sophisticated feature that will be implemented in the future.

    // eslint-disable-next-line vitest/no-disabled-tests
    test.skip('With 100 simultaneous posts, but enough TabCoins for 6', async () => {
      const timesToFetch = 100;
      const timesSuccessfully = 6;

      const firstUser = await orchestrator.createUser();
      const firstUserContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root',
        body: 'Body',
        status: 'published',
      });

      const tabcoinsRequestBuilder = new RequestBuilder(
        `/api/v1/contents/${firstUser.username}/${firstUserContent.slug}/tabcoins`,
      );
      const secondUser = await tabcoinsRequestBuilder.buildUser();

      await orchestrator.createBalance({
        balanceType: 'user:tabcoin',
        recipientId: secondUser.id,
        amount: 2 * timesSuccessfully,
      });

      const postTabCoinsPromises = Array(timesToFetch)
        .fill()
        .map(() => tabcoinsRequestBuilder.post({ transaction_type: 'credit' }));

      const postTabCoinsResponses = await Promise.all(postTabCoinsPromises);

      const postTabCoinsResponsesBody = postTabCoinsResponses.map(({ responseBody }) => responseBody);

      const postTabCoinsResponsesStatus = postTabCoinsResponses.map(({ response }) => response.status);

      const successPostIndexes = [postTabCoinsResponsesStatus.indexOf(201)];

      for (let i = 0; i < timesSuccessfully; i++) {
        successPostIndexes.push(postTabCoinsResponsesStatus.indexOf(201, successPostIndexes[i] + 1));
        expect(successPostIndexes[i]).not.toBe(-1);
        expect(postTabCoinsResponsesStatus[successPostIndexes[i]]).toBe(201);
        expect(postTabCoinsResponsesBody).toContainEqual({
          tabcoins: 2 + i,
        });
      }

      expect(successPostIndexes[timesSuccessfully]).toBe(-1);

      successPostIndexes.splice(-1, 1);
      successPostIndexes.reverse();

      successPostIndexes.forEach((idx) => {
        postTabCoinsResponsesStatus.splice(idx, 1);
        postTabCoinsResponsesBody.splice(idx, 1);
      });

      postTabCoinsResponsesStatus.forEach((status) => expect.soft(status).toBe(422));

      postTabCoinsResponsesBody.forEach((responseBody) =>
        expect(responseBody).toStrictEqual({
          name: 'UnprocessableEntityError',
          message: 'Não foi possível adicionar TabCoins nesta publicação.',
          action: 'Você precisa de pelo menos 2 TabCoins para realizar esta ação.',
          status_code: 422,
          error_id: responseBody.error_id,
          request_id: responseBody.request_id,
          error_location_code: 'MODEL:BALANCE:RATE_CONTENT:NOT_ENOUGH',
        }),
      );

      const usersRequestBuilder = new RequestBuilder('/api/v1/users');
      const { responseBody: firstUserResponseBody } = await usersRequestBuilder.get(`/${firstUser.username}`);

      expect(firstUserResponseBody.tabcoins).toBe(2 + timesSuccessfully);
      expect(firstUserResponseBody.tabcash).toBe(0);

      const { responseBody: secondUserResponseBody } = await usersRequestBuilder.get(`/${secondUser.username}`);

      expect(secondUserResponseBody.tabcoins).toBe(0);
      expect(secondUserResponseBody.tabcash).toBe(timesSuccessfully);
    });

    // eslint-disable-next-line vitest/no-disabled-tests
    test.skip('With 100 simultaneous posts, enough TabCoins for 90, no db resources, but only responses 201 or 422', async () => {
      const timesToFetch = 100;
      const timesSuccessfully = 90;

      const firstUser = await orchestrator.createUser();
      const firstUserContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root',
        body: 'Body',
        status: 'published',
      });

      const tabcoinsRequestBuilder = new RequestBuilder(
        `/api/v1/contents/${firstUser.username}/${firstUserContent.slug}/tabcoins`,
      );
      const secondUser = await tabcoinsRequestBuilder.buildUser();

      await orchestrator.createBalance({
        balanceType: 'user:tabcoin',
        recipientId: secondUser.id,
        amount: 2 * timesSuccessfully,
      });

      const postTabCoinsPromises = Array(timesToFetch)
        .fill()
        .map(() => tabcoinsRequestBuilder.post({ transaction_type: 'credit' }));

      const postTabCoinsResponses = await Promise.all(postTabCoinsPromises);

      const postTabCoinsResponsesBody = postTabCoinsResponses.map(({ responseBody }) => responseBody);

      const postTabCoinsResponsesStatus = postTabCoinsResponses.map(({ response }) => response.status);

      expect([201, 422]).toStrictEqual(expect.arrayContaining(postTabCoinsResponsesStatus));

      expect(postTabCoinsResponsesBody).toContainEqual(
        expect.objectContaining({
          name: 'UnprocessableEntityError',
          message: 'Muitos votos ao mesmo tempo.',
          action: 'Tente realizar esta operação mais tarde.',
          status_code: 422,
          error_location_code: 'CONTROLLER:CONTENT:TABCOINS:SERIALIZATION_FAILURE',
        }),
      );
    });
  });
});
</file>

<file path="tests/integration/api/v1/contents/[username]/[slug]/thumbnail/get.test.js">
import { readFileSync } from 'node:fs';
import { join, resolve } from 'node:path';
import { version as uuidVersion } from 'uuid';

import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('GET /api/v1/contents/[username]/[slug]/thumbnail', () => {
  describe('Anonymous user', () => {
    test('"root" content with "draft" status', async () => {
      const defaultUser = await orchestrator.createUser();
      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Root content',
        status: 'draft',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${rootContent.slug}/thumbnail`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'Este conteúdo não está disponível.',
        action:
          'Verifique se o "slug" está digitado corretamente ou considere o fato do conteúdo ter sido despublicado.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'CONTROLLER:CONTENT:THUMBNAIL:GET_HANDLER:SLUG_NOT_FOUND',
        key: 'slug',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('"root" content with "deleted" status', async () => {
      const defaultUser = await orchestrator.createUser();
      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Root content',
        status: 'published',
      });

      await orchestrator.updateContent(rootContent.id, { status: 'deleted' });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${rootContent.slug}/thumbnail`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'Este conteúdo não está disponível.',
        action:
          'Verifique se o "slug" está digitado corretamente ou considere o fato do conteúdo ter sido despublicado.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'CONTROLLER:CONTENT:THUMBNAIL:GET_HANDLER:SLUG_NOT_FOUND',
        key: 'slug',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('"root" content with short "title", short "username" and 0 "children"', async () => {
      const defaultUser = await orchestrator.createUser({
        username: 'abc',
      });

      vi.useFakeTimers({
        now: Date.parse('2022-01-01T12:00:00.000Z'),
      });

      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Short title',
        status: 'published',
      });

      vi.useRealTimers();

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${rootContent.slug}/thumbnail`,
      );

      const responseBody = Buffer.from(await response.arrayBuffer());

      const benchmarkFile = readFileSync(
        join(
          resolve('.'),
          'tests',
          'integration',
          'api',
          'v1',
          'contents',
          '[username]',
          '[slug]',
          'thumbnail',
          'root-short-title-short-username-0-children.png',
        ),
      );

      expect.soft(response.status).toBe(200);
      expect(Buffer.compare(benchmarkFile, responseBody)).toBe(0); // has the same bytes
    });

    test('"root" content with long "title", long "username" and 0 "children"', async () => {
      const defaultUser = await orchestrator.createUser({
        username: 'ThisUsernameHas30Characterssss',
      });

      vi.useFakeTimers({
        now: Date.parse('2022-06-06T12:00:00.000Z'),
      });

      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title:
          'This is a very long title and it should have 125 characters in total. Its not the maximum accepted value, but it is very long',
        status: 'published',
      });

      vi.useRealTimers();

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${rootContent.slug}/thumbnail`,
      );

      const responseBody = Buffer.from(await response.arrayBuffer());

      const benchmarkFile = readFileSync(
        join(
          resolve('.'),
          'tests',
          'integration',
          'api',
          'v1',
          'contents',
          '[username]',
          '[slug]',
          'thumbnail',
          'root-long-title-long-username-0-children.png',
        ),
      );

      expect.soft(response.status).toBe(200);
      expect(Buffer.compare(benchmarkFile, responseBody)).toBe(0); // has the same bytes
    });

    test('"root" content with long "title", long "username" and 2 "children"', async () => {
      const defaultUser = await orchestrator.createUser({
        username: 'ThisUsernameHas30Charactersss2',
      });

      vi.useFakeTimers({
        now: Date.parse('2022-07-01T12:00:00.000Z'),
      });

      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title:
          'This is a very long title and it should have 125 characters in total. Its not the maximum accepted value, but it is very long',
        status: 'published',
      });

      vi.useRealTimers();

      const childContent1 = await orchestrator.createContent({
        parent_id: rootContent.id,
        owner_id: defaultUser.id,
        body: 'Body',
        status: 'published',
      });

      await orchestrator.createContent({
        parent_id: childContent1.id,
        owner_id: defaultUser.id,
        body: 'Body',
        status: 'published',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${rootContent.slug}/thumbnail`,
      );

      const responseBody = Buffer.from(await response.arrayBuffer());

      const benchmarkFile = readFileSync(
        join(
          resolve('.'),
          'tests',
          'integration',
          'api',
          'v1',
          'contents',
          '[username]',
          '[slug]',
          'thumbnail',
          'root-long-title-long-username-2-children.png',
        ),
      );

      expect.soft(response.status).toBe(200);
      expect(Buffer.compare(benchmarkFile, responseBody)).toBe(0); // has the same bytes
    });

    test('"child" content with short "parent_title", short "body" and 0 "children"', async () => {
      const defaultUser = await orchestrator.createUser({
        username: 'ChildTest1',
      });

      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Short title',
        status: 'published',
      });

      vi.useFakeTimers({
        now: Date.parse('2022-02-02T12:00:00.000Z'),
      });

      const childContent = await orchestrator.createContent({
        parent_id: rootContent.id,
        owner_id: defaultUser.id,
        body: 'Short body',
        status: 'published',
      });

      vi.useRealTimers();

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${childContent.slug}/thumbnail`,
      );

      const responseBody = Buffer.from(await response.arrayBuffer());

      const benchmarkFile = readFileSync(
        join(
          resolve('.'),
          'tests',
          'integration',
          'api',
          'v1',
          'contents',
          '[username]',
          '[slug]',
          'thumbnail',
          'child-short-parent-title-short-body-0-children.png',
        ),
      );

      expect.soft(response.status).toBe(200);
      expect(Buffer.compare(benchmarkFile, responseBody)).toBe(0); // has the same bytes
    });

    test('"child" content with long "parent_title", long "body" and 0 "children"', async () => {
      const defaultUser = await orchestrator.createUser({
        username: 'ChildTest2',
      });

      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title:
          'This is a very long title and it should have 125 characters in total. Its not the maximum accepted value, but it is very long',
        status: 'published',
      });

      vi.useFakeTimers({
        now: Date.parse('2022-10-10T12:00:00.000Z'),
      });

      const childContent = await orchestrator.createContent({
        parent_id: rootContent.id,
        owner_id: defaultUser.id,
        body: 'This is a very long body and it should have 125 characters in total. Its not the maximum accepted value, but it is very long.',
        status: 'published',
      });

      vi.useRealTimers();

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${childContent.slug}/thumbnail`,
      );

      const responseBody = Buffer.from(await response.arrayBuffer());

      const benchmarkFile = readFileSync(
        join(
          resolve('.'),
          'tests',
          'integration',
          'api',
          'v1',
          'contents',
          '[username]',
          '[slug]',
          'thumbnail',
          'child-long-parent-title-long-body-0-children.png',
        ),
      );

      expect.soft(response.status).toBe(200);
      expect(Buffer.compare(benchmarkFile, responseBody)).toBe(0); // has the same bytes
    });

    test('"child" of a "child" content with "parent_title"', async () => {
      const defaultUser = await orchestrator.createUser({
        username: 'ChildTest3',
      });

      const contentLevel1 = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Content Level 1 Title',
        status: 'published',
      });

      vi.useFakeTimers({
        now: Date.parse('2022-02-02T12:00:00.000Z'),
      });

      const contentLevel2 = await orchestrator.createContent({
        parent_id: contentLevel1.id,
        owner_id: defaultUser.id,
        title: 'Content Level 2 Title',
        status: 'published',
      });

      const contentLevel3 = await orchestrator.createContent({
        parent_id: contentLevel2.id,
        owner_id: defaultUser.id,
        body: 'Content Level 3 Body',
        status: 'published',
      });

      vi.useRealTimers();

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${contentLevel3.slug}/thumbnail`,
      );

      const responseBody = Buffer.from(await response.arrayBuffer());

      const benchmarkFile = readFileSync(
        join(
          resolve('.'),
          'tests',
          'integration',
          'api',
          'v1',
          'contents',
          '[username]',
          '[slug]',
          'thumbnail',
          'child-child-content-with-parent-title.png',
        ),
      );

      expect.soft(response.status).toBe(200);
      expect(Buffer.compare(benchmarkFile, responseBody)).toBe(0); // has the same bytes
    });

    test('"child" of a "child" content without "parent_title"', async () => {
      const defaultUser = await orchestrator.createUser({
        username: 'ChildTest4',
      });

      const contentLevel1 = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Content Level 1 Title',
        status: 'published',
      });

      vi.useFakeTimers({
        now: Date.parse('2022-02-02T12:00:00.000Z'),
      });

      const contentLevel2 = await orchestrator.createContent({
        parent_id: contentLevel1.id,
        owner_id: defaultUser.id,
        body: 'No "title", just "body"',
        status: 'published',
      });

      const contentLevel3 = await orchestrator.createContent({
        parent_id: contentLevel2.id,
        owner_id: defaultUser.id,
        body: 'Content Level 3 Body',
        status: 'published',
      });

      vi.useRealTimers();

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${contentLevel3.slug}/thumbnail`,
      );

      const responseBody = Buffer.from(await response.arrayBuffer());

      const benchmarkFile = readFileSync(
        join(
          resolve('.'),
          'tests',
          'integration',
          'api',
          'v1',
          'contents',
          '[username]',
          '[slug]',
          'thumbnail',
          'child-child-content-without-parent-title.png',
        ),
      );

      expect.soft(response.status).toBe(200);
      expect(Buffer.compare(benchmarkFile, responseBody)).toBe(0); // has the same bytes
    });
  });
});
</file>

<file path="tests/integration/api/v1/contents/[username]/[slug]/get.test.js">
import { version as uuidVersion } from 'uuid';

import { relevantBody } from 'tests/constants-for-tests';
import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('GET /api/v1/contents/[username]/[slug]', () => {
  describe('Anonymous user', () => {
    test('Content with "username" non-existent', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/contents/ThisUserDoesNotExists/slug`);
      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);
      expect.soft(responseBody.status_code).toBe(404);
      expect(responseBody.name).toBe('NotFoundError');
      expect(responseBody.message).toBe('O "username" informado não foi encontrado no sistema.');
      expect(responseBody.action).toBe('Verifique se o "username" está digitado corretamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:USER:FIND_ONE_BY_USERNAME:NOT_FOUND');
    });

    test('Content with "username" existent, but "slug" non-existent', async () => {
      const defaultUser = await orchestrator.createUser();
      await orchestrator.activateUser(defaultUser);

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/esse-slug-nao-existe`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);
      expect.soft(responseBody.status_code).toBe(404);
      expect(responseBody.name).toBe('NotFoundError');
      expect(responseBody.message).toBe('O conteúdo informado não foi encontrado no sistema.');
      expect(responseBody.action).toBe('Verifique se o "slug" está digitado corretamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('CONTROLLER:CONTENT:GET_HANDLER:SLUG_NOT_FOUND');
    });

    test('Content "root" with "status" set to "draft"', async () => {
      const defaultUser = await orchestrator.createUser();
      await orchestrator.activateUser(defaultUser);

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Conteúdo existente, mas não publicamente disponível',
        body: 'Deveria estar disponível para ninguém.',
        status: 'draft',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${defaultUserContent.slug}`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);
      expect.soft(responseBody.status_code).toBe(404);
      expect(responseBody.name).toBe('NotFoundError');
      expect(responseBody.message).toBe('O conteúdo informado não foi encontrado no sistema.');
      expect(responseBody.action).toBe('Verifique se o "slug" está digitado corretamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('CONTROLLER:CONTENT:GET_HANDLER:SLUG_NOT_FOUND');
    });

    test('Content "root" with "status" set to "published"', async () => {
      const defaultUser = await orchestrator.createUser();
      await orchestrator.activateUser(defaultUser);

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Conteúdo publicamente disponível',
        body: 'Conteúdo relevante deveria estar disponível para todos.',
        status: 'published',
        source_url: 'https://www.tabnews.com.br/',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${defaultUserContent.slug}`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: defaultUserContent.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'conteudo-publicamente-disponivel',
        title: 'Conteúdo publicamente disponível',
        body: 'Conteúdo relevante deveria estar disponível para todos.',
        status: 'published',
        type: 'content',
        tabcoins: 1,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        source_url: 'https://www.tabnews.com.br/',
        created_at: defaultUserContent.created_at.toISOString(),
        updated_at: defaultUserContent.updated_at.toISOString(),
        published_at: defaultUserContent.published_at.toISOString(),
        deleted_at: null,
        owner_username: defaultUser.username,
        children_deep_count: 0,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(uuidVersion(responseBody.owner_id)).toBe(4);
    });

    test('Content "root" with "status" set to "deleted"', async () => {
      const defaultUser = await orchestrator.createUser();
      await orchestrator.activateUser(defaultUser);

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Conteúdo existente, mas não publicamente disponível',
        body: 'Deveria estar disponível para ninguém.',
        status: 'published',
      });

      await orchestrator.updateContent(defaultUserContent.id, { status: 'deleted' });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${defaultUserContent.slug}`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'O conteúdo informado não foi encontrado no sistema.',
        action: 'Verifique se o "slug" está digitado corretamente.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'CONTROLLER:CONTENT:GET_HANDLER:SLUG_NOT_FOUND',
        key: 'slug',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('Content "root" with with "children"', async () => {
      const defaultUser = await orchestrator.createUser();
      await orchestrator.activateUser(defaultUser);

      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Conteúdo root',
        body: relevantBody,
        status: 'published',
      });

      const childContentLevel1 = await orchestrator.createContent({
        parent_id: rootContent.id,
        owner_id: defaultUser.id,
        body: 'Conteúdo child nível 1',
        status: 'published',
      });

      const childContentLevel2 = await orchestrator.createContent({
        parent_id: childContentLevel1.id,
        owner_id: defaultUser.id,
        body: 'Conteúdo child nível 2',
        status: 'published',
      });

      const childContentLevel3 = await orchestrator.createContent({
        parent_id: childContentLevel2.id,
        owner_id: defaultUser.id,
        body: 'Conteúdo child nível 3',
        status: 'published',
      });

      const childContentLeve4 = await orchestrator.createContent({
        parent_id: childContentLevel3.id,
        owner_id: defaultUser.id,
        body: 'Conteúdo child nível 4 (vai ser deletado e não deve ser contabilizado)',
        status: 'published',
      });

      await orchestrator.updateContent(childContentLeve4.id, { status: 'deleted' });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${rootContent.slug}`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: rootContent.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: responseBody.slug,
        title: 'Conteúdo root',
        body: relevantBody,
        status: 'published',
        type: 'content',
        tabcoins: 1,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        source_url: null,
        created_at: rootContent.created_at.toISOString(),
        updated_at: rootContent.updated_at.toISOString(),
        published_at: rootContent.published_at.toISOString(),
        deleted_at: null,
        owner_username: defaultUser.username,
        children_deep_count: 3,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(uuidVersion(responseBody.owner_id)).toBe(4);
    });

    test('Content "child" with "status" set to "draft"', async () => {
      const defaultUser = await orchestrator.createUser();
      await orchestrator.activateUser(defaultUser);

      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Conteúdo root',
        body: 'Conteúdo root',
        status: 'published',
      });

      const childContent = await orchestrator.createContent({
        parent_id: rootContent.id,
        owner_id: defaultUser.id,
        body: 'Conteúdo child',
        status: 'draft',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${childContent.slug}`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);
      expect.soft(responseBody.status_code).toBe(404);
      expect(responseBody.name).toBe('NotFoundError');
      expect(responseBody.message).toBe('O conteúdo informado não foi encontrado no sistema.');
      expect(responseBody.action).toBe('Verifique se o "slug" está digitado corretamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('CONTROLLER:CONTENT:GET_HANDLER:SLUG_NOT_FOUND');
    });

    test('Content "child" with "status" set to "published"', async () => {
      const defaultUser = await orchestrator.createUser();
      await orchestrator.activateUser(defaultUser);

      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Conteúdo root',
        body: 'Conteúdo root',
        status: 'published',
      });

      const childContent = await orchestrator.createContent({
        parent_id: rootContent.id,
        owner_id: defaultUser.id,
        body: 'Conteúdo child',
        status: 'published',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${childContent.slug}`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: childContent.id,
        owner_id: defaultUser.id,
        parent_id: rootContent.id,
        slug: responseBody.slug,
        title: null,
        body: 'Conteúdo child',
        status: 'published',
        type: 'content',
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        source_url: null,
        created_at: childContent.created_at.toISOString(),
        updated_at: childContent.updated_at.toISOString(),
        published_at: childContent.published_at.toISOString(),
        deleted_at: null,
        owner_username: defaultUser.username,
        children_deep_count: 0,
      });
    });

    test('Content "child" with "children"', async () => {
      const defaultUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();
      await orchestrator.activateUser(defaultUser);

      const rootContent = await orchestrator.createContent({
        owner_id: secondUser.id,
        title: 'Conteúdo root',
        body: 'Conteúdo root',
        status: 'published',
      });

      const childContent = await orchestrator.createContent({
        parent_id: rootContent.id,
        owner_id: defaultUser.id,
        body: 'Conteúdo child',
        status: 'published',
      });

      const childContentLevel1 = await orchestrator.createContent({
        parent_id: childContent.id,
        owner_id: secondUser.id,
        body: 'Conteúdo child nível 1',
        status: 'published',
      });

      const childContentLevel2 = await orchestrator.createContent({
        parent_id: childContentLevel1.id,
        owner_id: defaultUser.id,
        body: 'Conteúdo child nível 2',
        status: 'published',
      });

      const childContentLeve3 = await orchestrator.createContent({
        parent_id: childContentLevel2.id,
        owner_id: defaultUser.id,
        body: 'Conteúdo child nível 3 (vai ser deletado e não deve ser contabilizado)',
        status: 'published',
      });

      await orchestrator.updateContent(childContentLeve3.id, { status: 'deleted' });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${childContent.slug}`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: childContent.id,
        owner_id: defaultUser.id,
        parent_id: rootContent.id,
        slug: responseBody.slug,
        title: null,
        body: 'Conteúdo child',
        status: 'published',
        type: 'content',
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        source_url: null,
        created_at: childContent.created_at.toISOString(),
        updated_at: childContent.updated_at.toISOString(),
        published_at: childContent.published_at.toISOString(),
        deleted_at: null,
        owner_username: defaultUser.username,
        children_deep_count: 2,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(uuidVersion(responseBody.owner_id)).toBe(4);
      expect(uuidVersion(responseBody.parent_id)).toBe(4);
    });

    test('Content "child" with "status" set to "deleted"', async () => {
      const defaultUser = await orchestrator.createUser();
      await orchestrator.activateUser(defaultUser);

      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Conteúdo root',
        body: 'Conteúdo root',
        status: 'published',
      });

      const childContent = await orchestrator.createContent({
        parent_id: rootContent.id,
        owner_id: defaultUser.id,
        body: 'Conteúdo child',
        status: 'published',
      });

      await orchestrator.updateContent(childContent.id, { status: 'deleted' });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${childContent.slug}`,
      );
      const responseBody = await response.json();

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'O conteúdo informado não foi encontrado no sistema.',
        action: 'Verifique se o "slug" está digitado corretamente.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'CONTROLLER:CONTENT:GET_HANDLER:SLUG_NOT_FOUND',
        key: 'slug',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('Content "root" with TabCoins credits and debits', async () => {
      const defaultUser = await orchestrator.createUser();
      await orchestrator.activateUser(defaultUser);

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Conteúdo com TabCoins',
        body: 'Conteúdo que foi avaliado positiva e negativamente.',
        status: 'published',
      });

      await orchestrator.createRate(defaultUserContent, 3);
      await orchestrator.createRate(defaultUserContent, -1);

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}/${defaultUserContent.slug}`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: defaultUserContent.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'conteudo-com-tabcoins',
        title: 'Conteúdo com TabCoins',
        body: 'Conteúdo que foi avaliado positiva e negativamente.',
        status: 'published',
        type: 'content',
        tabcoins: 2,
        tabcoins_credit: 3,
        tabcoins_debit: -1,
        source_url: null,
        created_at: defaultUserContent.created_at.toISOString(),
        updated_at: defaultUserContent.updated_at.toISOString(),
        published_at: defaultUserContent.published_at.toISOString(),
        deleted_at: null,
        owner_username: defaultUser.username,
        children_deep_count: 0,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(uuidVersion(responseBody.owner_id)).toBe(4);
    });
  });
});
</file>

<file path="tests/integration/api/v1/contents/[username]/[slug]/patch.test.js">
import { version as uuidVersion } from 'uuid';

import { maxSlugLength, maxTitleLength, relevantBody } from 'tests/constants-for-tests';
import orchestrator from 'tests/orchestrator.js';
import RequestBuilder from 'tests/request-builder';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('PATCH /api/v1/contents/[username]/[slug]', () => {
  describe('Anonymous user', () => {
    test('Content with minimum valid data', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');

      const { response, responseBody } = await contentsRequestBuilder.patch('/someUsername/slug', {
        title: 'Anônimo tentando atualizar um conteúdo existente',
        body: 'Não deveria conseguir.',
      });

      expect.soft(response.status).toBe(403);
      expect.soft(responseBody.status_code).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Usuário não pode executar esta operação.');
      expect(responseBody.action).toBe('Verifique se este usuário possui a feature "update:content".');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND');
    });
  });

  describe('User without "update:content" feature', () => {
    test('"root" content with valid data', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const userWithoutFeature = await contentsRequestBuilder.buildUser({ without: ['update:content'] });

      const { response, responseBody } = await contentsRequestBuilder.patch(`/${userWithoutFeature.username}/slug`, {
        title: 'Usuário válido, tentando atualizar conteúdo na raiz do site.',
        body: 'Não deveria conseguir, pois não possui a feature "update:content".',
      });

      expect.soft(response.status).toBe(403);
      expect.soft(responseBody.status_code).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Usuário não pode executar esta operação.');
      expect(responseBody.action).toBe('Verifique se este usuário possui a feature "update:content".');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND');
    });

    test('"child" content with valid data', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const userWithoutFeature = await contentsRequestBuilder.buildUser({ without: ['update:content'] });

      const rootContent = await orchestrator.createContent({
        owner_id: userWithoutFeature.id,
        title: 'Root content title',
        body: 'Root content body',
      });

      const childContent = await orchestrator.createContent({
        owner_id: userWithoutFeature.id,
        title: 'Child content title',
        body: 'Child content body',
        parent_id: rootContent.id,
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${userWithoutFeature.username}/${childContent.slug}`,
        {
          title: 'Usuário válido, tentando atualizar conteúdo "child".',
          body: 'Não deveria conseguir, pois não possui a feature "update:content".',
        },
      );

      expect.soft(response.status).toBe(403);
      expect.soft(responseBody.status_code).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Usuário não pode executar esta operação.');
      expect(responseBody.action).toBe('Verifique se este usuário possui a feature "update:content".');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND');
    });
  });

  describe('User without "create:content:text_root" feature', () => {
    test('"root" content with valid data', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const userWithoutFeature = await contentsRequestBuilder.buildUser({ without: ['create:content:text_root'] });

      const rootContent = await orchestrator.createContent({
        owner_id: userWithoutFeature.id,
        title: 'Root content title',
        body: 'Root content body',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${userWithoutFeature.username}/${rootContent.slug}`,
        {
          title: 'Valid user trying to update "root" content.',
          body: "He shouldn't be able to do it because he lacks the 'create:content:text_root' feature.",
        },
      );

      expect.soft(response.status).toBe(403);
      expect.soft(responseBody.status_code).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Você não possui permissão para editar conteúdos na raiz do site.');
      expect(responseBody.action).toBe('Verifique se você possui a feature "create:content:text_root".');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe(
        'CONTROLLER:CONTENT:PATCH_HANDLER:CREATE:CONTENT:TEXT_ROOT:FEATURE_NOT_FOUND',
      );
    });

    test('"child" content with valid data', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const userWithoutFeature = await contentsRequestBuilder.buildUser({ without: ['create:content:text_root'] });

      const rootContent = await orchestrator.createContent({
        owner_id: userWithoutFeature.id,
        title: 'Root content title',
        body: 'Root content body',
      });

      const childContent = await orchestrator.createContent({
        owner_id: userWithoutFeature.id,
        body: 'Child content with original body',
        parent_id: rootContent.id,
        status: 'published',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${userWithoutFeature.username}/${childContent.slug}`,
        {
          body: 'Updated body, even without "create:content:text_root" feature.',
        },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: userWithoutFeature.id,
        parent_id: rootContent.id,
        slug: childContent.slug,
        title: null,
        body: 'Updated body, even without "create:content:text_root" feature.',
        status: 'published',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: responseBody.published_at,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: userWithoutFeature.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.published_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.updated_at > childContent.updated_at.toISOString()).toBe(true);
    });
  });

  describe('User without "create:content:text_child" feature', () => {
    test('"root" content with valid data', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const userWithoutFeature = await contentsRequestBuilder.buildUser({ without: ['create:content:text_child'] });

      const rootContent = await orchestrator.createContent({
        owner_id: userWithoutFeature.id,
        title: 'Valid user trying to update "root" content.',
        body: 'It should be possible, even without the "create:content:text_child" feature.',
        status: 'published',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${userWithoutFeature.username}/${rootContent.slug}`,
        { source_url: 'http://www.tabnews.com.br/' },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: userWithoutFeature.id,
        parent_id: null,
        slug: 'valid-user-trying-to-update-root-content',
        title: 'Valid user trying to update "root" content.',
        body: 'It should be possible, even without the "create:content:text_child" feature.',
        status: 'published',
        type: 'content',
        source_url: 'http://www.tabnews.com.br/',
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: responseBody.published_at,
        deleted_at: null,
        tabcoins: 1,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: userWithoutFeature.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.published_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.updated_at > rootContent.updated_at.toISOString()).toBe(true);
    });

    test('"child" content with valid data', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const userWithoutFeature = await contentsRequestBuilder.buildUser({ without: ['create:content:text_child'] });

      const rootContent = await orchestrator.createContent({
        owner_id: userWithoutFeature.id,
        title: 'Root content title',
        body: 'Root content body',
      });

      const childContent = await orchestrator.createContent({
        owner_id: userWithoutFeature.id,
        body: 'Child content body',
        parent_id: rootContent.id,
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${userWithoutFeature.username}/${childContent.slug}`,
        {
          title: 'Valid user, trying to update "child" content.',
          body: "He shouldn't be able to do it because he lacks the 'create:content:text_child' feature.",
        },
      );

      expect.soft(response.status).toBe(403);
      expect.soft(responseBody.status_code).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Você não possui permissão para editar conteúdos dentro de outros conteúdos.');
      expect(responseBody.action).toBe('Verifique se você possui a feature "create:content:text_child".');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe(
        'CONTROLLER:CONTENT:PATCH_HANDLER:CREATE:CONTENT:TEXT_CHILD:FEATURE_NOT_FOUND',
      );
    });
  });

  describe('Default user', () => {
    test('Content without PATCH Body and "Content-Type"', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      contentsRequestBuilder.buildHeaders({ 'Content-Type': undefined });
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.patch(`/${defaultUser.username}/slug`);

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"body" enviado deve ser do tipo Object.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with PATCH Body containing an invalid JSON string', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      contentsRequestBuilder.buildHeaders({ 'Content-Type': undefined });
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/slug`,
        'Texto corrido no lugar de um JSON',
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"body" enviado deve ser do tipo Object.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with PATCH Body containing an empty Object', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.patch(`/${defaultUser.username}/slug`, {});

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('Objeto enviado deve ter no mínimo uma chave.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with invalid "username" in the URL', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.patch(`/invalid-username/slug`, {});

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"username" deve conter apenas caracteres alfanuméricos.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with invalid "slug" in the URL', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/%3Cscript%3Ealert%28%29%3Cscript%3E`,
        {},
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"slug" está no formato errado.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "username" non-existent', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.patch(`/ThisUserDoesNotExists/slug`, {
        title: 'Primeiro usuário tentando atualizar o conteúdo do Segundo usuário',
        body: 'Não deveria conseguir',
      });

      expect.soft(response.status).toBe(404);
      expect.soft(responseBody.status_code).toBe(404);
      expect(responseBody.name).toBe('NotFoundError');
      expect(responseBody.message).toBe('O "username" informado não foi encontrado no sistema.');
      expect(responseBody.action).toBe('Verifique se o "username" está digitado corretamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:USER:FIND_ONE_BY_USERNAME:NOT_FOUND');
    });

    test('Content with "username" existent, but "slug" non-existent', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const firstUser = await contentsRequestBuilder.buildUser();

      await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Conteúdo do primeiro usuário',
        status: 'published',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${firstUser.username}/esse-slug-nao-existe`,
        {
          title: 'Tentando atualizar um conteúdo próprio, mas errando o slug',
          body: 'Não deveria conseguir',
        },
      );

      expect.soft(response.status).toBe(404);
      expect.soft(responseBody.status_code).toBe(404);
      expect(responseBody.name).toBe('NotFoundError');
      expect(responseBody.message).toBe('O conteúdo informado não foi encontrado no sistema.');
      expect(responseBody.action).toBe('Verifique se o "slug" está digitado corretamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('CONTROLLER:CONTENT:PATCH_HANDLER:SLUG_NOT_FOUND');
    });

    test('Content with "username" and "slug" pointing to content from another user', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();
      const secondUser = await orchestrator.createUser();

      const secondUserContent = await orchestrator.createContent({
        owner_id: secondUser.id,
        title: 'Conteúdo do segundo usuário',
        status: 'published',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${secondUser.username}/${secondUserContent.slug}`,
        {
          title: 'Primeiro usuário tentando atualizar o conteúdo do Segundo usuário',
          body: 'Não deveria conseguir',
        },
      );

      expect.soft(response.status).toBe(403);
      expect.soft(responseBody.status_code).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Você não possui permissão para atualizar o conteúdo de outro usuário.');
      expect(responseBody.action).toBe('Verifique se você possui a feature "update:content:others".');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe(
        'CONTROLLER:CONTENTS:PATCH:USER_CANT_UPDATE_CONTENT_FROM_OTHER_USER',
      );
    });

    test('Content with "owner_id" pointing to another user', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const firstUser = await contentsRequestBuilder.buildUser();
      const secondUser = await orchestrator.createUser();

      const firstUserContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Conteúdo do Primeiro Usuário antes do patch!',
        body: 'Body antes do patch!',
        status: 'published',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${firstUser.username}/${firstUserContent.slug}`,
        {
          title: 'Tentando atualizar o dono do conteúdo.',
          body: 'Campo "owner_id" da request deveria ser ignorado e pego através da sessão.',
          owner_id: secondUser.id,
        },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: firstUserContent.id,
        owner_id: firstUser.id,
        parent_id: null,
        slug: 'conteudo-do-primeiro-usuario-antes-do-patch',
        title: 'Tentando atualizar o dono do conteúdo.',
        body: 'Campo "owner_id" da request deveria ser ignorado e pego através da sessão.',
        status: 'published',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: responseBody.published_at,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: firstUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.published_at).toBe(firstUserContent.published_at.toISOString());
      expect(responseBody.updated_at > firstUserContent.updated_at.toISOString()).toBe(true);
    });

    test('Content with "body" declared solely', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { body: 'Body novo' },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'titulo-velho',
        title: 'Título velho',
        body: 'Body novo',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.updated_at > defaultUserContent.updated_at.toISOString()).toBe(true);
    });

    test('Content with TabCoins credits and debits', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Title',
        body: 'Body',
      });

      await orchestrator.createRate(defaultUserContent, 3);
      await orchestrator.createRate(defaultUserContent, -2);

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { body: 'New body' },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'title',
        title: 'Title',
        body: 'New body',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 1,
        tabcoins_credit: 3,
        tabcoins_debit: -2,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.updated_at > defaultUserContent.updated_at.toISOString()).toBe(true);
    });

    test('Content with "body" containing blank String', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { body: '' },
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"body" não pode estar em branco.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "body" containing empty Markdown', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        {
          body: `![](https://image-url.com/image.png)
            <div><a></a></div>`,
        },
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('Markdown deve conter algum texto.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "title", "body" and "source_url" containing \\u0000 null characters', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Contendo caractere \u0000 proibido no Postgres',
        body: '\u0000Começando com caractere proibido no Postgres',
        source_url: 'https://\u0000teste-caractere.invalido/',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        {
          title: '\u0000Começando com caractere proibido no Postgres',
          body: 'Terminando com caractere proibido no Postgres\u0000',
          source_url: 'https://teste-caractere.invalido/\u0000',
        },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'contendo-caractere-proibido-no-postgres',
        title: 'Começando com caractere proibido no Postgres',
        body: 'Terminando com caractere proibido no Postgres',
        status: 'draft',
        type: 'content',
        source_url: 'https://teste-caractere.invalido/',
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('Content with "title" and "body" containing invalid characters', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: '\u2800Título começando com caracteres inválidos.',
        body: 'Texto começando com caracteres inválidos.',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        {
          title: 'Título terminando com caracteres inválidos.\u200f',
          body: '\u2800Texto terminando com caracteres inválidos.\u200e',
        },
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"body" deve começar com caracteres visíveis.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "body" containing more than 20.000 characters', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { body: 'A'.repeat(20001) },
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"body" deve conter no máximo 20000 caracteres.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "body" containing untrimmed values', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { body: ' Espaço no início e no fim ' },
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"body" deve começar com caracteres visíveis.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "body" ending with untrimmed values', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { body: 'Espaço só no fim ' },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'titulo-velho',
        title: 'Título velho',
        body: 'Espaço só no fim',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.updated_at > defaultUserContent.updated_at.toISOString()).toBe(true);
    });

    test('Content with "body" containing Null value', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { body: null },
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"body" deve ser do tipo String.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "slug" declared solely', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
        slug: 'slug-velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { slug: 'slug-novo' },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'slug-novo',
        title: 'Título velho',
        body: 'Body velho',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.updated_at > defaultUserContent.updated_at.toISOString()).toBe(true);
    });

    test('Content with "slug" containing the same value of another content (same user, both "published" status)', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      // firstContent
      await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Primeiro conteúdo',
        body: 'Primeiro conteúdo',
        slug: 'primeiro-conteudo',
        status: 'published',
      });

      const secondContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Segundo conteúdo',
        body: 'Segundo conteúdo',
        slug: 'segundo-conteudo',
        status: 'published',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${secondContent.slug}`,
        { slug: 'primeiro-conteudo' },
      );

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: 'O conteúdo enviado parece ser duplicado.',
        action: 'Utilize um "title" ou "slug" com começo diferente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:CONTENT:CHECK_FOR_CONTENT_UNIQUENESS:ALREADY_EXISTS',
        key: 'slug',
      });
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('Content with "slug" containing the same value of another content (same user, one with "draft" and the other "published" status)', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      // firstContent
      await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Primeiro conteúdo',
        body: 'Primeiro conteúdo',
        slug: 'primeiro-conteudo',
        status: 'draft',
      });

      const secondContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Segundo conteúdo',
        body: 'Segundo conteúdo',
        slug: 'segundo-conteudo',
        status: 'published',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${secondContent.slug}`,
        { slug: 'primeiro-conteudo' },
      );

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: 'O conteúdo enviado parece ser duplicado.',
        action: 'Utilize um "title" ou "slug" com começo diferente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:CONTENT:CHECK_FOR_CONTENT_UNIQUENESS:ALREADY_EXISTS',
        key: 'slug',
      });
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('Content with "slug" containing the same value of another content (same user, one with "published" and the other "deleted" status)', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const firstContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Primeiro conteúdo',
        body: 'Primeiro conteúdo',
        slug: 'primeiro-conteudo',
        status: 'published',
      });

      await orchestrator.updateContent(firstContent.id, {
        status: 'deleted',
      });

      const secondContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Segundo conteúdo',
        body: 'Segundo conteúdo',
        slug: 'segundo-conteudo',
        status: 'published',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${secondContent.slug}`,
        { slug: 'primeiro-conteudo' },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'primeiro-conteudo',
        title: 'Segundo conteúdo',
        body: 'Segundo conteúdo',
        status: 'published',
        type: 'content',
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: responseBody.published_at,
        deleted_at: null,
        owner_username: defaultUser.username,
      });

      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.published_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('Content with "slug" containing a blank String', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { slug: '' },
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"slug" não pode estar em branco.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test(`Content with "slug" containing more than ${maxSlugLength} bytes`, async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        {
          slug: `this-slug-must-be-changed-from-${1 + maxSlugLength}-to-${maxSlugLength}-bytes`.padEnd(
            1 + maxSlugLength,
            's',
          ),
        },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: `this-slug-must-be-changed-from-${1 + maxSlugLength}-to-${maxSlugLength}-bytes`.padEnd(
          maxSlugLength,
          's',
        ),
        title: 'Título velho',
        body: 'Body velho',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.updated_at > defaultUserContent.updated_at.toISOString()).toBe(true);
    });

    test('Content with "slug" containing special characters', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { slug: 'slug-não-pode-ter-caracteres-especiais' },
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"slug" está no formato errado.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "slug" containing Null value', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { slug: null },
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"slug" deve ser do tipo String.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "slug" with trailing hyphen', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        {
          slug: 'slug-with-trailing-hyphen---',
        },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'slug-with-trailing-hyphen',
        title: 'Título velho',
        body: 'Body velho',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.updated_at > defaultUserContent.updated_at.toISOString()).toBe(true);
    });

    test('Content with "title" declared solely', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { title: 'Título novo' },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'titulo-velho',
        title: 'Título novo',
        body: 'Body velho',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.updated_at > defaultUserContent.updated_at.toISOString()).toBe(true);
    });

    test('Content with "title" containing a blank String', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { title: '' },
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"title" não pode estar em branco.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "title", but current content is "deleted"', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      await orchestrator.updateContent(defaultUserContent.id, {
        status: 'deleted',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { title: 'Título novo' },
      );

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'O conteúdo informado não foi encontrado no sistema.',
        action: 'Verifique se o "slug" está digitado corretamente.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'CONTROLLER:CONTENT:PATCH_HANDLER:SLUG_NOT_FOUND',
        key: 'slug',
      });
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test(`Content with "title" containing more than ${maxTitleLength} characters`, async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        {
          title: `Este título possui ${1 + maxTitleLength} caracteres`.padEnd(1 + maxTitleLength, 's'),
        },
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe(`"title" deve conter no máximo ${maxTitleLength} caracteres.`);
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "title" containing Null value in "root" content', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { title: null },
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"title" é um campo obrigatório.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:CONTENT:CHECK_ROOT_CONTENT_TITLE:MISSING_TITLE');
    });

    test('Content with "title" containing Null value in "child" content', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Root old title',
        body: 'Root old body',
      });

      const childContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        parent_id: rootContent.id,
        title: 'Child old title',
        body: 'Child old body',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${childContent.slug}`,
        { title: null },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: childContent.id,
        owner_id: defaultUser.id,
        parent_id: rootContent.id,
        slug: 'child-old-title',
        title: null,
        body: 'Child old body',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.updated_at > childContent.updated_at.toISOString()).toBe(true);
    });

    test('Content with "title" containing untrimmed values', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { title: ' Título válido, mas com espaços em branco no início e no fim ' },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'titulo-velho',
        title: 'Título válido, mas com espaços em branco no início e no fim',
        body: 'Body velho',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.updated_at > defaultUserContent.updated_at.toISOString()).toBe(true);
    });

    test('Content with "title" containing unescaped characters', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { title: `Tab & News | Conteúdos com \n valor <strong>concreto</strong> e "massa"> participe! '\\o/'` },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'titulo-velho',
        title: `Tab & News | Conteúdos com \n valor <strong>concreto</strong> e "massa"> participe! '\\o/'`,
        body: 'Body velho',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.updated_at > defaultUserContent.updated_at.toISOString()).toBe(true);
    });

    test('Content with "status" "draft" set to "draft"', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { status: 'draft' },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'titulo-velho',
        title: 'Título velho',
        body: 'Body velho',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.updated_at > defaultUserContent.updated_at.toISOString()).toBe(true);
    });

    test('Content with "status" "draft" set to "published"', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: relevantBody,
        status: 'draft',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { status: 'published' },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'titulo-velho',
        title: 'Título velho',
        body: relevantBody,
        status: 'published',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: responseBody.published_at,
        deleted_at: null,
        tabcoins: 1,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(Date.parse(responseBody.published_at)).not.toBeNaN();
      expect(responseBody.updated_at > defaultUserContent.updated_at.toISOString()).toBe(true);
    });

    test('Content with "status" "published" set to "draft"', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
        status: 'published',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { status: 'draft' },
      );

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: 'Não é possível alterar para rascunho um conteúdo já publicado.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:CONTENT:CHECK_STATUS_CHANGE:STATUS_ALREADY_PUBLISHED',
        key: 'status',
      });
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('Content with "status" "published" set to "deleted"', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Title',
        body: relevantBody,
        status: 'published',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { status: 'deleted' },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'title',
        title: 'Title',
        body: relevantBody,
        status: 'deleted',
        type: 'content',
        tabcoins: 1,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: responseBody.published_at,
        deleted_at: responseBody.deleted_at,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(uuidVersion(responseBody.owner_id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(Date.parse(responseBody.published_at)).not.toBeNaN();
      expect(Date.parse(responseBody.deleted_at)).not.toBeNaN();
      expect(responseBody.updated_at > defaultUserContent.updated_at.toISOString()).toBe(true);
      expect(responseBody.deleted_at > defaultUserContent.published_at.toISOString()).toBe(true);
    });

    test('Content with "status" "published" set to "deleted", than "published"', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const originalContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Title',
        body: 'Body',
        status: 'published',
      });

      await contentsRequestBuilder.patch(`/${defaultUser.username}/${originalContent.slug}`, {
        status: 'deleted',
      });

      const { response: republishedResponse, responseBody: republishedResponseBody } =
        await contentsRequestBuilder.patch(`/${defaultUser.username}/${originalContent.slug}`, { status: 'published' });

      expect.soft(republishedResponse.status).toBe(404);
      expect(republishedResponseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'O conteúdo informado não foi encontrado no sistema.',
        action: 'Verifique se o "slug" está digitado corretamente.',
        status_code: 404,
        error_id: republishedResponseBody.error_id,
        request_id: republishedResponseBody.request_id,
        error_location_code: 'CONTROLLER:CONTENT:PATCH_HANDLER:SLUG_NOT_FOUND',
        key: 'slug',
      });
      expect(uuidVersion(republishedResponseBody.error_id)).toBe(4);
      expect(uuidVersion(republishedResponseBody.request_id)).toBe(4);
    });

    test('Content with "status" set to "non_existent_status"', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { status: 'non_existent_status' },
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe(
        '"status" deve possuir um dos seguintes valores: "draft", "published", "deleted", "firewall".',
      );
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "status" set to "firewall"', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título',
        body: 'Body',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { status: 'firewall' },
      );

      expect.soft(response.status).toBe(400);
      expect(responseBody).toStrictEqual({
        status_code: 400,
        name: 'ValidationError',
        message: 'Não é possível atualizar um conteúdo para o status "firewall".',
        action: 'Ajuste os dados enviados e tente novamente.',
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:CONTENT:VALIDATE_UPDATE_SCHEMA:INVALID_STATUS',
        key: 'status',
        type: 'any.only',
      });
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('Content with "status" set to Null', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { status: null },
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe(
        '"status" deve possuir um dos seguintes valores: "draft", "published", "deleted", "firewall".',
      );
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "status" set a blank String', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { status: '' },
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe(
        '"status" deve possuir um dos seguintes valores: "draft", "published", "deleted", "firewall".',
      );
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "source_url" containing a valid HTTP URL', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { source_url: 'http://www.tabnews.com.br/' },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'titulo-velho',
        title: 'Título velho',
        body: 'Body velho',
        status: 'draft',
        type: 'content',
        source_url: 'http://www.tabnews.com.br/',
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.updated_at > defaultUserContent.updated_at.toISOString()).toBe(true);
    });

    test('Content with "source_url" containing a valid HTTPS URL', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { source_url: 'https://www.tabnews.com.br/museu' },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'titulo-velho',
        title: 'Título velho',
        body: 'Body velho',
        status: 'draft',
        type: 'content',
        source_url: 'https://www.tabnews.com.br/museu',
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.updated_at > defaultUserContent.updated_at.toISOString()).toBe(true);
    });

    test('Content with "source_url" containing a valid long TLD', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Alterar um baita de um Top-Level Domain',
        body: 'O maior TLD listado em http://data.iana.org/TLD/tlds-alpha-by-domain.txt possuía 24 caracteres',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { source_url: 'https://nic.xn--vermgensberatung-pwb/' },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'alterar-um-baita-de-um-top-level-domain',
        title: 'Alterar um baita de um Top-Level Domain',
        body: 'O maior TLD listado em http://data.iana.org/TLD/tlds-alpha-by-domain.txt possuía 24 caracteres',
        status: 'draft',
        type: 'content',
        source_url: 'https://nic.xn--vermgensberatung-pwb/',
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.updated_at > defaultUserContent.updated_at.toISOString()).toBe(true);
    });

    test('Content with "source_url" containing a valid short URL', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Alterar URL bem curta',
        body: 'Por exemplo o encurtador do Telegram',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { source_url: 'https://t.me' },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'alterar-url-bem-curta',
        title: 'Alterar URL bem curta',
        body: 'Por exemplo o encurtador do Telegram',
        status: 'draft',
        type: 'content',
        source_url: 'https://t.me',
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.updated_at > defaultUserContent.updated_at.toISOString()).toBe(true);
    });

    test('Content with "source_url" containing a invalid short TLD', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Alterar um Top-Level Domain menor que o permitido',
        body: 'TLDs precisam ter pelo menos dois caracteres',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { source_url: 'http://invalidtl.d' },
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe(
        '"source_url" deve possuir uma URL válida e utilizando os protocolos HTTP ou HTTPS.',
      );
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "source_url" containing a invalid long TLD', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Alterar um Top-Level Domain maior que o permitido',
        body: 'O maior TLD listado em http://data.iana.org/TLD/tlds-alpha-by-domain.txt possuía 24 caracteres',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { source_url: 'https://tl.dcomvinteecincocaracteres' },
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe(
        '"source_url" deve possuir uma URL válida e utilizando os protocolos HTTP ou HTTPS.',
      );
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "source_url" containing a not accepted Protocol', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { source_url: 'ftp://www.tabnews.com.br' },
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe(
        '"source_url" deve possuir uma URL válida e utilizando os protocolos HTTP ou HTTPS.',
      );
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "source_url" not containing a protocol', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { source_url: 'www.tabnews.com.br' },
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe(
        '"source_url" deve possuir uma URL válida e utilizando os protocolos HTTP ou HTTPS.',
      );
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "source_url" containing an incomplete URL', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { source_url: 'https://lol.' },
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe(
        '"source_url" deve possuir uma URL válida e utilizando os protocolos HTTP ou HTTPS.',
      );
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "source_url" containing query parameters', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { source_url: 'https://www.tabnews.com.br/api/v1/contents?strategy=old' },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'titulo-velho',
        title: 'Título velho',
        body: 'Body velho',
        status: 'draft',
        type: 'content',
        source_url: 'https://www.tabnews.com.br/api/v1/contents?strategy=old',
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.published_at).toBeNull();
      expect(responseBody.updated_at > defaultUserContent.updated_at.toISOString()).toBe(true);
    });

    test('Content with "source_url" containing fragment component', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { source_url: 'https://www.tabnews.com.br/#:~:text=TabNews,-Status' },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'titulo-velho',
        title: 'Título velho',
        body: 'Body velho',
        status: 'draft',
        type: 'content',
        source_url: 'https://www.tabnews.com.br/#:~:text=TabNews,-Status',
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.published_at).toBeNull();
      expect(responseBody.updated_at > defaultUserContent.updated_at.toISOString()).toBe(true);
    });

    test('Content with "source_url" containing an empty String', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { source_url: '' },
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"source_url" não pode estar em branco.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "source_url" containing a Null value', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const defaultUserContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Título velho',
        body: 'Body velho',
        source_url: 'https://www.tabnews.com.br',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${defaultUserContent.slug}`,
        { source_url: null },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'titulo-velho',
        title: 'Título velho',
        body: 'Body velho',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.updated_at > defaultUserContent.updated_at.toISOString()).toBe(true);
    });

    test('Content with "parent_id" declared solely', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Root content title',
        body: 'Root content body',
      });

      const childContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Child content title',
        body: 'Child content body',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${childContent.slug}`,
        { parent_id: rootContent.id },
      );

      expect.soft(response.status).toBe(400);

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('Objeto enviado deve ter no mínimo uma chave.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "title" and "parent_id" set to another "parent_id"', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const rootContent1 = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Root content title #1',
        body: 'Root content body #1',
      });

      const rootContent2 = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Root content title #2',
        body: 'Root content body #2',
      });

      const childContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Child content title',
        body: 'Child content body',
        parent_id: rootContent1.id,
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${defaultUser.username}/${childContent.slug}`,
        {
          title: 'Updated title, but not "parent_id"',
          parent_id: rootContent2.id,
        },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: rootContent1.id,
        slug: 'child-content-title',
        title: 'Updated title, but not "parent_id"',
        body: 'Child content body',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.updated_at > childContent.updated_at.toISOString()).toBe(true);
    });

    test('Content from another user', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();
      const secondUser = await orchestrator.createUser();

      const secondUserContent = await orchestrator.createContent({
        owner_id: secondUser.id,
        title: 'Conteúdo do Segundo Usuário antes do patch!',
        body: 'Body antes do patch!',
        status: 'published',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${secondUser.username}/${secondUserContent.slug}`,
        { title: 'Tentando atualizar o conteúdo.' },
      );

      expect.soft(response.status).toBe(403);
      expect.soft(responseBody.status_code).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Você não possui permissão para atualizar o conteúdo de outro usuário.');
      expect(responseBody.action).toBe('Verifique se você possui a feature "update:content:others".');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe(
        'CONTROLLER:CONTENTS:PATCH:USER_CANT_UPDATE_CONTENT_FROM_OTHER_USER',
      );
    });

    describe('TabCoins', () => {
      test('"root" content updated from "draft" to "draft" status', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(defaultUser.id);

        const defaultUserContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: 'Title',
          body: 'Body',
          status: 'draft',
        });

        const { responseBody } = await contentsRequestBuilder.patch(
          `/${defaultUser.username}/${defaultUserContent.slug}`,
          { status: 'draft' },
        );

        expect(responseBody.tabcoins).toBe(0);

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcoins).toBe(0);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('"root" content updated from "draft" to "published" status', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(defaultUser.id);

        const defaultUserContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: 'Title',
          body: relevantBody,
          status: 'draft',
        });

        const { responseBody } = await contentsRequestBuilder.patch(
          `/${defaultUser.username}/${defaultUserContent.slug}`,
          { status: 'published' },
        );

        expect(responseBody.tabcoins).toBe(1);

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcoins).toBe(2);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('"root" content updated from "draft" to "deleted" status', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(defaultUser.id);

        const defaultUserContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: 'Title',
          body: 'Body',
          status: 'draft',
        });

        const { responseBody } = await contentsRequestBuilder.patch(
          `/${defaultUser.username}/${defaultUserContent.slug}`,
          { status: 'deleted' },
        );

        expect(responseBody.tabcoins).toBe(0);

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcoins).toBe(0);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('"root" content updated from "published" to "deleted" status (with prestige)', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();
        const prestigeContents = await orchestrator.createPrestige(defaultUser.id, { rootPrestigeNumerator: 8 });

        const defaultUserContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: 'Title',
          body: relevantBody,
          status: 'published',
        });

        const { responseBody: userResponseBodyBefore } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBodyBefore.tabcoins).toBe(8);
        expect(userResponseBodyBefore.tabcash).toBe(0);

        await orchestrator.createBalance({
          balanceType: 'content:tabcoin:initial',
          recipientId: prestigeContents[0].id,
          amount: 1,
          originatorType: 'orchestrator',
          originatorId: prestigeContents[0].id,
        });

        const { responseBody } = await contentsRequestBuilder.patch(
          `/${defaultUser.username}/${defaultUserContent.slug}`,
          { status: 'deleted' },
        );

        expect(responseBody.tabcoins).toBe(1);

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcoins).toBe(0);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('"root" content updated from "published" to "deleted" status (without prestige)', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();

        const defaultUserContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: 'Title',
          body: relevantBody,
          status: 'published',
        });

        const { responseBody: userResponseBodyBefore } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBodyBefore.tabcoins).toBe(0);
        expect(userResponseBodyBefore.tabcash).toBe(0);

        await orchestrator.createPrestige(defaultUser.id, { rootPrestigeNumerator: 1 });

        const { responseBody } = await contentsRequestBuilder.patch(
          `/${defaultUser.username}/${defaultUserContent.slug}`,
          { status: 'deleted' },
        );

        expect(responseBody.tabcoins).toBe(1);

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcoins).toBe(0);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('Deletion of "root" content that was first published without the minimum amount of relevant words', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(defaultUser.id, { rootPrestigeNumerator: 4 });

        const defaultUserContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: 'Title',
          body: 'Body with no minimum amount of relevant words',
          status: 'published',
        });

        const { responseBody: userResponseBodyBefore } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBodyBefore.tabcoins).toBe(0);
        expect(userResponseBodyBefore.tabcash).toBe(0);

        const { responseBody } = await contentsRequestBuilder.patch(
          `/${defaultUser.username}/${defaultUserContent.slug}`,
          { status: 'deleted' },
        );

        expect(responseBody.tabcoins).toBe(0);

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcoins).toBe(0);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('"root" content with positive tabcoins updated from "published" to "deleted" status (with prestige)', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();
        const prestigeContents = await orchestrator.createPrestige(defaultUser.id);

        const defaultUserContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: 'Title',
          body: relevantBody,
          status: 'published',
        });

        await orchestrator.createBalance({
          balanceType: 'content:tabcoin:credit',
          recipientId: prestigeContents[0].id,
          amount: 8,
          originatorType: 'orchestrator',
          originatorId: prestigeContents[0].id,
        });

        await orchestrator.createRate(defaultUserContent, 10);

        const { responseBody: contentFirstGetResponseBody } = await contentsRequestBuilder.get(
          `/${defaultUser.username}/${defaultUserContent.slug}`,
        );
        expect(contentFirstGetResponseBody.tabcoins).toBe(11);

        const { responseBody: userFirstGetResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);
        expect(userFirstGetResponseBody.tabcoins).toBe(12);

        const { responseBody: contentSecondResponseBody } = await contentsRequestBuilder.patch(
          `/${defaultUser.username}/${defaultUserContent.slug}`,
          { status: 'deleted' },
        );

        expect(contentSecondResponseBody.tabcoins).toBe(11);

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcoins).toBe(0);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('"root" content with positive tabcoins updated from "published" to "deleted" status (without prestige)', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();

        const defaultUserContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: 'Title',
          body: relevantBody,
          status: 'published',
        });

        await orchestrator.createPrestige(defaultUser.id, { rootPrestigeNumerator: 8 });

        await orchestrator.createRate(defaultUserContent, 10);

        const { responseBody: contentFirstGetResponseBody } = await contentsRequestBuilder.get(
          `/${defaultUser.username}/${defaultUserContent.slug}`,
        );
        expect(contentFirstGetResponseBody.tabcoins).toBe(11);

        const { responseBody: userFirstGetResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);
        expect(userFirstGetResponseBody.tabcoins).toBe(10);

        const { responseBody: contentSecondResponseBody } = await contentsRequestBuilder.patch(
          `/${defaultUser.username}/${defaultUserContent.slug}`,
          { status: 'deleted' },
        );

        expect(contentSecondResponseBody.tabcoins).toBe(11);

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcoins).toBe(0);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('"root" content with negative tabcoins updated from "published" to "deleted" status (with prestige)', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();
        const prestigeContents = await orchestrator.createPrestige(defaultUser.id);

        const defaultUserContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: 'Title',
          body: relevantBody,
          status: 'published',
        });

        await orchestrator.createBalance({
          balanceType: 'content:tabcoin:credit',
          recipientId: prestigeContents[0].id,
          amount: 10,
          originatorType: 'orchestrator',
          originatorId: prestigeContents[0].id,
        });

        await orchestrator.createRate(defaultUserContent, -10);

        const { responseBody: contentFirstGetResponseBody } = await contentsRequestBuilder.get(
          `/${defaultUser.username}/${defaultUserContent.slug}`,
        );
        expect(contentFirstGetResponseBody.tabcoins).toBe(-9);

        const { responseBody: userFirstGetResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);
        expect(userFirstGetResponseBody.tabcoins).toBe(-8);

        const { responseBody: contentSecondResponseBody } = await contentsRequestBuilder.patch(
          `/${defaultUser.username}/${defaultUserContent.slug}`,
          { status: 'deleted' },
        );

        expect(contentSecondResponseBody.tabcoins).toBe(-9);

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcoins).toBe(-10);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('"root" content with negative tabcoins updated from "published" to "deleted" status (without prestige)', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();

        const defaultUserContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: 'Title',
          body: relevantBody,
          status: 'published',
        });

        await orchestrator.createPrestige(defaultUser.id, { rootPrestigeNumerator: 10 });

        await orchestrator.createRate(defaultUserContent, -10);

        const { responseBody: contentFirstGetResponseBody } = await contentsRequestBuilder.get(
          `/${defaultUser.username}/${defaultUserContent.slug}`,
        );
        expect(contentFirstGetResponseBody.tabcoins).toBe(-9);

        const { responseBody: userFirstGetResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);
        expect(userFirstGetResponseBody.tabcoins).toBe(-10);

        const { responseBody: contentSecondResponseBody } = await contentsRequestBuilder.patch(
          `/${defaultUser.username}/${defaultUserContent.slug}`,
          { status: 'deleted' },
        );

        expect(contentSecondResponseBody.tabcoins).toBe(-9);

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcoins).toBe(-10);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('"child" content updated from "draft" to "draft" status', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(defaultUser.id);

        // User will receive tabcoins for publishing a root content.
        const rootContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: 'Root',
          body: relevantBody,
          status: 'published',
        });

        const childContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          parent_id: rootContent.id,
          title: 'Child',
          body: relevantBody,
        });

        const { responseBody: responseBody } = await contentsRequestBuilder.patch(
          `/${defaultUser.username}/${childContent.slug}`,
          { status: 'draft' },
        );

        expect(responseBody.tabcoins).toBe(0);

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcoins).toBe(2);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('"child" content updated from "draft" to "published" status (same user)', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(defaultUser.id);

        // User will receive tabcoins for publishing a root content.
        const rootContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: 'Root',
          body: relevantBody,
          status: 'published',
        });

        const childContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          parent_id: rootContent.id,
          title: 'Child',
          body: relevantBody,
          status: 'draft',
        });

        const { responseBody: responseBody } = await contentsRequestBuilder.patch(
          `/${defaultUser.username}/${childContent.slug}`,
          { status: 'published' },
        );

        expect(responseBody.tabcoins).toBe(0);

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcoins).toBe(2);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('"child" content updated from "draft" to "published" status (different user)', async () => {
        const firstUser = await orchestrator.createUser();
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const secondUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(firstUser.id);
        await orchestrator.createPrestige(secondUser.id);

        const rootContent = await orchestrator.createContent({
          owner_id: firstUser.id,
          title: 'Root',
          body: relevantBody,
          status: 'published',
        });

        const childContent = await orchestrator.createContent({
          owner_id: secondUser.id,
          parent_id: rootContent.id,
          title: 'Child',
          body: relevantBody,
          status: 'draft',
        });

        const { responseBody: userResponse1Body } = await usersRequestBuilder.get(`/${secondUser.username}`);

        expect(userResponse1Body.tabcoins).toBe(0);
        expect(userResponse1Body.tabcash).toBe(0);

        const { responseBody: responseBody } = await contentsRequestBuilder.patch(
          `/${secondUser.username}/${childContent.slug}`,
          { status: 'published' },
        );

        expect(responseBody.tabcoins).toBe(1);

        const { responseBody: userResponse2Body } = await usersRequestBuilder.get(`/${secondUser.username}`);

        expect(userResponse2Body.tabcoins).toBe(2);
        expect(userResponse2Body.tabcash).toBe(0);
      });

      test('"child" content updated from "draft" to "deleted" status (same user)', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(defaultUser.id);

        // User will receive tabcoins for publishing a root content.
        const rootContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: 'Root',
          body: relevantBody,
          status: 'published',
        });

        const childContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          parent_id: rootContent.id,
          title: 'Child',
          body: relevantBody,
          status: 'draft',
        });

        const { responseBody: userResponse1Body } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponse1Body.tabcoins).toBe(2);
        expect(userResponse1Body.tabcash).toBe(0);

        const { responseBody: responseBody } = await contentsRequestBuilder.patch(
          `/${defaultUser.username}/${childContent.slug}`,
          { status: 'deleted' },
        );

        expect(responseBody.tabcoins).toBe(0);

        const { responseBody: userResponse2Body } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponse2Body.tabcoins).toBe(2);
        expect(userResponse2Body.tabcash).toBe(0);
      });

      test('"child" content updated from "draft" to "deleted" status (different user)', async () => {
        const firstUser = await orchestrator.createUser();
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const secondUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(firstUser.id);
        await orchestrator.createPrestige(secondUser.id);

        const rootContent = await orchestrator.createContent({
          owner_id: firstUser.id,
          title: 'Root',
          body: relevantBody,
          status: 'published',
        });

        const childContent = await orchestrator.createContent({
          owner_id: secondUser.id,
          parent_id: rootContent.id,
          title: 'Child',
          body: relevantBody,
          status: 'draft',
        });

        const { responseBody: userResponse1Body } = await usersRequestBuilder.get(`/${secondUser.username}`);

        expect(userResponse1Body.tabcoins).toBe(0);
        expect(userResponse1Body.tabcash).toBe(0);

        const { responseBody: responseBody } = await contentsRequestBuilder.patch(
          `/${secondUser.username}/${childContent.slug}`,
          { status: 'deleted' },
        );

        expect(responseBody.tabcoins).toBe(0);

        const { responseBody: userResponse2Body } = await usersRequestBuilder.get(`/${secondUser.username}`);

        expect(userResponse2Body.tabcoins).toBe(0);
        expect(userResponse2Body.tabcash).toBe(0);
      });

      test('"child" content updated from "published" to "deleted" status (same user - with prestige)', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(defaultUser.id);

        // User will receive tabcoins for publishing a root content.
        const rootContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: 'Root',
          body: relevantBody,
          status: 'published',
        });

        const childContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          parent_id: rootContent.id,
          title: 'Child',
          body: relevantBody,
          status: 'published',
        });

        const { responseBody: userResponse1Body } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponse1Body.tabcoins).toBe(2);
        expect(userResponse1Body.tabcash).toBe(0);

        const { responseBody: responseBody } = await contentsRequestBuilder.patch(
          `/${defaultUser.username}/${childContent.slug}`,
          { status: 'deleted' },
        );

        expect(responseBody.tabcoins).toBe(0);

        const { responseBody: userResponse2Body } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponse2Body.tabcoins).toBe(2);
        expect(userResponse2Body.tabcash).toBe(0);
      });

      test('"child" content updated from "published" to "deleted" status (same user - without prestige)', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();

        // User will not receive tabcoins for publishing a root content.
        const rootContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: 'Root',
          body: relevantBody,
          status: 'published',
        });

        const childContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          parent_id: rootContent.id,
          title: 'Child',
          body: relevantBody,
          status: 'published',
        });

        const { responseBody: userResponse1Body } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponse1Body.tabcoins).toBe(0);
        expect(userResponse1Body.tabcash).toBe(0);

        const { responseBody: responseBody } = await contentsRequestBuilder.patch(
          `/${defaultUser.username}/${childContent.slug}`,
          { status: 'deleted' },
        );

        expect(responseBody.tabcoins).toBe(0);

        const { responseBody: userResponse2Body } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponse2Body.tabcoins).toBe(0);
        expect(userResponse2Body.tabcash).toBe(0);
      });

      test('"child" content updated from "published" to "deleted" status (different user - with prestige)', async () => {
        const firstUser = await orchestrator.createUser();
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const secondUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(secondUser.id);

        const rootContent = await orchestrator.createContent({
          owner_id: firstUser.id,
          title: 'Root',
          body: relevantBody,
          status: 'published',
        });

        const childContent = await orchestrator.createContent({
          owner_id: secondUser.id,
          parent_id: rootContent.id,
          title: 'Child',
          body: relevantBody,
          status: 'published',
        });

        const { responseBody: secondUserResponse1Body } = await usersRequestBuilder.get(`/${secondUser.username}`);

        expect(secondUserResponse1Body.tabcoins).toBe(2);
        expect(secondUserResponse1Body.tabcash).toBe(0);

        const { responseBody: responseBody } = await contentsRequestBuilder.patch(
          `/${secondUser.username}/${childContent.slug}`,
          { status: 'deleted' },
        );

        expect(responseBody.tabcoins).toBe(1);

        const { responseBody: secondUserResponse2Body } = await usersRequestBuilder.get(`/${secondUser.username}`);

        expect(secondUserResponse2Body.tabcoins).toBe(0);
        expect(secondUserResponse2Body.tabcash).toBe(0);
      });

      test('"child" content updated from "published" to "deleted" status (different user - without prestige)', async () => {
        const firstUser = await orchestrator.createUser();
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const secondUser = await contentsRequestBuilder.buildUser();

        const rootContent = await orchestrator.createContent({
          owner_id: firstUser.id,
          title: 'Root',
          body: relevantBody,
          status: 'published',
        });

        const childContent = await orchestrator.createContent({
          owner_id: secondUser.id,
          parent_id: rootContent.id,
          title: 'Child',
          body: relevantBody,
          status: 'published',
        });

        const { responseBody: secondUserResponse1Body } = await usersRequestBuilder.get(`/${secondUser.username}`);

        expect(secondUserResponse1Body.tabcoins).toBe(0);
        expect(secondUserResponse1Body.tabcash).toBe(0);

        const { responseBody: responseBody } = await contentsRequestBuilder.patch(
          `/${secondUser.username}/${childContent.slug}`,
          { status: 'deleted' },
        );

        expect(responseBody.tabcoins).toBe(1);

        const { responseBody: secondUserResponse2Body } = await usersRequestBuilder.get(`/${secondUser.username}`);

        expect(secondUserResponse2Body.tabcoins).toBe(0);
        expect(secondUserResponse2Body.tabcash).toBe(0);
      });

      test('Deletion of "child" content that was first published without the minimum amount of relevant words (without votes)', async () => {
        const firstUser = await orchestrator.createUser();
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const secondUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(secondUser.id);

        const rootContent = await orchestrator.createContent({
          owner_id: firstUser.id,
          title: 'Root',
          body: relevantBody,
          status: 'published',
        });

        const childContent = await orchestrator.createContent({
          owner_id: secondUser.id,
          parent_id: rootContent.id,
          title: 'Child',
          body: 'Body with no minimum amount of relevant words',
          status: 'published',
        });

        const { responseBody: userResponse1Body } = await usersRequestBuilder.get(`/${secondUser.username}`);

        expect(userResponse1Body.tabcoins).toBe(0);
        expect(userResponse1Body.tabcash).toBe(0);

        const { responseBody: responseBody } = await contentsRequestBuilder.patch(
          `/${secondUser.username}/${childContent.slug}`,
          { status: 'deleted' },
        );

        expect(responseBody.tabcoins).toBe(0);

        const { responseBody: userResponse2Body } = await usersRequestBuilder.get(`/${secondUser.username}`);

        expect(userResponse2Body.tabcoins).toBe(0);
        expect(userResponse2Body.tabcash).toBe(0);
      });

      test('Deletion of "child" content that was first published without the minimum amount of relevant words (with positive votes)', async () => {
        const firstUser = await orchestrator.createUser();
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const secondUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(secondUser.id);

        const rootContent = await orchestrator.createContent({
          owner_id: firstUser.id,
          title: 'Root',
          body: relevantBody,
          status: 'published',
        });

        const childContent = await orchestrator.createContent({
          owner_id: secondUser.id,
          parent_id: rootContent.id,
          title: 'Child',
          body: 'Body with no minimum amount of relevant words',
          status: 'published',
        });

        await orchestrator.createRate(childContent, 10);

        const { responseBody: userResponse1Body } = await usersRequestBuilder.get(`/${secondUser.username}`);

        expect(userResponse1Body.tabcoins).toBe(10);
        expect(userResponse1Body.tabcash).toBe(0);

        const { responseBody: responseBody } = await contentsRequestBuilder.patch(
          `/${secondUser.username}/${childContent.slug}`,
          { status: 'deleted' },
        );

        expect(responseBody.tabcoins).toBe(10);

        const { responseBody: userResponse2Body } = await usersRequestBuilder.get(`/${secondUser.username}`);

        expect(userResponse2Body.tabcoins).toBe(0);
        expect(userResponse2Body.tabcash).toBe(0);
      });

      test('Deletion of "child" content that was first published without the minimum amount of relevant words (with negative votes)', async () => {
        const firstUser = await orchestrator.createUser();
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const secondUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(secondUser.id);

        const rootContent = await orchestrator.createContent({
          owner_id: firstUser.id,
          title: 'Root',
          body: relevantBody,
          status: 'published',
        });

        const childContent = await orchestrator.createContent({
          owner_id: secondUser.id,
          parent_id: rootContent.id,
          title: 'Child',
          body: 'Body with no minimum amount of relevant words',
          status: 'published',
        });

        await orchestrator.createRate(childContent, -10);

        const { responseBody: userResponse1Body } = await usersRequestBuilder.get(`/${secondUser.username}`);

        expect(userResponse1Body.tabcoins).toBe(-10);
        expect(userResponse1Body.tabcash).toBe(0);

        const { responseBody: responseBody } = await contentsRequestBuilder.patch(
          `/${secondUser.username}/${childContent.slug}`,
          { status: 'deleted' },
        );

        expect(responseBody.tabcoins).toBe(-10);

        const { responseBody: userResponse2Body } = await usersRequestBuilder.get(`/${secondUser.username}`);

        expect(userResponse2Body.tabcoins).toBe(-10);
        expect(userResponse2Body.tabcash).toBe(0);
      });
    });
  });

  describe('User with "update:content:others" feature', () => {
    test('Content from another user', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser({ with: ['update:content:others'] });

      const secondUser = await orchestrator.createUser();
      const secondUserContent = await orchestrator.createContent({
        owner_id: secondUser.id,
        title: 'Conteúdo do Segundo Usuário antes do patch!',
        body: relevantBody,
        status: 'published',
      });

      const { response, responseBody } = await contentsRequestBuilder.patch(
        `/${secondUser.username}/${secondUserContent.slug}`,
        {
          title: 'Novo title.',
          body: 'Novo body.',
        },
      );

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: secondUserContent.id,
        owner_id: secondUser.id,
        parent_id: null,
        slug: 'conteudo-do-segundo-usuario-antes-do-patch',
        title: 'Novo title.',
        body: 'Novo body.',
        status: 'published',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: responseBody.published_at,
        deleted_at: null,
        tabcoins: 1,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: secondUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(Date.parse(responseBody.published_at)).not.toBeNaN();
      expect(responseBody.published_at).toBe(secondUserContent.published_at.toISOString());
      expect(responseBody.updated_at > secondUserContent.updated_at.toISOString()).toBe(true);
    });
  });
});
</file>

<file path="tests/integration/api/v1/contents/[username]/get.test.js">
import parseLinkHeader from 'parse-link-header';
import { version as uuidVersion } from 'uuid';

import { defaultTabCashForAdCreation, relevantBody } from 'tests/constants-for-tests';
import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('GET /api/v1/contents/[username]', () => {
  describe('Anonymous user', () => {
    test('"username" non-existent', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/contents/ThisUserDoesNotExists`);
      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);
      expect.soft(responseBody.status_code).toBe(404);
      expect(responseBody.name).toBe('NotFoundError');
      expect(responseBody.message).toBe('O "username" informado não foi encontrado no sistema.');
      expect(responseBody.action).toBe('Verifique se o "username" está digitado corretamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:USER:FIND_ONE_BY_USERNAME:NOT_FOUND');
    });

    test('"username" existent, but with no content at all', async () => {
      const defaultUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      // secondUserRootContent
      await orchestrator.createContent({
        owner_id: secondUser.id,
        title: 'Conteúdo de outro usuário',
        status: 'published',
      });

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}`);
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);
      expect(responseBody).toStrictEqual([]);
    });

    test('"username" existent, but with no "published" "root" content', async () => {
      const defaultUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      // secondUserRootContent
      await orchestrator.createContent({
        owner_id: secondUser.id,
        title: 'Conteúdo de outro usuário',
        status: 'published',
      });

      // defaultUserContent
      await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Draft content',
        body: 'Draft content',
        status: 'draft',
      });

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}`);
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);
      expect(responseBody).toStrictEqual([]);
    });

    test('"username" existent and only with "published" "child" content (short body)', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      // secondUserRootContent
      await orchestrator.createContent({
        owner_id: secondUser.id,
        title: 'Conteúdo de outro usuário',
        status: 'published',
      });

      const rootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root content',
        body: 'Root content',
        status: 'draft',
      });

      const childContent = await orchestrator.createContent({
        parent_id: rootContent.id,
        owner_id: firstUser.id,
        body: 'Child content',
        status: 'published',
      });

      // childContentDraft
      await orchestrator.createContent({
        parent_id: rootContent.id,
        owner_id: firstUser.id,
        body: 'Child content with draft status',
        status: 'draft',
      });

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}`);
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);
      expect(responseBody).toStrictEqual([
        {
          id: childContent.id,
          owner_id: firstUser.id,
          parent_id: rootContent.id,
          slug: childContent.slug,
          title: null,
          body: 'Child content',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: childContent.created_at.toISOString(),
          updated_at: childContent.updated_at.toISOString(),
          published_at: childContent.published_at.toISOString(),
          deleted_at: null,
          owner_username: firstUser.username,
          tabcoins: 0,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          children_deep_count: 0,
        },
      ]);
    });

    test('"username" existent and only with "published" "child" content (long body)', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      // secondUserRootContent
      await orchestrator.createContent({
        owner_id: secondUser.id,
        title: 'Conteúdo de outro usuário',
        status: 'published',
      });

      const rootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root content',
        body: 'Root content',
        status: 'draft',
      });

      const childContent = await orchestrator.createContent({
        parent_id: rootContent.id,
        owner_id: firstUser.id,
        body: `Diferente do teste **anterior**, o corpo dessa publicação é grande,
        com quebras de linha, \`Markdown\` e ultrapassa o limite de caracteres que
        iremos devolver pelo response.

        ## Motivo

        Hoje estamos usando o mesmo número de caracteres de um \`title\` para que
        o frontend possa lidar com o mesmo tamanho de texto em ambos os casos.`,
        status: 'published',
      });

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}`);
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);
      expect(responseBody).toStrictEqual([
        {
          id: childContent.id,
          owner_id: firstUser.id,
          parent_id: rootContent.id,
          slug: childContent.slug,
          title: null,
          body: 'Diferente do teste anterior, o corpo dessa publicação é grande, com quebras de linha, Markdown e ultrapassa o limite de caracteres que iremos devolver pelo response. Motivo Hoje estamos usando o mesmo número de caracteres de um title para que o fronten...',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: childContent.created_at.toISOString(),
          updated_at: childContent.updated_at.toISOString(),
          published_at: childContent.published_at.toISOString(),
          deleted_at: null,
          owner_username: firstUser.username,
          tabcoins: 0,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          children_deep_count: 0,
        },
      ]);
    });

    test('"username" existent with 4 contents, with 2 "root" "published", 1 "child" "published", and strategy "new"', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const firstRootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Primeiro conteúdo criado',
        status: 'published',
      });

      const secondRootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Segundo conteúdo criado',
        status: 'published',
      });

      // thirdRootContent
      await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Terceiro conteúdo criado',
        body: `Este conteúdo não deverá aparecer na lista retornada pelo /contents/[username],
               porque quando um conteúdo possui o "status" como "draft", ele não
               esta pronto para ser listado publicamente.`,
        status: 'draft',
      });

      const childContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        parent_id: firstRootContent.id,
        body: `Este conteúdo agora deverá aparecer na lista retornada pelo /contents/[username]`,
        status: 'published',
      });

      // secondUserRootContent
      await orchestrator.createContent({
        owner_id: secondUser.id,
        title: 'Conteúdo de outro usuário',
        status: 'published',
      });

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}?strategy=new`);
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual([
        {
          id: childContent.id,
          owner_id: firstUser.id,
          parent_id: firstRootContent.id,
          slug: childContent.slug,
          title: null,
          body: 'Este conteúdo agora deverá aparecer na lista retornada pelo /contents/[username]',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: childContent.created_at.toISOString(),
          updated_at: childContent.updated_at.toISOString(),
          published_at: childContent.published_at.toISOString(),
          deleted_at: null,
          owner_username: firstUser.username,
          tabcoins: 0,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          children_deep_count: 0,
        },
        {
          id: secondRootContent.id,
          owner_id: firstUser.id,
          parent_id: null,
          slug: 'segundo-conteudo-criado',
          title: 'Segundo conteúdo criado',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: secondRootContent.created_at.toISOString(),
          updated_at: secondRootContent.updated_at.toISOString(),
          published_at: secondRootContent.published_at.toISOString(),
          deleted_at: null,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: firstUser.username,
          children_deep_count: 0,
        },
        {
          id: firstRootContent.id,
          owner_id: firstUser.id,
          parent_id: null,
          slug: 'primeiro-conteudo-criado',
          title: 'Primeiro conteúdo criado',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: firstRootContent.created_at.toISOString(),
          updated_at: firstRootContent.updated_at.toISOString(),
          published_at: firstRootContent.published_at.toISOString(),
          deleted_at: null,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: firstUser.username,
          children_deep_count: 1,
        },
      ]);

      expect(uuidVersion(responseBody[0].id)).toBe(4);
      expect(uuidVersion(responseBody[1].id)).toBe(4);
      expect(uuidVersion(responseBody[0].owner_id)).toBe(4);
      expect(uuidVersion(responseBody[1].owner_id)).toBe(4);
      expect(responseBody[0].published_at > responseBody[1].published_at).toBe(true);
    });

    test('"username" existent with 4 contents, but only 2 "root" "published"', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const firstRootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Primeiro conteúdo criado',
        status: 'published',
      });

      const secondRootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Segundo conteúdo criado',
        status: 'published',
      });

      // thirdRootContent
      await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Terceiro conteúdo criado',
        body: `Este conteúdo não deverá aparecer na lista retornada pelo /contents/[username],
               porque quando um conteúdo possui o "status" como "draft", ele não
               esta pronto para ser listado publicamente.`,
        status: 'draft',
      });

      const childContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        parent_id: firstRootContent.id,
        title: 'Quarto conteúdo criado',
        body: `Este conteúdo que agora deverá aparecer na lista retornada pelo /contents/[username]`,
        status: 'published',
      });

      // secondUserRootContent
      await orchestrator.createContent({
        owner_id: secondUser.id,
        title: 'Conteúdo de outro usuário',
        status: 'published',
      });

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}?strategy=new`);
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual([
        {
          id: childContent.id,
          owner_id: firstUser.id,
          parent_id: firstRootContent.id,
          slug: 'quarto-conteudo-criado',
          title: 'Quarto conteúdo criado',
          body: 'Este conteúdo que agora deverá aparecer na lista retornada pelo /contents/[username]',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: childContent.created_at.toISOString(),
          updated_at: childContent.updated_at.toISOString(),
          published_at: childContent.published_at.toISOString(),
          deleted_at: null,
          owner_username: firstUser.username,
          tabcoins: 0,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          children_deep_count: 0,
        },
        {
          id: secondRootContent.id,
          owner_id: firstUser.id,
          parent_id: null,
          slug: 'segundo-conteudo-criado',
          title: 'Segundo conteúdo criado',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: secondRootContent.created_at.toISOString(),
          updated_at: secondRootContent.updated_at.toISOString(),
          published_at: secondRootContent.published_at.toISOString(),
          deleted_at: null,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: firstUser.username,
          children_deep_count: 0,
        },
        {
          id: firstRootContent.id,
          owner_id: firstUser.id,
          parent_id: null,
          slug: 'primeiro-conteudo-criado',
          title: 'Primeiro conteúdo criado',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: firstRootContent.created_at.toISOString(),
          updated_at: firstRootContent.updated_at.toISOString(),
          published_at: firstRootContent.published_at.toISOString(),
          deleted_at: null,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: firstUser.username,
          children_deep_count: 1,
        },
      ]);

      expect(uuidVersion(responseBody[0].id)).toBe(4);
      expect(uuidVersion(responseBody[1].id)).toBe(4);
      expect(uuidVersion(responseBody[0].owner_id)).toBe(4);
      expect(uuidVersion(responseBody[1].owner_id)).toBe(4);
      expect(responseBody[0].published_at > responseBody[1].published_at).toBe(true);
    });

    test('"username" existent with "root" and "child" content with TabCoins credits and debits', async () => {
      const firstUser = await orchestrator.createUser();

      const rootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Conteúdo raiz',
        status: 'published',
      });

      await orchestrator.createRate(rootContent, -3);
      await orchestrator.createRate(rootContent, 1);

      const childContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        parent_id: rootContent.id,
        title: 'Comentário',
        body: 'Um comentário',
        status: 'published',
      });

      await orchestrator.createRate(childContent, 10);
      await orchestrator.createRate(childContent, -2);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}?strategy=new`);
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual([
        {
          id: childContent.id,
          owner_id: firstUser.id,
          parent_id: rootContent.id,
          slug: 'comentario',
          title: 'Comentário',
          body: 'Um comentário',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: childContent.created_at.toISOString(),
          updated_at: childContent.updated_at.toISOString(),
          published_at: childContent.published_at.toISOString(),
          deleted_at: null,
          owner_username: firstUser.username,
          tabcoins: 8,
          tabcoins_credit: 10,
          tabcoins_debit: -2,
          children_deep_count: 0,
        },
        {
          id: rootContent.id,
          owner_id: firstUser.id,
          parent_id: null,
          slug: 'conteudo-raiz',
          title: 'Conteúdo raiz',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: rootContent.created_at.toISOString(),
          updated_at: rootContent.updated_at.toISOString(),
          published_at: rootContent.published_at.toISOString(),
          deleted_at: null,
          tabcoins: -1,
          tabcoins_credit: 1,
          tabcoins_debit: -3,
          owner_username: firstUser.username,
          children_deep_count: 1,
        },
      ]);

      expect(uuidVersion(responseBody[0].id)).toBe(4);
      expect(uuidVersion(responseBody[1].id)).toBe(4);
      expect(uuidVersion(responseBody[0].owner_id)).toBe(4);
      expect(uuidVersion(responseBody[1].owner_id)).toBe(4);
      expect(responseBody[0].published_at > responseBody[1].published_at).toBe(true);
    });

    test('"username" existent with 60 contents, default pagination and strategy "new"', async () => {
      const defaultUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const numberOfContents = 60;
      const contentList = [];

      for (let item = 0; item < numberOfContents; item++) {
        const contentCreated = await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: `Conteúdo #${item + 1}`,
          status: 'published',
        });

        contentList.push(contentCreated);
      }

      const secondUserRootContent = await orchestrator.createContent({
        owner_id: secondUser.id,
        title: 'Conteúdo de outro usuário',
        status: 'published',
      });

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:credit',
        recipientId: secondUserRootContent.id, // Conteúdo de outro usuário
        amount: 22,
      });

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:credit',
        recipientId: contentList[30].id, // Conteúdo #31
        amount: 12,
      });

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:credit',
        recipientId: contentList[35].id, // Conteúdo #36
        amount: 7,
      });

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:debit',
        recipientId: contentList[49].id, // Conteúdo #50
        amount: -2,
      });

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:debit',
        recipientId: contentList[50].id, // Conteúdo #51
        amount: -3,
      });

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:debit',
        recipientId: contentList[59].id, // Conteúdo #60
        amount: -1,
      });

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}?strategy=new`);
      const responseBody = await response.json();

      const responseLinkHeader = parseLinkHeader(response.headers.get('Link'));
      const responseTotalRowsHeader = response.headers.get('X-Pagination-Total-Rows');

      expect.soft(response.status).toBe(200);
      expect(responseTotalRowsHeader).toBe('60');
      expect(responseLinkHeader).toStrictEqual({
        first: {
          page: '1',
          per_page: '30',
          rel: 'first',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}?strategy=new&page=1&per_page=30`,
        },
        next: {
          page: '2',
          per_page: '30',
          rel: 'next',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}?strategy=new&page=2&per_page=30`,
        },
        last: {
          page: '2',
          per_page: '30',
          rel: 'last',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}?strategy=new&page=2&per_page=30`,
        },
      });

      expect(responseBody.length).toBe(30);
      expect(responseBody[0].title).toBe('Conteúdo #60');
      expect(responseBody[1].title).toBe('Conteúdo #59');
      expect(responseBody[2].title).toBe('Conteúdo #58');
      expect(responseBody[15].title).toBe('Conteúdo #45');
      expect(responseBody[27].title).toBe('Conteúdo #33');
      expect(responseBody[28].title).toBe('Conteúdo #32');
      expect(responseBody[29].title).toBe('Conteúdo #31');

      const page2Response = await fetch(responseLinkHeader.next.url);
      const page2ResponseBody = await page2Response.json();

      const page2ResponseLinkHeader = parseLinkHeader(page2Response.headers.get('Link'));
      const page2ResponseTotalRowsHeader = page2Response.headers.get('X-Pagination-Total-Rows');

      expect.soft(page2Response.status).toBe(200);
      expect(page2ResponseTotalRowsHeader).toBe('60');
      expect(page2ResponseLinkHeader).toStrictEqual({
        first: {
          page: '1',
          per_page: '30',
          rel: 'first',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}?strategy=new&page=1&per_page=30`,
        },
        prev: {
          page: '1',
          per_page: '30',
          rel: 'prev',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}?strategy=new&page=1&per_page=30`,
        },
        last: {
          page: '2',
          per_page: '30',
          rel: 'last',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}?strategy=new&page=2&per_page=30`,
        },
      });

      expect(page2ResponseBody.length).toBe(30);
      expect(page2ResponseBody[0].title).toBe('Conteúdo #30');
      expect(page2ResponseBody[1].title).toBe('Conteúdo #29');
      expect(page2ResponseBody[27].title).toBe('Conteúdo #3');
      expect(page2ResponseBody[28].title).toBe('Conteúdo #2');
      expect(page2ResponseBody[29].title).toBe('Conteúdo #1');
    });

    test('"username" existent with 60 contents, default pagination and strategy "relevant"', async () => {
      const defaultUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const numberOfContents = 60;
      const contentList = [];

      for (let item = 0; item < numberOfContents; item++) {
        const contentCreated = await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: `Conteúdo #${item + 1}`,
          status: 'published',
        });

        contentList.push(contentCreated);
      }

      const secondUserRootContent = await orchestrator.createContent({
        owner_id: secondUser.id,
        title: 'Conteúdo de outro usuário',
        status: 'published',
      });

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:credit',
        recipientId: secondUserRootContent.id, // Conteúdo de outro usuário
        amount: 22,
      });

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:credit',
        recipientId: contentList[30].id, // Conteúdo #31
        amount: 12,
      });

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:credit',
        recipientId: contentList[35].id, // Conteúdo #36
        amount: 7,
      });

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:debit',
        recipientId: contentList[49].id, // Conteúdo #50
        amount: -2,
      });

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:debit',
        recipientId: contentList[50].id, // Conteúdo #51
        amount: -3,
      });

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:debit',
        recipientId: contentList[59].id, // Conteúdo #60
        amount: -1,
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}?strategy=relevant`,
      );
      const responseBody = await response.json();

      const responseLinkHeader = parseLinkHeader(response.headers.get('Link'));
      const responseTotalRowsHeader = response.headers.get('X-Pagination-Total-Rows');

      expect.soft(response.status).toBe(200);
      expect(responseTotalRowsHeader).toBe('60');
      expect(responseLinkHeader).toStrictEqual({
        first: {
          page: '1',
          per_page: '30',
          rel: 'first',
          strategy: 'relevant',
          url: `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}?strategy=relevant&page=1&per_page=30`,
        },
        next: {
          page: '2',
          per_page: '30',
          rel: 'next',
          strategy: 'relevant',
          url: `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}?strategy=relevant&page=2&per_page=30`,
        },
        last: {
          page: '2',
          per_page: '30',
          rel: 'last',
          strategy: 'relevant',
          url: `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}?strategy=relevant&page=2&per_page=30`,
        },
      });

      expect(responseBody.length).toBe(30);
      expect(responseBody[0].title).toBe('Conteúdo #31');
      expect(responseBody[1].title).toBe('Conteúdo #36');
      expect(responseBody[2].title).toBe('Conteúdo #59');
      expect(responseBody[3].title).toBe('Conteúdo #58');
      expect(responseBody[6].title).toBe('Conteúdo #55');
      expect(responseBody[26].title).toBe('Conteúdo #32');
      expect(responseBody[27].title).toBe('Conteúdo #60');
      expect(responseBody[28].title).toBe('Conteúdo #50');
      expect(responseBody[29].title).toBe('Conteúdo #51');

      const page2Response = await fetch(responseLinkHeader.next.url);
      const page2ResponseBody = await page2Response.json();

      const page2ResponseLinkHeader = parseLinkHeader(page2Response.headers.get('Link'));
      const page2ResponseTotalRowsHeader = page2Response.headers.get('X-Pagination-Total-Rows');

      expect.soft(page2Response.status).toBe(200);
      expect(page2ResponseTotalRowsHeader).toBe('60');
      expect(page2ResponseLinkHeader).toStrictEqual({
        first: {
          page: '1',
          per_page: '30',
          rel: 'first',
          strategy: 'relevant',
          url: `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}?strategy=relevant&page=1&per_page=30`,
        },
        prev: {
          page: '1',
          per_page: '30',
          rel: 'prev',
          strategy: 'relevant',
          url: `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}?strategy=relevant&page=1&per_page=30`,
        },
        last: {
          page: '2',
          per_page: '30',
          rel: 'last',
          strategy: 'relevant',
          url: `${orchestrator.webserverUrl}/api/v1/contents/${defaultUser.username}?strategy=relevant&page=2&per_page=30`,
        },
      });

      expect(page2ResponseBody.length).toBe(30);
      expect(page2ResponseBody[0].title).toBe('Conteúdo #30');
      expect(page2ResponseBody[1].title).toBe('Conteúdo #29');
      expect(page2ResponseBody[27].title).toBe('Conteúdo #3');
      expect(page2ResponseBody[28].title).toBe('Conteúdo #2');
      expect(page2ResponseBody[29].title).toBe('Conteúdo #1');
    });

    test('"username" existent with 4 contents, but only 2 "root" "published" and with_children "false"', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const firstRootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Primeiro conteúdo criado',
        status: 'published',
      });

      const secondRootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Segundo conteúdo criado',
        status: 'published',
      });

      await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Terceiro conteúdo criado',
        body: `Este conteúdo não deverá aparecer na lista retornada pelo /contents/[username],
               porque quando um conteúdo possui o "status" como "draft", ele não
               esta pronto para ser listado publicamente.`,
        status: 'draft',
      });

      await orchestrator.createContent({
        owner_id: firstUser.id,
        parent_id: firstRootContent.id,
        title: 'Quarto conteúdo criado',
        body: `Este conteúdo não deverá aparecer na lista retornada pelo /contents/[username],
               porque o parâmetro "with_children" foi passado como "false".`,
        status: 'published',
      });

      await orchestrator.createContent({
        owner_id: secondUser.id,
        title: 'Conteúdo de outro usuário',
        status: 'published',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}?strategy=new&with_children=false`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual([
        {
          id: secondRootContent.id,
          owner_id: firstUser.id,
          parent_id: null,
          slug: 'segundo-conteudo-criado',
          title: 'Segundo conteúdo criado',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: secondRootContent.created_at.toISOString(),
          updated_at: secondRootContent.updated_at.toISOString(),
          published_at: secondRootContent.published_at.toISOString(),
          deleted_at: null,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: firstUser.username,
          children_deep_count: 0,
        },
        {
          id: firstRootContent.id,
          owner_id: firstUser.id,
          parent_id: null,
          slug: 'primeiro-conteudo-criado',
          title: 'Primeiro conteúdo criado',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: firstRootContent.created_at.toISOString(),
          updated_at: firstRootContent.updated_at.toISOString(),
          published_at: firstRootContent.published_at.toISOString(),
          deleted_at: null,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: firstUser.username,
          children_deep_count: 1,
        },
      ]);

      expect(uuidVersion(responseBody[0].id)).toBe(4);
      expect(uuidVersion(responseBody[1].id)).toBe(4);
      expect(uuidVersion(responseBody[0].owner_id)).toBe(4);
      expect(uuidVersion(responseBody[1].owner_id)).toBe(4);
      expect(responseBody[0].published_at > responseBody[1].published_at).toBe(true);

      const responseLinkHeader = parseLinkHeader(response.headers.get('Link'));
      expect(responseLinkHeader.first.url).toBe(
        `${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}?strategy=new&with_children=false&page=1&per_page=30`,
      );
      expect(responseLinkHeader.last.url).toBe(
        `${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}?strategy=new&with_children=false&page=1&per_page=30`,
      );
    });

    test('"username" existent with 5 contents, but only 2 "root" "published", and with_root "false"', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();

      const firstRootContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Primeiro conteúdo criado',
        body: `Este conteúdo não deverá aparecer na lista retornada pelo /contents/[username],
               porque o parâmetro "with_root" foi passado como "false".`,
        status: 'published',
      });

      await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Segundo conteúdo criado',
        body: `Este conteúdo não deverá aparecer na lista retornada pelo /contents/[username],
               porque o parâmetro "with_root" foi passado como "false".`,
        status: 'published',
      });

      await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Terceiro conteúdo criado',
        body: `Este conteúdo não deverá aparecer na lista retornada pelo /contents/[username],
               porque quando um conteúdo possui o "status" como "draft", ele não
               esta pronto para ser listado publicamente.`,
        status: 'draft',
      });

      const firstChildContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        parent_id: firstRootContent.id,
        title: 'Quarto conteúdo criado',
        body: `Este conteúdo deverá aparecer na lista retornada pelo /contents/[username]`,
        status: 'published',
      });

      const secondChildContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        parent_id: firstRootContent.id,
        title: 'Quinto conteúdo criado',
        body: `Este conteúdo deverá aparecer na lista retornada pelo /contents/[username]`,
        status: 'published',
      });

      await orchestrator.createContent({
        owner_id: secondUser.id,
        title: 'Conteúdo de outro usuário',
        status: 'published',
      });

      const response = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}?strategy=new&with_root=false`,
      );
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual([
        {
          id: secondChildContent.id,
          owner_id: firstUser.id,
          parent_id: firstRootContent.id,
          slug: 'quinto-conteudo-criado',
          title: 'Quinto conteúdo criado',
          body: 'Este conteúdo deverá aparecer na lista retornada pelo /contents/[username]',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: secondChildContent.created_at.toISOString(),
          updated_at: secondChildContent.updated_at.toISOString(),
          published_at: secondChildContent.published_at.toISOString(),
          deleted_at: null,
          owner_username: firstUser.username,
          tabcoins: 0,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          children_deep_count: 0,
        },
        {
          id: firstChildContent.id,
          owner_id: firstUser.id,
          parent_id: firstRootContent.id,
          slug: 'quarto-conteudo-criado',
          title: 'Quarto conteúdo criado',
          body: 'Este conteúdo deverá aparecer na lista retornada pelo /contents/[username]',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: firstChildContent.created_at.toISOString(),
          updated_at: firstChildContent.updated_at.toISOString(),
          published_at: firstChildContent.published_at.toISOString(),
          deleted_at: null,
          owner_username: firstUser.username,
          tabcoins: 0,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          children_deep_count: 0,
        },
      ]);

      expect(uuidVersion(responseBody[0].id)).toBe(4);
      expect(uuidVersion(responseBody[1].id)).toBe(4);
      expect(uuidVersion(responseBody[0].owner_id)).toBe(4);
      expect(uuidVersion(responseBody[1].owner_id)).toBe(4);
      expect(responseBody[0].published_at > responseBody[1].published_at).toBe(true);

      const responseLinkHeader = parseLinkHeader(response.headers.get('Link'));
      expect(responseLinkHeader.first.url).toBe(
        `${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}?strategy=new&with_root=false&page=1&per_page=30`,
      );
      expect(responseLinkHeader.last.url).toBe(
        `${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}?strategy=new&with_root=false&page=1&per_page=30`,
      );
    });

    test('"username" existent with "ad" content', async () => {
      const firstUser = await orchestrator.createUser();

      await orchestrator.createBalance({
        balanceType: 'user:tabcash',
        recipientId: firstUser.id,
        amount: defaultTabCashForAdCreation,
      });

      const adContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Ad Content',
        body: relevantBody,
        status: 'published',
        type: 'ad',
      });

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}`);
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual([
        {
          id: adContent.id,
          owner_id: firstUser.id,
          parent_id: null,
          slug: 'ad-content',
          title: 'Ad Content',
          status: 'published',
          type: 'ad',
          source_url: null,
          created_at: adContent.created_at.toISOString(),
          updated_at: adContent.updated_at.toISOString(),
          published_at: adContent.published_at.toISOString(),
          deleted_at: null,
          owner_username: firstUser.username,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          children_deep_count: 0,
        },
      ]);

      const responseLinkHeader = parseLinkHeader(response.headers.get('Link'));
      expect(responseLinkHeader.first.url).toBe(
        `${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}?strategy=relevant&page=1&per_page=30`,
      );
      expect(responseLinkHeader.last.url).toBe(
        `${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}?strategy=relevant&page=1&per_page=30`,
      );
    });
  });
});
</file>

<file path="tests/integration/api/v1/contents/rss/get.test.js">
import { defaultTabCashForAdCreation, relevantBody } from 'tests/constants-for-tests';
import orchestrator from 'tests/orchestrator.js';

describe('GET /recentes/rss', () => {
  beforeAll(async () => {
    await orchestrator.waitForAllServices();
    await orchestrator.dropAllTables();
    await orchestrator.runPendingMigrations();
  });

  describe('Anonymous user', () => {
    test('With `/rss` alias`', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/rss`);
      expect.soft(response.status).toBe(200);
    });

    test('With `/rss.xml` alias`', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/rss.xml`);
      expect.soft(response.status).toBe(200);
    });

    test('With 0 contents', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/recentes/rss`);
      const responseBody = await response.text();

      const lastBuildDateFromResponseBody = /<lastBuildDate>(.*?)<\/lastBuildDate>/.exec(responseBody)[1];

      expect.soft(response.status).toBe(200);

      expect(responseBody).toBe(`<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>TabNews</title>
        <link>${orchestrator.webserverUrl}/recentes/rss</link>
        <description>Conteúdos para quem trabalha com Programação e Tecnologia</description>
        <lastBuildDate>${lastBuildDateFromResponseBody}</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>pt</language>
        <image>
            <title>TabNews</title>
            <url>${orchestrator.webserverUrl}/favicon-mobile.png</url>
            <link>${orchestrator.webserverUrl}/recentes/rss</link>
        </image>
    </channel>
</rss>`);
    });

    test('With 1 "ad" content`', async () => {
      const defaultUser = await orchestrator.createUser();

      await orchestrator.createBalance({
        balanceType: 'user:tabcash',
        recipientId: defaultUser.id,
        amount: defaultTabCashForAdCreation,
      });

      await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Ad Title',
        body: relevantBody,
        status: 'published',
        type: 'ad',
      });

      const response = await fetch(`${orchestrator.webserverUrl}/recentes/rss`);
      const responseBody = await response.text();

      const lastBuildDateFromResponseBody = /<lastBuildDate>(.*?)<\/lastBuildDate>/.exec(responseBody)[1];

      expect.soft(response.status).toBe(200);

      expect(responseBody).toBe(`<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>TabNews</title>
        <link>${orchestrator.webserverUrl}/recentes/rss</link>
        <description>Conteúdos para quem trabalha com Programação e Tecnologia</description>
        <lastBuildDate>${lastBuildDateFromResponseBody}</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>pt</language>
        <image>
            <title>TabNews</title>
            <url>${orchestrator.webserverUrl}/favicon-mobile.png</url>
            <link>${orchestrator.webserverUrl}/recentes/rss</link>
        </image>
    </channel>
</rss>`);
    });

    test('With 3 contents, 2 `published` and 1 with `draft` status', async () => {
      const defaultUser = await orchestrator.createUser();

      const firstRootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Conteúdo #1 (mais antigo)',
        status: 'published',
        body: `# Corpo com HTML

É **importante** lidar corretamente com o \`HTML\`, incluindo estilos ~~especiais~~ do \`GFM\`.`,
      });

      const secondRootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Conteúdo #2 (mais novo)',
        body: 'Este é um corpo bastante longo, vamos ver como que a propriedade description irá reagir, pois por padrão ela deverá cortar após um número X de caracteres. Não vou tomar nota aqui da quantidade exata de caracteres, pois isso pode mudar ao longo do tempo.',
        status: 'published',
      });

      // thirdRootContent
      await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Conteúdo #3 (mais novo, mas no status "draft")',
        body: `Este conteúdo não deverá aparecer na lista retornada pelo rss,
               porque quando um conteúdo possui o "status" como "draft", ele não
               esta pronto para ser listado publicamente.`,
        status: 'draft',
      });

      const response = await fetch(`${orchestrator.webserverUrl}/rss`);
      const responseBody = await response.text();

      expect.soft(response.status).toBe(200);
      expect(responseBody).toBe(`<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>TabNews</title>
        <link>${orchestrator.webserverUrl}/recentes/rss</link>
        <description>Conteúdos para quem trabalha com Programação e Tecnologia</description>
        <lastBuildDate>${new Date(secondRootContent.updated_at).toUTCString()}</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>pt</language>
        <image>
            <title>TabNews</title>
            <url>${orchestrator.webserverUrl}/favicon-mobile.png</url>
            <link>${orchestrator.webserverUrl}/recentes/rss</link>
        </image>
        <item>
            <title><![CDATA[Conteúdo #2 (mais novo)]]></title>
            <link>${orchestrator.webserverUrl}/${secondRootContent.owner_username}/${secondRootContent.slug}</link>
            <guid>${orchestrator.webserverUrl}/${secondRootContent.owner_username}/${secondRootContent.slug}</guid>
            <pubDate>${new Date(secondRootContent.published_at).toUTCString()}</pubDate>
            <description><![CDATA[Este é um corpo bastante longo, vamos ver como que a propriedade description irá reagir, pois por padrão ela deverá cortar após um número X de caracteres. Não vou tomar nota aqui da quant...]]></description>
            <content:encoded><![CDATA[<div class="markdown-body"><p>Este é um corpo bastante longo, vamos ver como que a propriedade description irá reagir, pois por padrão ela deverá cortar após um número X de caracteres. Não vou tomar nota aqui da quantidade exata de caracteres, pois isso pode mudar ao longo do tempo.</p></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Conteúdo #1 (mais antigo)]]></title>
            <link>${orchestrator.webserverUrl}/${firstRootContent.owner_username}/${firstRootContent.slug}</link>
            <guid>${orchestrator.webserverUrl}/${firstRootContent.owner_username}/${firstRootContent.slug}</guid>
            <pubDate>${new Date(firstRootContent.published_at).toUTCString()}</pubDate>
            <description><![CDATA[Corpo com HTML É importante lidar corretamente com o HTML, incluindo estilos especiais do GFM.]]></description>
            <content:encoded><![CDATA[<div class="markdown-body"><h1 id="${defaultUser.username.toLowerCase()}-content-corpo-com-html">Corpo com HTML</h1><p>É <strong>importante</strong> lidar corretamente com o <code>HTML</code>, incluindo estilos <del>especiais</del> do <code>GFM</code>.</p></div>]]></content:encoded>
        </item>
    </channel>
</rss>`);
    });
  });
});
</file>

<file path="tests/integration/api/v1/contents/firewall.post.test.js">
import { version as uuidVersion } from 'uuid';

import content from 'models/content.js';
import user from 'models/user';
import orchestrator from 'tests/orchestrator.js';
import RequestBuilder from 'tests/request-builder';

beforeEach(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
  await orchestrator.createFirewallTestFunctions();
  await orchestrator.deleteAllEmails();
});

describe('POST /api/v1/contents [FIREWALL]', () => {
  async function createContentViaApi(contentsRequestBuilder, body) {
    return await contentsRequestBuilder.post({
      title: body?.title ?? `New content - ${new Date().getTime()}`,
      body: 'body',
      status: 'published',
      parent_id: body?.parent_id,
    });
  }

  describe('Default user', () => {
    describe('Root content', () => {
      test('Spamming valid "root" contents', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const defaultUser = await contentsRequestBuilder.buildUser();

        const { response: response1, responseBody: response1Body } = await createContentViaApi(contentsRequestBuilder);
        const { response: response2, responseBody: response2Body } = await createContentViaApi(contentsRequestBuilder);
        const { response: response3, responseBody: response3Body } = await createContentViaApi(contentsRequestBuilder, {
          title: 'Título 3',
        });

        expect.soft(response1.status).toBe(201);
        expect.soft(response2.status).toBe(201);
        expect.soft(response3.status).toBe(429);

        expect(response3Body).toStrictEqual({
          name: 'TooManyRequestsError',
          message:
            'Identificamos a criação de muitas publicações em um curto período, então publicações criadas recentemente podem ter sido removidas.',
          action: 'Tente novamente mais tarde ou contate o suporte caso acredite que isso seja um erro.',
          status_code: 429,
          error_id: response3Body.error_id,
          request_id: response3Body.request_id,
        });

        const content1 = await content.findOne({
          where: {
            id: response1Body.id,
          },
        });

        const content2 = await content.findOne({
          where: {
            id: response2Body.id,
          },
        });

        const content3 = await content.findOne({
          where: {
            slug: 'titulo-3',
          },
        });

        expect(content1.status).toBe('firewall');
        expect(content1.deleted_at).toBeNull();
        expect(Date.parse(content1.updated_at)).not.toBeNaN();
        expect(content1.updated_at.toISOString()).toBe(response1Body.updated_at);

        expect(content2.status).toBe('firewall');
        expect(content2.deleted_at).toBeNull();
        expect(Date.parse(content2.updated_at)).not.toBeNaN();
        expect(content2.updated_at.toISOString()).toBe(response2Body.updated_at);

        expect(content3).toBeUndefined();

        const lastEvent = await orchestrator.getLastEvent();

        expect(lastEvent).toStrictEqual({
          id: lastEvent.id,
          type: 'firewall:block_contents:text_root',
          originator_user_id: defaultUser.id,
          originator_ip: '127.0.0.1',
          metadata: {
            from_rule: 'create:content:text_root',
            contents: [content1.id, content2.id],
          },
          created_at: lastEvent.created_at,
        });
        expect(uuidVersion(lastEvent.id)).toBe(4);
        expect(Date.parse(lastEvent.created_at)).not.toBeNaN();

        expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);
      });

      test('Spamming valid "root" contents with a content deleted', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const defaultUser = await contentsRequestBuilder.buildUser();

        const { response: response1, responseBody: response1Body } = await createContentViaApi(contentsRequestBuilder);
        const { response: response2, responseBody: response2Body } = await createContentViaApi(contentsRequestBuilder);

        expect.soft(response1.status).toBe(201);
        expect.soft(response2.status).toBe(201);

        const content2BeforeFirewall = await orchestrator.updateContent(response2Body.id, {
          status: 'deleted',
        });

        const { response: response3, responseBody: response3Body } = await createContentViaApi(contentsRequestBuilder, {
          title: 'Título 3',
        });

        expect.soft(response3.status).toBe(429);

        expect(response3Body).toStrictEqual({
          name: 'TooManyRequestsError',
          message:
            'Identificamos a criação de muitas publicações em um curto período, então publicações criadas recentemente podem ter sido removidas.',
          action: 'Tente novamente mais tarde ou contate o suporte caso acredite que isso seja um erro.',
          status_code: 429,
          error_id: response3Body.error_id,
          request_id: response3Body.request_id,
        });

        const content1 = await content.findOne({
          where: {
            id: response1Body.id,
          },
        });

        const content2 = await content.findOne({
          where: {
            id: response2Body.id,
          },
        });

        const content3 = await content.findOne({
          where: {
            slug: 'titulo-3',
          },
        });

        expect(content1.status).toBe('firewall');
        expect(content2.status).toBe('firewall');
        expect(content1.deleted_at).toBeNull();
        expect(content2.deleted_at).toStrictEqual(content2BeforeFirewall.deleted_at);
        expect(content2.deleted_at).not.toBeNull();
        expect(content3).toBeUndefined();

        const lastEvent = await orchestrator.getLastEvent();

        expect(lastEvent).toStrictEqual({
          id: lastEvent.id,
          type: 'firewall:block_contents:text_root',
          originator_user_id: defaultUser.id,
          originator_ip: '127.0.0.1',
          metadata: {
            from_rule: 'create:content:text_root',
            contents: [content1.id, content2.id],
          },
          created_at: lastEvent.created_at,
        });
        expect(uuidVersion(lastEvent.id)).toBe(4);
        expect(Date.parse(lastEvent.created_at)).not.toBeNaN();

        expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);
      });

      test('Spamming valid "root" contents with TabCoins earnings', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const defaultUser = await contentsRequestBuilder.buildUser();

        const { response: response1, responseBody: response1Body } = await createContentViaApi(contentsRequestBuilder);
        const { response: response2, responseBody: response2Body } = await createContentViaApi(contentsRequestBuilder);

        expect.soft(response1.status).toBe(201);
        expect.soft(response2.status).toBe(201);

        await orchestrator.createRate(response1Body, 10);
        const content1BeforeFirewall = await orchestrator.updateContent(response1Body.id, { status: 'deleted' });

        await orchestrator.createRate(response2Body, -3);
        await orchestrator.createRate(response2Body, 5);

        const userAfterRates = await user.findOneById(defaultUser.id, { withBalance: true });
        expect(userAfterRates.tabcoins).toBe(2);

        const { response: response3, responseBody: response3Body } = await createContentViaApi(contentsRequestBuilder, {
          title: 'Título 3',
        });

        expect.soft(response3.status).toBe(429);

        expect(response3Body).toStrictEqual({
          name: 'TooManyRequestsError',
          message:
            'Identificamos a criação de muitas publicações em um curto período, então publicações criadas recentemente podem ter sido removidas.',
          action: 'Tente novamente mais tarde ou contate o suporte caso acredite que isso seja um erro.',
          status_code: 429,
          error_id: response3Body.error_id,
          request_id: response3Body.request_id,
        });

        const content1 = await content.findOne({ where: { id: response1Body.id } });
        const content2 = await content.findOne({ where: { id: response2Body.id } });
        const content3 = await content.findOne({ where: { slug: 'titulo-3' } });

        expect(content1.status).toBe('firewall');
        expect(Date.parse(content1.deleted_at)).not.toBeNaN();
        expect(content1.deleted_at.toISOString()).toBe(content1BeforeFirewall.deleted_at.toISOString());
        expect(Date.parse(content1.updated_at)).not.toBeNaN();
        expect(content1.updated_at.toISOString()).toBe(content1BeforeFirewall.updated_at.toISOString());

        expect(content2.status).toBe('firewall');
        expect(content2.deleted_at).toBeNull();
        expect(Date.parse(content2.updated_at)).not.toBeNaN();
        expect(content2.updated_at.toISOString()).toBe(response2Body.updated_at);

        expect(content3).toBeUndefined();

        const lastEvent = await orchestrator.getLastEvent();

        expect(lastEvent).toStrictEqual({
          id: lastEvent.id,
          type: 'firewall:block_contents:text_root',
          originator_user_id: defaultUser.id,
          originator_ip: '127.0.0.1',
          metadata: {
            from_rule: 'create:content:text_root',
            contents: [content1.id, content2.id],
          },
          created_at: lastEvent.created_at,
        });
        expect(uuidVersion(lastEvent.id)).toBe(4);
        expect(Date.parse(lastEvent.created_at)).not.toBeNaN();

        const userAfterFirewallCatch = await user.findOneById(defaultUser.id, { withBalance: true });
        expect(userAfterFirewallCatch.tabcoins).toBe(0);

        expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);
      });

      test('Different users spamming valid "root" contents with TabCoins earnings', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');

        const user1 = await contentsRequestBuilder.buildUser();
        const { response: response1, responseBody: response1Body } = await createContentViaApi(contentsRequestBuilder);

        const user2 = await contentsRequestBuilder.buildUser();
        const { response: response2, responseBody: response2Body } = await createContentViaApi(contentsRequestBuilder);

        expect.soft(response1.status).toBe(201);
        expect.soft(response2.status).toBe(201);

        await orchestrator.createRate(response1Body, 4);
        await orchestrator.createRate(response2Body, 2);

        const user1AfterRates = await user.findOneById(user1.id, { withBalance: true });
        expect(user1AfterRates.tabcoins).toBe(4);

        const user2AfterRates = await user.findOneById(user2.id, { withBalance: true });
        expect(user2AfterRates.tabcoins).toBe(2);

        const { response: response3, responseBody: response3Body } = await createContentViaApi(contentsRequestBuilder, {
          title: 'Título 3',
        });

        expect.soft(response3.status).toBe(429);

        expect(response3Body).toStrictEqual({
          name: 'TooManyRequestsError',
          message:
            'Identificamos a criação de muitas publicações em um curto período, então publicações criadas recentemente podem ter sido removidas.',
          action: 'Tente novamente mais tarde ou contate o suporte caso acredite que isso seja um erro.',
          status_code: 429,
          error_id: response3Body.error_id,
          request_id: response3Body.request_id,
        });

        const content1 = await content.findOne({ where: { id: response1Body.id } });
        const content2 = await content.findOne({ where: { id: response2Body.id } });
        const content3 = await content.findOne({ where: { slug: 'titulo-3' } });

        expect(content1.status).toBe('firewall');
        expect(content1.deleted_at).toBeNull();
        expect(Date.parse(content1.updated_at)).not.toBeNaN();
        expect(content1.updated_at.toISOString()).toBe(response1Body.updated_at);

        expect(content2.status).toBe('firewall');
        expect(content2.deleted_at).toBeNull();
        expect(Date.parse(content2.updated_at)).not.toBeNaN();
        expect(content2.updated_at.toISOString()).toBe(response2Body.updated_at);

        expect(content3).toBeUndefined();

        const lastEvent = await orchestrator.getLastEvent();

        expect(lastEvent).toStrictEqual({
          id: lastEvent.id,
          type: 'firewall:block_contents:text_root',
          originator_user_id: user2.id,
          originator_ip: '127.0.0.1',
          metadata: {
            from_rule: 'create:content:text_root',
            contents: [content1.id, content2.id],
          },
          created_at: lastEvent.created_at,
        });
        expect(uuidVersion(lastEvent.id)).toBe(4);
        expect(Date.parse(lastEvent.created_at)).not.toBeNaN();

        const user1AfterFirewallCatch = await user.findOneById(user1.id, { withBalance: true });
        expect(user1AfterFirewallCatch.tabcoins).toBe(0);

        const user2AfterFirewallCatch = await user.findOneById(user2.id, { withBalance: true });
        expect(user2AfterFirewallCatch.tabcoins).toBe(0);

        const allEmails = await orchestrator.getEmails();
        const email = allEmails[0];

        expect(allEmails).toHaveLength(1);
        expect(email.recipients).toStrictEqual([`<${user1.email}>`]);
        expect(email.subject).toBe('Um conteúdo seu foi removido');
        expect(email.text).toContain(user1.username);
        expect(email.html).toContain(user1.username);

        const deletedContentText = `Identificamos a criação de muitas publicações em um curto período, então a sua publicação "${response1Body.title}" foi removida.`;
        expect(email.text).toContain(deletedContentText);
        expect(email.html).toContain(deletedContentText.replaceAll('"', '&quot;'));

        expect(email.text).toContain(`Identificador do evento: ${lastEvent.id}`);
        expect(email.html).toContain('Identificador do evento');
        expect(email.html).toContain(lastEvent.id);
      });

      test('Spamming valid "root" contents deleted before the firewall catch', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        await contentsRequestBuilder.buildUser();

        const { response: response1, responseBody: response1Body } = await createContentViaApi(contentsRequestBuilder);
        const { response: response2, responseBody: response2Body } = await createContentViaApi(contentsRequestBuilder);

        expect.soft(response1.status).toBe(201);
        expect.soft(response2.status).toBe(201);

        await orchestrator.updateContent(response1Body.id, { status: 'deleted' });
        await orchestrator.updateContent(response2Body.id, { status: 'deleted' });

        const { response: request3, responseBody: response3Body } = await createContentViaApi(contentsRequestBuilder);

        expect.soft(request3.status).toBe(429);

        expect(response3Body).toStrictEqual({
          name: 'TooManyRequestsError',
          message:
            'Identificamos a criação de muitas publicações em um curto período, então publicações criadas recentemente podem ter sido removidas.',
          action: 'Tente novamente mais tarde ou contate o suporte caso acredite que isso seja um erro.',
          status_code: 429,
          error_id: response3Body.error_id,
          request_id: response3Body.request_id,
        });

        const content1 = await content.findOne({
          where: {
            id: response1Body.id,
          },
        });

        const content2 = await content.findOne({
          where: {
            id: response2Body.id,
          },
        });

        const content3 = await content.findOne({
          where: {
            slug: 'titulo-3',
          },
        });

        expect(content1.status).toBe('firewall');
        expect(content2.status).toBe('firewall');
        expect(content3).toBeUndefined();

        const lastEvent = await orchestrator.getLastEvent();

        expect(lastEvent.metadata).toStrictEqual({
          from_rule: 'create:content:text_root',
          contents: [content1.id, content2.id],
        });
      });
    });

    describe('Child content', () => {
      test('Spamming valid "child" contents', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const defaultUser = await contentsRequestBuilder.buildUser();

        const { responseBody: rootContentBody } = await createContentViaApi(contentsRequestBuilder);

        const { response: response1, responseBody: response1Body } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContentBody.id,
        });
        const { response: response2, responseBody: response2Body } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContentBody.id,
        });
        const { response: response3, responseBody: response3Body } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContentBody.id,
          title: 'Título 3',
        });

        expect.soft(response1.status).toBe(201);
        expect.soft(response2.status).toBe(201);
        expect.soft(response3.status).toBe(429);

        expect(response3Body).toStrictEqual({
          name: 'TooManyRequestsError',
          message:
            'Identificamos a criação de muitos comentários em um curto período, então comentários criados recentemente podem ter sido removidos.',
          action: 'Tente novamente mais tarde ou contate o suporte caso acredite que isso seja um erro.',
          status_code: 429,
          error_id: response3Body.error_id,
          request_id: response3Body.request_id,
        });

        const content1 = await content.findOne({
          where: {
            id: response1Body.id,
          },
        });

        const content2 = await content.findOne({
          where: {
            id: response2Body.id,
          },
        });

        const content3 = await content.findOne({
          where: {
            slug: 'titulo-3',
          },
        });

        expect(content1.status).toBe('firewall');
        expect(content1.deleted_at).toBeNull();
        expect(Date.parse(content1.updated_at)).not.toBeNaN();
        expect(content1.updated_at.toISOString()).toBe(response1Body.updated_at);

        expect(content2.status).toBe('firewall');
        expect(content2.deleted_at).toBeNull();
        expect(Date.parse(content2.updated_at)).not.toBeNaN();
        expect(content2.updated_at.toISOString()).toBe(response2Body.updated_at);

        expect(content3).toBeUndefined();

        const lastEvent = await orchestrator.getLastEvent();

        expect(lastEvent).toStrictEqual({
          id: lastEvent.id,
          type: 'firewall:block_contents:text_child',
          originator_user_id: defaultUser.id,
          originator_ip: '127.0.0.1',
          metadata: {
            from_rule: 'create:content:text_child',
            contents: [content1.id, content2.id],
          },
          created_at: lastEvent.created_at,
        });
        expect(uuidVersion(lastEvent.id)).toBe(4);
        expect(Date.parse(lastEvent.created_at)).not.toBeNaN();

        expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);
      });

      test('Spamming valid "child" contents with a content deleted', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const defaultUser = await contentsRequestBuilder.buildUser();

        const { responseBody: rootContentBody } = await createContentViaApi(contentsRequestBuilder);

        const { response: response1, responseBody: response1Body } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContentBody.id,
        });
        const { response: response2, responseBody: response2Body } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContentBody.id,
        });

        expect.soft(response1.status).toBe(201);
        expect.soft(response2.status).toBe(201);

        const content2BeforeFirewall = await orchestrator.updateContent(response2Body.id, {
          status: 'deleted',
        });

        const { response: response3, responseBody: response3Body } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContentBody.id,
          title: 'Título 3',
        });

        expect.soft(response3.status).toBe(429);

        expect(response3Body).toStrictEqual({
          name: 'TooManyRequestsError',
          message:
            'Identificamos a criação de muitos comentários em um curto período, então comentários criados recentemente podem ter sido removidos.',
          action: 'Tente novamente mais tarde ou contate o suporte caso acredite que isso seja um erro.',
          status_code: 429,
          error_id: response3Body.error_id,
          request_id: response3Body.request_id,
        });

        const content1 = await content.findOne({
          where: {
            id: response1Body.id,
          },
        });

        const content2 = await content.findOne({
          where: {
            id: response2Body.id,
          },
        });

        const content3 = await content.findOne({
          where: {
            slug: 'titulo-3',
          },
        });

        expect(content1.status).toBe('firewall');
        expect(content2.status).toBe('firewall');
        expect(content1.deleted_at).toBeNull();
        expect(content2.deleted_at).toStrictEqual(content2BeforeFirewall.deleted_at);
        expect(content2.deleted_at).not.toBeNull();
        expect(content3).toBeUndefined();

        const lastEvent = await orchestrator.getLastEvent();

        expect(lastEvent).toStrictEqual({
          id: lastEvent.id,
          type: 'firewall:block_contents:text_child',
          originator_user_id: defaultUser.id,
          originator_ip: '127.0.0.1',
          metadata: {
            from_rule: 'create:content:text_child',
            contents: [content1.id, content2.id],
          },
          created_at: lastEvent.created_at,
        });
        expect(uuidVersion(lastEvent.id)).toBe(4);
        expect(Date.parse(lastEvent.created_at)).not.toBeNaN();

        expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);
      });

      test('Spamming valid "child" contents with TabCoins earnings', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const defaultUser = await contentsRequestBuilder.buildUser();

        const { responseBody: rootContentBody } = await createContentViaApi(contentsRequestBuilder);

        const { response: response1, responseBody: response1Body } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContentBody.id,
        });
        const { response: response2, responseBody: response2Body } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContentBody.id,
        });

        expect.soft(response1.status).toBe(201);
        expect.soft(response2.status).toBe(201);

        await orchestrator.createRate(response1Body, 2);
        const content1BeforeFirewall = await orchestrator.updateContent(response1Body.id, {
          status: 'deleted',
        });

        await orchestrator.createRate(response2Body, 10);
        await orchestrator.createRate(response2Body, -4);

        const userAfterRates = await user.findOneById(defaultUser.id, { withBalance: true });
        expect(userAfterRates.tabcoins).toBe(6);

        const { response: response3, responseBody: response3Body } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContentBody.id,
          title: 'Título 3',
        });

        expect.soft(response3.status).toBe(429);

        expect(response3Body).toStrictEqual({
          name: 'TooManyRequestsError',
          message:
            'Identificamos a criação de muitos comentários em um curto período, então comentários criados recentemente podem ter sido removidos.',
          action: 'Tente novamente mais tarde ou contate o suporte caso acredite que isso seja um erro.',
          status_code: 429,
          error_id: response3Body.error_id,
          request_id: response3Body.request_id,
        });

        const content1 = await content.findOne({ where: { id: response1Body.id } });
        const content2 = await content.findOne({ where: { id: response2Body.id } });
        const content3 = await content.findOne({ where: { slug: 'titulo-3' } });

        expect(content1.status).toBe('firewall');
        expect(Date.parse(content1.deleted_at)).not.toBeNaN();
        expect(content1.deleted_at.toISOString()).toBe(content1BeforeFirewall.deleted_at.toISOString());
        expect(Date.parse(content1.updated_at)).not.toBeNaN();
        expect(content1.updated_at.toISOString()).toBe(content1BeforeFirewall.updated_at.toISOString());

        expect(content2.status).toBe('firewall');
        expect(content2.deleted_at).toBeNull();
        expect(Date.parse(content2.updated_at)).not.toBeNaN();
        expect(content2.updated_at.toISOString()).toBe(response2Body.updated_at);

        expect(content3).toBeUndefined();

        const lastEvent = await orchestrator.getLastEvent();

        expect(lastEvent).toStrictEqual({
          id: lastEvent.id,
          type: 'firewall:block_contents:text_child',
          originator_user_id: defaultUser.id,
          originator_ip: '127.0.0.1',
          metadata: {
            from_rule: 'create:content:text_child',
            contents: [content1.id, content2.id],
          },
          created_at: lastEvent.created_at,
        });
        expect(uuidVersion(lastEvent.id)).toBe(4);
        expect(Date.parse(lastEvent.created_at)).not.toBeNaN();

        const userAfterFirewallCatch = await user.findOneById(defaultUser.id, { withBalance: true });
        expect(userAfterFirewallCatch.tabcoins).toBe(0);

        expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);
      });

      test('Spamming valid "child" contents with one with negative TabCoins', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const defaultUser = await contentsRequestBuilder.buildUser();

        const { responseBody: rootContentBody } = await createContentViaApi(contentsRequestBuilder);

        const { response: response1, responseBody: response1Body } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContentBody.id,
        });
        const { response: response2, responseBody: response2Body } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContentBody.id,
        });

        expect.soft(response1.status).toBe(201);
        expect.soft(response2.status).toBe(201);

        await orchestrator.createRate(response1Body, 1);
        await orchestrator.createRate(response1Body, -5);
        await orchestrator.createRate(response2Body, 3);

        const userAfterRates = await user.findOneById(defaultUser.id, { withBalance: true });
        expect(userAfterRates.tabcoins).toBe(-1);

        const { response: response3, responseBody: response3Body } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContentBody.id,
          title: 'Título 3',
        });

        expect.soft(response3.status).toBe(429);

        expect(response3Body).toStrictEqual({
          name: 'TooManyRequestsError',
          message:
            'Identificamos a criação de muitos comentários em um curto período, então comentários criados recentemente podem ter sido removidos.',
          action: 'Tente novamente mais tarde ou contate o suporte caso acredite que isso seja um erro.',
          status_code: 429,
          error_id: response3Body.error_id,
          request_id: response3Body.request_id,
        });

        const content1 = await content.findOne({ where: { id: response1Body.id } });
        const content2 = await content.findOne({ where: { id: response2Body.id } });
        const content3 = await content.findOne({ where: { slug: 'titulo-3' } });

        expect(content1.status).toBe('firewall');
        expect(content2.status).toBe('firewall');
        expect(content3).toBeUndefined();

        const lastEvent = await orchestrator.getLastEvent();

        expect(lastEvent).toStrictEqual({
          id: lastEvent.id,
          type: 'firewall:block_contents:text_child',
          originator_user_id: defaultUser.id,
          originator_ip: '127.0.0.1',
          metadata: {
            from_rule: 'create:content:text_child',
            contents: [content1.id, content2.id],
          },
          created_at: lastEvent.created_at,
        });
        expect(uuidVersion(lastEvent.id)).toBe(4);
        expect(Date.parse(lastEvent.created_at)).not.toBeNaN();

        const userAfterFirewallCatch = await user.findOneById(defaultUser.id, { withBalance: true });
        expect(userAfterFirewallCatch.tabcoins).toBe(-4);
      });

      test('Different users spamming valid "child" contents with TabCoins earnings', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');

        const userRootContent = await contentsRequestBuilder.buildUser();
        const { responseBody: rootContentBody } = await createContentViaApi(contentsRequestBuilder);

        await user.update(userRootContent, { notifications: false });

        const user1 = await contentsRequestBuilder.buildUser();
        const { response: response1, responseBody: response1Body } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContentBody.id,
        });

        const user2 = await contentsRequestBuilder.buildUser();
        const { response: response2, responseBody: response2Body } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContentBody.id,
        });

        expect.soft(response1.status).toBe(201);
        expect.soft(response2.status).toBe(201);

        await orchestrator.createRate(response1Body, 2);
        await orchestrator.createRate(response2Body, 1);

        const user1AfterRates = await user.findOneById(user1.id, { withBalance: true });
        expect(user1AfterRates.tabcoins).toBe(2);

        const user2AfterRates = await user.findOneById(user2.id, { withBalance: true });
        expect(user2AfterRates.tabcoins).toBe(1);

        const user3 = await contentsRequestBuilder.buildUser();
        const { response: response3, responseBody: response3Body } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContentBody.id,
          title: 'Título 3',
        });

        expect.soft(response3.status).toBe(429);

        expect(response3Body).toStrictEqual({
          name: 'TooManyRequestsError',
          message:
            'Identificamos a criação de muitos comentários em um curto período, então comentários criados recentemente podem ter sido removidos.',
          action: 'Tente novamente mais tarde ou contate o suporte caso acredite que isso seja um erro.',
          status_code: 429,
          error_id: response3Body.error_id,
          request_id: response3Body.request_id,
        });

        const content1 = await content.findOne({ where: { id: response1Body.id } });
        const content2 = await content.findOne({ where: { id: response2Body.id } });
        const content3 = await content.findOne({ where: { slug: 'titulo-3' } });

        expect(content1.status).toBe('firewall');
        expect(content1.deleted_at).toBeNull();
        expect(Date.parse(content1.updated_at)).not.toBeNaN();
        expect(content1.updated_at.toISOString()).toBe(response1Body.updated_at);

        expect(content2.status).toBe('firewall');
        expect(content2.deleted_at).toBeNull();
        expect(Date.parse(content2.updated_at)).not.toBeNaN();
        expect(content2.updated_at.toISOString()).toBe(response2Body.updated_at);

        expect(content3).toBeUndefined();

        const lastEvent = await orchestrator.getLastEvent();

        expect(lastEvent).toStrictEqual({
          id: lastEvent.id,
          type: 'firewall:block_contents:text_child',
          originator_user_id: user3.id,
          originator_ip: '127.0.0.1',
          metadata: {
            from_rule: 'create:content:text_child',
            contents: [content1.id, content2.id],
          },
          created_at: lastEvent.created_at,
        });
        expect(uuidVersion(lastEvent.id)).toBe(4);
        expect(Date.parse(lastEvent.created_at)).not.toBeNaN();

        const user1AfterFirewallCatch = await user.findOneById(user1.id, {
          withBalance: true,
        });
        expect(user1AfterFirewallCatch.tabcoins).toBe(0);

        const user2AfterFirewallCatch = await user.findOneById(user2.id, {
          withBalance: true,
        });
        expect(user2AfterFirewallCatch.tabcoins).toBe(0);

        const allEmails = await orchestrator.getEmails(2);
        expect(allEmails).toHaveLength(2);

        const user1Email = allEmails.find((email) => email.recipients.includes(`<${user1.email}>`));
        const user2Email = allEmails.find((email) => email.recipients.includes(`<${user2.email}>`));

        expect(user1Email.recipients).toStrictEqual([`<${user1.email}>`]);
        expect(user2Email.recipients).toStrictEqual([`<${user2.email}>`]);

        expect(user1Email.subject).toBe('Um conteúdo seu foi removido');
        expect(user2Email.subject).toBe('Um conteúdo seu foi removido');

        expect(user1Email.text).toContain(user1.username);
        expect(user1Email.html).toContain(user1.username);
        expect(user2Email.text).toContain(user2.username);
        expect(user2Email.html).toContain(user2.username);

        const user1DeletedContentText = `Identificamos a criação de muitos comentários em um curto período, então o seu comentário de ID "${content1.id}" foi removido.`;
        expect(user1Email.text).toContain(user1DeletedContentText);
        expect(user1Email.html).toContain(user1DeletedContentText.replaceAll('"', '&quot;'));

        const user2DeletedContentText = `Identificamos a criação de muitos comentários em um curto período, então o seu comentário de ID "${content2.id}" foi removido.`;
        expect(user2Email.text).toContain(user2DeletedContentText);
        expect(user2Email.html).toContain(user2DeletedContentText.replaceAll('"', '&quot;'));

        expect(user1Email.text).toContain(`Identificador do evento: ${lastEvent.id}`);
        expect(user1Email.html).toContain('Identificador do evento');
        expect(user1Email.html).toContain(lastEvent.id);
        expect(user2Email.text).toContain(`Identificador do evento: ${lastEvent.id}`);
        expect(user2Email.html).toContain('Identificador do evento');
        expect(user2Email.html).toContain(lastEvent.id);
      });
    });
  });
});
</file>

<file path="tests/integration/api/v1/contents/get.test.js">
import parseLinkHeader from 'parse-link-header';
import { version as uuidVersion } from 'uuid';

import { defaultTabCashForAdCreation, relevantBody } from 'tests/constants-for-tests';
import orchestrator from 'tests/orchestrator.js';
import RequestBuilder from 'tests/request-builder';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
});

describe('GET /api/v1/contents', () => {
  const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');

  describe('Anonymous user (dropAllTables beforeEach)', () => {
    beforeEach(async () => {
      await orchestrator.dropAllTables();
      await orchestrator.runPendingMigrations();
    });

    test('With CORS and Security Headers enabled', async () => {
      const { response } = await contentsRequestBuilder.get();

      const responseHeaders = {};

      response.headers.forEach((value, key) => {
        responseHeaders[key] = [value];
      });

      const expectedHeaders = {
        'x-dns-prefetch-control': ['on'],
        'strict-transport-security': ['max-age=63072000; includeSubDomains; preload'],
        'x-xss-protection': ['1; mode=block'],
        'x-frame-options': ['SAMEORIGIN'],
        'permissions-policy': ['camera=(), microphone=(), geolocation=()'],
        'x-content-type-options': ['nosniff'],
        'referrer-policy': ['origin-when-cross-origin'],
        'access-control-allow-credentials': ['true'],
        'access-control-allow-origin': ['*'],
        'cache-control': ['public, s-maxage=10, stale-while-revalidate'],
        'access-control-allow-methods': ['GET,OPTIONS,PATCH,DELETE,POST,PUT'],
        'access-control-allow-headers': [
          'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version',
        ],
        link: [
          `<${orchestrator.webserverUrl}/api/v1/contents?strategy=relevant&page=1&per_page=30>; rel="first", <${orchestrator.webserverUrl}/api/v1/contents?strategy=relevant&page=1&per_page=30>; rel="last"`,
        ],
        'x-pagination-total-rows': ['0'],
        'content-type': ['application/json; charset=utf-8'],
        etag: responseHeaders.etag,
        'content-length': ['2'],
        vary: ['Accept-Encoding'],
        date: responseHeaders.date,
        connection: [expect.stringMatching(/^close$|^keep-alive$/)],
      };

      const expectedHeadersAlternative = {
        ...expectedHeaders,
        'keep-alive': [expect.stringMatching(/^timeout=/)],
      };

      expect([expectedHeaders, expectedHeadersAlternative]).toContainEqual(responseHeaders);
    });

    test('With no content', async () => {
      const { response, responseBody } = await contentsRequestBuilder.get();

      expect.soft(response.status).toBe(200);
      expect(responseBody).toStrictEqual([]);
    });

    test('With invalid strategy', async () => {
      const { response, responseBody } = await contentsRequestBuilder.get(`?strategy=invalid`);

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"strategy" deve possuir um dos seguintes valores: "new", "old", "relevant".',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'strategy',
        type: 'any.only',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With 2 "published" entries and strategy "new"', async () => {
      const defaultUser = await orchestrator.createUser();

      const firstRootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Primeiro conteúdo criado',
        status: 'published',
      });

      const secondRootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Segundo conteúdo criado',
        status: 'published',
      });

      // thirdRootContent
      await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Terceiro conteúdo criado',
        body: `Este conteúdo não deverá aparecer na lista retornada pelo /contents,
               porque quando um conteúdo possui o "status" como "draft", ele não
               esta pronto para ser listado publicamente.`,
        status: 'draft',
      });

      // NotRootContentPublished
      await orchestrator.createContent({
        owner_id: defaultUser.id,
        parent_id: firstRootContent.id,
        title: 'Quarto conteúdo criado',
        body: `Este conteúdo não deverá aparecer na lista retornada pelo /contents,
               porque quando um conteúdo possui um "parent_id",
               significa que ele é uma resposta a um outro conteúdo.`,
        status: 'published',
      });

      // NotRootContentDraft
      await orchestrator.createContent({
        owner_id: defaultUser.id,
        parent_id: firstRootContent.id,
        title: 'Quinto conteúdo criado',
        body: `Este conteúdo não somente não deve aparecer na lista principal,
               como também não deve ser contabilizado no "children_deep_count".`,
        status: 'draft',
      });

      const { response, responseBody } = await contentsRequestBuilder.get(`?strategy=new`);

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual([
        {
          id: secondRootContent.id,
          owner_id: defaultUser.id,
          parent_id: null,
          slug: 'segundo-conteudo-criado',
          title: 'Segundo conteúdo criado',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: secondRootContent.created_at.toISOString(),
          updated_at: secondRootContent.updated_at.toISOString(),
          published_at: secondRootContent.published_at.toISOString(),
          deleted_at: null,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: defaultUser.username,
          children_deep_count: 0,
        },
        {
          id: firstRootContent.id,
          owner_id: defaultUser.id,
          parent_id: null,
          slug: 'primeiro-conteudo-criado',
          title: 'Primeiro conteúdo criado',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: firstRootContent.created_at.toISOString(),
          updated_at: firstRootContent.updated_at.toISOString(),
          published_at: firstRootContent.published_at.toISOString(),
          deleted_at: null,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: defaultUser.username,
          children_deep_count: 1,
        },
      ]);

      expect(uuidVersion(responseBody[0].id)).toBe(4);
      expect(uuidVersion(responseBody[1].id)).toBe(4);
      expect(uuidVersion(responseBody[0].owner_id)).toBe(4);
      expect(uuidVersion(responseBody[1].owner_id)).toBe(4);
      expect(responseBody[0].published_at > responseBody[1].published_at).toBe(true);
    });

    test('With 2 "published" entries and strategy "old"', async () => {
      const defaultUser = await orchestrator.createUser();

      const firstRootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Primeiro conteúdo criado',
        status: 'published',
      });

      const secondRootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Segundo conteúdo criado',
        status: 'published',
      });

      // thirdRootContent
      await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Terceiro conteúdo criado',
        body: `Este conteúdo não deverá aparecer na lista retornada pelo /contents,
               porque quando um conteúdo possui o "status" como "draft", ele não
               esta pronto para ser listado publicamente.`,
        status: 'draft',
      });

      // NotRootContentPublished
      await orchestrator.createContent({
        owner_id: defaultUser.id,
        parent_id: firstRootContent.id,
        title: 'Quarto conteúdo criado',
        body: `Este conteúdo não deverá aparecer na lista retornada pelo /contents,
               porque quando um conteúdo possui um "parent_id",
               significa que ele é uma resposta a um outro conteúdo.`,
        status: 'published',
      });

      // NotRootContentDraft
      await orchestrator.createContent({
        owner_id: defaultUser.id,
        parent_id: firstRootContent.id,
        title: 'Quinto conteúdo criado',
        body: `Este conteúdo não somente não deve aparecer na lista principal,
               como também não deve ser contabilizado no "children_deep_count".`,
        status: 'draft',
      });

      const { response, responseBody } = await contentsRequestBuilder.get(`?strategy=old`);

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual([
        {
          id: firstRootContent.id,
          owner_id: defaultUser.id,
          parent_id: null,
          slug: 'primeiro-conteudo-criado',
          title: 'Primeiro conteúdo criado',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: firstRootContent.created_at.toISOString(),
          updated_at: firstRootContent.updated_at.toISOString(),
          published_at: firstRootContent.published_at.toISOString(),
          deleted_at: null,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: defaultUser.username,
          children_deep_count: 1,
        },
        {
          id: secondRootContent.id,
          owner_id: defaultUser.id,
          parent_id: null,
          slug: 'segundo-conteudo-criado',
          title: 'Segundo conteúdo criado',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: secondRootContent.created_at.toISOString(),
          updated_at: secondRootContent.updated_at.toISOString(),
          published_at: secondRootContent.published_at.toISOString(),
          deleted_at: null,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: defaultUser.username,
          children_deep_count: 0,
        },
      ]);

      expect(uuidVersion(responseBody[0].id)).toBe(4);
      expect(uuidVersion(responseBody[1].id)).toBe(4);
      expect(uuidVersion(responseBody[0].owner_id)).toBe(4);
      expect(uuidVersion(responseBody[1].owner_id)).toBe(4);
      expect(responseBody[1].published_at > responseBody[0].published_at).toBe(true);
    });

    test('With 3 children 3 level deep and default strategy', async () => {
      const defaultUser = await orchestrator.createUser();

      const rootContent = await orchestrator.createContent({
        owner_id: defaultUser.id,
        title: 'Conteúdo raiz',
        status: 'published',
      });

      const level1Content = await orchestrator.createContent({
        owner_id: defaultUser.id,
        parent_id: rootContent.id,
        body: 'Nível 1',
        status: 'published',
      });

      const level2Content = await orchestrator.createContent({
        owner_id: defaultUser.id,
        parent_id: level1Content.id,
        body: 'Nível 2',
        status: 'published',
      });

      // level3Content
      await orchestrator.createContent({
        owner_id: defaultUser.id,
        parent_id: level2Content.id,
        body: 'Nível 3',
        status: 'published',
      });

      const level4ContentDeleted = await orchestrator.createContent({
        owner_id: defaultUser.id,
        parent_id: level2Content.id,
        body: 'Nível 4 (vai ser deletado e não deve ser contabilizado)',
        status: 'published',
      });
      await orchestrator.updateContent(level4ContentDeleted.id, { status: 'deleted' });

      const { response, responseBody } = await contentsRequestBuilder.get();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual([
        {
          id: rootContent.id,
          owner_id: defaultUser.id,
          parent_id: null,
          slug: 'conteudo-raiz',
          title: 'Conteúdo raiz',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: rootContent.created_at.toISOString(),
          updated_at: rootContent.updated_at.toISOString(),
          published_at: rootContent.published_at.toISOString(),
          deleted_at: null,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: defaultUser.username,
          children_deep_count: 3,
        },
      ]);
    });

    test('With 60 entries, default "page", "per_page" and strategy "new"', async () => {
      const defaultUser = await orchestrator.createUser();

      const numberOfContents = 60;

      for (let item = 0; item < numberOfContents; item++) {
        await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: `Conteúdo #${item + 1}`,
          status: 'published',
        });
      }
      const { response, responseBody } = await contentsRequestBuilder.get(`?strategy=new`);

      const responseLinkHeader = parseLinkHeader(response.headers.get('Link'));
      const responseTotalRowsHeader = response.headers.get('X-Pagination-Total-Rows');

      expect.soft(response.status).toBe(200);
      expect(responseTotalRowsHeader).toBe('60');
      expect(responseLinkHeader).toStrictEqual({
        first: {
          page: '1',
          per_page: '30',
          rel: 'first',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=new&page=1&per_page=30`,
        },
        next: {
          page: '2',
          per_page: '30',
          rel: 'next',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=new&page=2&per_page=30`,
        },
        last: {
          page: '2',
          per_page: '30',
          rel: 'last',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=new&page=2&per_page=30`,
        },
      });

      expect(responseBody.length).toBe(30);
      expect(responseBody[0].title).toBe('Conteúdo #60');
      expect(responseBody[29].title).toBe('Conteúdo #31');
    });

    test('With 60 entries, default "page", "per_page" and strategy "relevant" (default)', async () => {
      const firstUser = await orchestrator.createUser();
      const secondUser = await orchestrator.createUser();
      const thirdUser = await orchestrator.createUser();

      const numberOfContents = 60;
      const contentList = [];

      vi.useFakeTimers({
        now: new Date(Date.now() - 1000 * 60 * 60 * 24 * 10), // 10 days ago
      });

      contentList.push(
        await orchestrator.createContent({
          owner_id: firstUser.id,
          title: `Conteúdo #1`,
          status: 'published',
        }),
      );

      vi.useRealTimers();

      await orchestrator.createContent({
        owner_id: firstUser.id,
        body: 'Comment #10',
        status: 'published',
        parent_id: contentList[0].id,
      });

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:credit',
        recipientId: contentList[0].id, // Conteúdo #1
        amount: 10, // -> with recent comment, but same user
      });

      vi.useFakeTimers({
        now: new Date(Date.now() - 1000 * 60 * 60 * 24 * 9), // 9 days ago
      });

      contentList.push(
        await orchestrator.createContent({
          owner_id: firstUser.id,
          title: `Conteúdo #2`,
          status: 'published',
        }),
      );

      vi.useRealTimers();

      await orchestrator.createContent({
        owner_id: secondUser.id,
        body: 'Comment #11',
        status: 'published',
        parent_id: contentList[1].id,
      });

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:credit',
        recipientId: contentList[1].id, // Conteúdo #2
        amount: 10, // -> score = 33, more than 7 days ago, but with recent comment
      });

      vi.useFakeTimers({
        now: new Date(Date.now() - 1000 * 60 * 60 * 24 * 8), // 8 days ago
      });

      contentList.push(
        await orchestrator.createContent({
          owner_id: firstUser.id,
          title: `Conteúdo #3`,
          status: 'published',
        }),
      );

      vi.useRealTimers();

      await orchestrator.createContent({
        owner_id: secondUser.id,
        body: 'Comment #12',
        status: 'published',
        parent_id: contentList[2].id,
      });

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:credit',
        recipientId: contentList[2].id, // Conteúdo #3
        amount: 9, // -> score = 30, more than 7 days ago, but with recent comment
      });

      vi.useFakeTimers({
        now: new Date(Date.now() - 1000 * 60 * 60 * 24 * 7), // 7 days ago
      });

      contentList.push(
        await orchestrator.createContent({
          owner_id: firstUser.id,
          title: `Conteúdo #4`,
          status: 'published',
        }),
      );

      vi.useRealTimers();

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:credit',
        recipientId: contentList[3].id, // Conteúdo #4
        amount: 9, // -> score = 30, but more than 7 days ago
      });

      vi.useFakeTimers({
        now: new Date(Date.now() - 1000 * 60 * 60 * 24 * 3), // 3 days ago
      });

      contentList.push(
        await orchestrator.createContent({
          owner_id: secondUser.id,
          title: `Conteúdo #5`,
          status: 'published',
        }),
      );

      vi.useRealTimers();

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:credit',
        recipientId: contentList[4].id, // Conteúdo #5
        amount: 8, // -> score = 27 and 3 days ago -> group_6
      });

      vi.useFakeTimers({
        now: new Date(Date.now() - 1000 * 60 * 60 * 35), // 35 hours ago
      });

      contentList.push(
        await orchestrator.createContent({
          owner_id: thirdUser.id,
          title: `Conteúdo #6`,
          status: 'published',
        }),
      );

      vi.useRealTimers();

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:credit',
        recipientId: contentList[5].id, // Conteúdo #6
        amount: 3, // score = 12 and less than 36 hours -> group_4
      });

      vi.useFakeTimers({
        now: new Date(Date.now() - 1000 * 60 * 60 * 37), // 37 hours ago
      });

      contentList.push(
        await orchestrator.createContent({
          owner_id: firstUser.id,
          title: `Conteúdo #7`,
          status: 'published',
        }),
      );

      vi.useRealTimers();

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:credit',
        recipientId: contentList[6].id, // Conteúdo #7
        amount: 4, // score = 15 and more than 37 hours -> group_5
      });

      vi.useFakeTimers({
        now: new Date(Date.now() - 1000 * 60 * 60 * 36), // 36 hours ago
      });

      contentList.push(
        await orchestrator.createContent({
          owner_id: secondUser.id,
          title: `Conteúdo #8`,
          status: 'published',
        }),
      );

      vi.useRealTimers();

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:credit',
        recipientId: contentList[7].id, // Conteúdo #8
        amount: 4, // score = 15 and more than 36 hours -> group_5
      });

      vi.useFakeTimers({
        now: new Date(Date.now() - 1000 * 60 * 60 * 24), // 24 hours ago
      });

      contentList.push(
        await orchestrator.createContent({
          owner_id: thirdUser.id,
          title: `Conteúdo #9`,
          status: 'published',
        }),
      );

      vi.useRealTimers();

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:credit',
        recipientId: contentList[8].id, // Conteúdo #9
        amount: 2, // score = 9 and more than 24 hours -> group_5
      });

      for (let item = 9; item < numberOfContents; item = item + 3) {
        contentList.push(
          await orchestrator.createContent({
            owner_id: firstUser.id,
            title: `Conteúdo #${item + 1}`,
            status: 'published',
          }),
        );

        contentList.push(
          await orchestrator.createContent({
            owner_id: secondUser.id,
            title: `Conteúdo #${item + 2}`,
            status: 'published',
          }),
        );

        contentList.push(
          await orchestrator.createContent({
            owner_id: thirdUser.id,
            title: `Conteúdo #${item + 3}`,
            status: 'published',
          }),
        );
      }

      await orchestrator.createContent({
        owner_id: firstUser.id,
        body: 'Comment #1',
        status: 'published',
        parent_id: contentList[44].id, // Conteúdo #45 -> score = 3
      });

      await orchestrator.createContent({
        owner_id: secondUser.id,
        body: 'Comment #2',
        status: 'published',
        parent_id: contentList[44].id, // Conteúdo #45 -> score = 4
      });

      // Comment on own content should not count towards the score
      await orchestrator.createContent({
        owner_id: thirdUser.id,
        body: 'Comment #3',
        status: 'published',
        parent_id: contentList[44].id, // Conteúdo #45 -> score = 4
      });

      await orchestrator.createContent({
        owner_id: firstUser.id,
        body: 'Comment #4',
        status: 'published',
        parent_id: contentList[47].id, // Conteúdo #48 -> score = 3
      });

      await orchestrator.createContent({
        owner_id: secondUser.id,
        body: 'Comment #5',
        status: 'published',
        parent_id: contentList[47].id, // Conteúdo #48 -> score = 4
      });

      await orchestrator.createContent({
        owner_id: firstUser.id,
        body: 'Comment #6',
        status: 'published',
        parent_id: contentList[52].id, // Conteúdo #53 -> score = 3
      });

      // More than one comment from the same user should not count towards the score
      await orchestrator.createContent({
        owner_id: firstUser.id,
        body: 'Comment #7',
        status: 'published',
        parent_id: contentList[52].id, // Conteúdo #53 -> score = 3
      });

      await orchestrator.createContent({
        owner_id: firstUser.id,
        body: 'Comment #8',
        status: 'published',
        parent_id: contentList[52].id, // Conteúdo #53 -> score = 3
      });

      await orchestrator.createContent({
        owner_id: thirdUser.id,
        body: 'Comment #9',
        status: 'published',
        parent_id: contentList[51].id, // Conteúdo #52 -> score = 3
      });

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:credit',
        recipientId: contentList[30].id, // Conteúdo #31
        amount: 5, // score = 18 -> group_1
      });

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:credit',
        recipientId: contentList[35].id, // Conteúdo #36
        amount: 2, // score = 9 -> group_2
      });

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:debit',
        recipientId: contentList[49].id, // Conteúdo #50
        amount: -2,
      });

      await orchestrator.createBalance({
        balanceType: 'content:tabcoin:debit',
        recipientId: contentList[50].id, // Conteúdo #51
        amount: -3,
      });

      const { response, responseBody } = await contentsRequestBuilder.get();

      const responseLinkHeader = parseLinkHeader(response.headers.get('Link'));
      const responseTotalRowsHeader = response.headers.get('X-Pagination-Total-Rows');

      expect.soft(response.status).toBe(200);
      expect(responseTotalRowsHeader).toBe('56');
      expect(responseLinkHeader).toStrictEqual({
        first: {
          page: '1',
          per_page: '30',
          rel: 'first',
          strategy: 'relevant',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=relevant&page=1&per_page=30`,
        },
        next: {
          page: '2',
          per_page: '30',
          rel: 'next',
          strategy: 'relevant',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=relevant&page=2&per_page=30`,
        },
        last: {
          page: '2',
          per_page: '30',
          rel: 'last',
          strategy: 'relevant',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=relevant&page=2&per_page=30`,
        },
      });

      expect(responseBody.length).toBe(30);

      // group_1 -> score > 16 and less than 36 hours ago
      expect(responseBody[0].title).toBe('Conteúdo #31');

      // group_2 -> score > 8 and less than 24 hours ago
      expect(responseBody[1].title).toBe('Conteúdo #36');

      // group_3 -> max one new content by user with less than 12 hours
      expect(responseBody[2].title).toBe('Conteúdo #60');
      expect(responseBody[3].title).toBe('Conteúdo #59');
      expect(responseBody[4].title).toBe('Conteúdo #58');

      // group_4 -> score > 11 and less than 36 hours ago
      expect(responseBody[5].title).toBe('Conteúdo #6');

      // group_5 -> score > 8 and less than 3 days ago
      expect(responseBody[6].title).toBe('Conteúdo #8');
      expect(responseBody[7].title).toBe('Conteúdo #7');
      expect(responseBody[8].title).toBe('Conteúdo #9');

      // group_6 -> tabcoins > 0 and less than 7 days ago
      // or commented less than 24 hours
      expect(responseBody[9].title).toBe('Conteúdo #2');
      expect(responseBody[10].title).toBe('Conteúdo #3');
      expect(responseBody[11].title).toBe('Conteúdo #5');
      expect(responseBody[12].title).toBe('Conteúdo #48');
      expect(responseBody[13].title).toBe('Conteúdo #45');
      expect(responseBody[14].title).toBe('Conteúdo #53');
      expect(responseBody[15].title).toBe('Conteúdo #52');
      expect(responseBody[16].title).toBe('Conteúdo #57');
      expect(responseBody[19].title).toBe('Conteúdo #54');
      expect(responseBody[20].title).toBe('Conteúdo #49');
      expect(responseBody[21].title).toBe('Conteúdo #47');
      expect(responseBody[22].title).toBe('Conteúdo #46');
      expect(responseBody[23].title).toBe('Conteúdo #44');
      expect(responseBody[29].title).toBe('Conteúdo #38');

      const page2RequestBuilder = new RequestBuilder(responseLinkHeader.next.url);
      const { response: page2Response, responseBody: page2ResponseBody } = await page2RequestBuilder.get();

      const page2ResponseLinkHeader = parseLinkHeader(page2Response.headers.get('Link'));
      const page2ResponseTotalRowsHeader = page2Response.headers.get('X-Pagination-Total-Rows');

      expect.soft(page2Response.status).toBe(200);
      expect(page2ResponseTotalRowsHeader).toBe('56');
      expect(page2ResponseLinkHeader).toStrictEqual({
        first: {
          page: '1',
          per_page: '30',
          rel: 'first',
          strategy: 'relevant',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=relevant&page=1&per_page=30`,
        },
        prev: {
          page: '1',
          per_page: '30',
          rel: 'prev',
          strategy: 'relevant',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=relevant&page=1&per_page=30`,
        },
        last: {
          page: '2',
          per_page: '30',
          rel: 'last',
          strategy: 'relevant',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=relevant&page=2&per_page=30`,
        },
      });

      expect(page2ResponseBody.length).toBe(26);
      expect(page2ResponseBody[0].title).toBe('Conteúdo #37');
      expect(page2ResponseBody[1].title).toBe('Conteúdo #35');
      expect(page2ResponseBody[2].title).toBe('Conteúdo #34');
      expect(page2ResponseBody[3].title).toBe('Conteúdo #33');
      expect(page2ResponseBody[24].title).toBe('Conteúdo #11');
      expect(page2ResponseBody[25].title).toBe('Conteúdo #10');
    });

    test('With 9 entries, custom "page", "per_page" and strategy "new" (navigating using Link Header)', async () => {
      const defaultUser = await orchestrator.createUser();

      const numberOfContents = 9;

      for (let item = 0; item < numberOfContents; item++) {
        await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: `Conteúdo #${item + 1}`,
          status: 'published',
        });
      }

      const { response: page1, responseBody: page1Body } = await contentsRequestBuilder.get(
        `?page=1&per_page=3&strategy=new`,
      );

      const page1LinkHeader = parseLinkHeader(page1.headers.get('Link'));
      const page1TotalRowsHeader = page1.headers.get('X-Pagination-Total-Rows');

      expect.soft(page1.status).toBe(200);
      expect(page1TotalRowsHeader).toBe('9');
      expect(page1LinkHeader).toStrictEqual({
        first: {
          page: '1',
          per_page: '3',
          rel: 'first',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=new&page=1&per_page=3`,
        },
        next: {
          page: '2',
          per_page: '3',
          rel: 'next',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=new&page=2&per_page=3`,
        },
        last: {
          page: '3',
          per_page: '3',
          rel: 'last',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=new&page=3&per_page=3`,
        },
      });

      expect(page1Body.length).toBe(3);
      expect(page1Body[0].title).toBe('Conteúdo #9');
      expect(page1Body[1].title).toBe('Conteúdo #8');
      expect(page1Body[2].title).toBe('Conteúdo #7');

      const page2RequestBuilder = new RequestBuilder(page1LinkHeader.next.url);
      const { response: page2, responseBody: page2Body } = await page2RequestBuilder.get();

      const page2LinkHeader = parseLinkHeader(page2.headers.get('Link'));
      const page2TotalRowsHeader = page2.headers.get('X-Pagination-Total-Rows');

      expect.soft(page2.status).toBe(200);
      expect(page2TotalRowsHeader).toBe('9');
      expect(page2LinkHeader).toStrictEqual({
        first: {
          page: '1',
          per_page: '3',
          rel: 'first',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=new&page=1&per_page=3`,
        },
        prev: {
          page: '1',
          per_page: '3',
          rel: 'prev',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=new&page=1&per_page=3`,
        },
        next: {
          page: '3',
          per_page: '3',
          rel: 'next',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=new&page=3&per_page=3`,
        },
        last: {
          page: '3',
          per_page: '3',
          rel: 'last',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=new&page=3&per_page=3`,
        },
      });

      expect(page2Body.length).toBe(3);
      expect(page2Body[0].title).toBe('Conteúdo #6');
      expect(page2Body[1].title).toBe('Conteúdo #5');
      expect(page2Body[2].title).toBe('Conteúdo #4');

      const page3RequestBuilder = new RequestBuilder(page2LinkHeader.next.url);
      const { response: page3, responseBody: page3Body } = await page3RequestBuilder.get();

      const page3LinkHeader = parseLinkHeader(page3.headers.get('Link'));
      const page3TotalRowsHeader = page3.headers.get('X-Pagination-Total-Rows');

      expect.soft(page3.status).toBe(200);
      expect(page3TotalRowsHeader).toBe('9');
      expect(page3LinkHeader).toStrictEqual({
        first: {
          page: '1',
          per_page: '3',
          rel: 'first',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=new&page=1&per_page=3`,
        },
        prev: {
          page: '2',
          per_page: '3',
          rel: 'prev',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=new&page=2&per_page=3`,
        },
        last: {
          page: '3',
          per_page: '3',
          rel: 'last',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=new&page=3&per_page=3`,
        },
      });

      expect(page3Body.length).toBe(3);
      expect(page3Body[0].title).toBe('Conteúdo #3');
      expect(page3Body[1].title).toBe('Conteúdo #2');
      expect(page3Body[2].title).toBe('Conteúdo #1');

      // FIRST AND LAST PAGE USING "PAGE 1" LINK HEADER
      const firstPageRequestBuilder = new RequestBuilder(page1LinkHeader.first.url);
      const { response: firstPage, responseBody: firstPageBody } = await firstPageRequestBuilder.get();
      const firstPageLinkHeader = parseLinkHeader(firstPage.headers.get('Link'));
      const firstPageTotalRowsHeader = firstPage.headers.get('X-Pagination-Total-Rows');

      expect.soft(firstPage.status).toBe(200);
      expect(firstPageTotalRowsHeader).toBe(page1TotalRowsHeader);
      expect(firstPageLinkHeader).toStrictEqual(page1LinkHeader);
      expect(firstPageBody).toStrictEqual(page1Body);

      const lastPageRequestBuilder = new RequestBuilder(page1LinkHeader.last.url);
      const { response: lastPage, responseBody: lastPageBody } = await lastPageRequestBuilder.get();
      const lastPageLinkHeader = parseLinkHeader(lastPage.headers.get('Link'));
      const lastPageTotalRowsHeader = lastPage.headers.get('X-Pagination-Total-Rows');

      expect.soft(lastPage.status).toBe(200);
      expect(lastPageTotalRowsHeader).toBe(page3TotalRowsHeader);
      expect(lastPageLinkHeader).toStrictEqual(page3LinkHeader);
      expect(lastPageBody).toStrictEqual(page3Body);
    });

    test('With 9 entries but "page" out of bounds and strategy "new"', async () => {
      const defaultUser = await orchestrator.createUser();

      const numberOfContents = 9;

      for (let item = 0; item < numberOfContents; item++) {
        await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: `Conteúdo #${item + 1}`,
          status: 'published',
        });
      }

      const { response: page4, responseBody: page4Body } = await contentsRequestBuilder.get(
        '?strategy=new&page=4&per_page=3',
      );

      const page4LinkHeader = parseLinkHeader(page4.headers.get('Link'));
      const page4TotalRowsHeader = page4.headers.get('X-Pagination-Total-Rows');

      expect.soft(page4.status).toBe(200);
      expect(page4TotalRowsHeader).toBe('9');
      expect(page4LinkHeader).toStrictEqual({
        first: {
          page: '1',
          per_page: '3',
          rel: 'first',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=new&page=1&per_page=3`,
        },
        prev: {
          page: '3',
          per_page: '3',
          rel: 'prev',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=new&page=3&per_page=3`,
        },
        last: {
          page: '3',
          per_page: '3',
          rel: 'last',
          strategy: 'new',
          url: `${orchestrator.webserverUrl}/api/v1/contents?strategy=new&page=3&per_page=3`,
        },
      });

      expect(page4Body.length).toBe(0);
    });

    test('With "page" with a String', async () => {
      const { response, responseBody } = await contentsRequestBuilder.get('?page=CINCO');

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"page" deve ser do tipo Number.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'page',
        type: 'number.base',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With "page" with an invalid minimum Number', async () => {
      const { response, responseBody } = await contentsRequestBuilder.get('?page=0');

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"page" deve possuir um valor mínimo de 1.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'page',
        type: 'number.min',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With "page" with an invalid maximum Number', async () => {
      const { response, responseBody } = await contentsRequestBuilder.get('?page=9007199254740991');

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"page" deve possuir um valor máximo de 9007199254740990.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'page',
        type: 'number.max',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With "page" with an unsafe Number', async () => {
      const { response, responseBody } = await contentsRequestBuilder.get('?page=9007199254740992');

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: `"page" deve possuir um valor entre 1 e 9007199254740990.`,
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'page',
        type: 'number.unsafe',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With "page" with a Float Number', async () => {
      const { response, responseBody } = await contentsRequestBuilder.get('?page=1.5');

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"page" deve ser um Inteiro.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'page',
        type: 'number.integer',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With "per_page" with a String', async () => {
      const { response, responseBody } = await contentsRequestBuilder.get('?per_page=SEIS');

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"per_page" deve ser do tipo Number.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'per_page',
        type: 'number.base',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With "per_page" with an invalid minimum Number', async () => {
      const { response, responseBody } = await contentsRequestBuilder.get('?per_page=0');

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"per_page" deve possuir um valor mínimo de 1.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'per_page',
        type: 'number.min',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With "per_page" with an invalid maximum Number', async () => {
      const { response, responseBody } = await contentsRequestBuilder.get('?per_page=9007199254740991');

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"per_page" deve possuir um valor máximo de 100.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'per_page',
        type: 'number.max',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With "per_page" with an unsafe Number', async () => {
      const { response, responseBody } = await contentsRequestBuilder.get('?per_page=9007199254740992');

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"per_page" deve possuir um valor entre 1 e 100.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'per_page',
        type: 'number.unsafe',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With "per_page" with a Float Number', async () => {
      const { response, responseBody } = await contentsRequestBuilder.get('?per_page=1.5');

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"per_page" deve ser um Inteiro.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'per_page',
        type: 'number.integer',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });
  });

  describe('Anonymous user (dropAllTables beforeAll)', () => {
    describe('with_children and with_root using different strategies', () => {
      const rootSortedByOld = [];
      const childSortedByOld = [];
      const rootSortedByNew = [];
      const childSortedByNew = [];
      const rootSortedByTabCoins = [];
      const childSortedByTabCoins = [];

      beforeAll(async () => {
        await orchestrator.dropAllTables();
        await orchestrator.runPendingMigrations();

        const createUser = async () => await orchestrator.createUser();
        const createContent = async (user, options) =>
          await orchestrator.createContent({ owner_id: user.id, ...options });
        const createComment = async (user, parent, body) =>
          await createContent(user, { body, status: 'published', parent_id: parent.id });

        const [firstUser, secondUser, thirdUser] = await Promise.all(Array.from({ length: 3 }, () => createUser()));

        await createContent(firstUser, { title: 'Conteúdo "Draft"', status: 'draft' });

        const firstRootContent = await createContent(secondUser, {
          title: 'Primeiro conteúdo criado',
          status: 'published',
        });

        rootSortedByOld.push({
          id: firstRootContent.id,
          owner_id: secondUser.id,
          parent_id: null,
          slug: 'primeiro-conteudo-criado',
          title: 'Primeiro conteúdo criado',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: firstRootContent.created_at.toISOString(),
          updated_at: firstRootContent.updated_at.toISOString(),
          published_at: firstRootContent.published_at.toISOString(),
          deleted_at: null,
          owner_username: secondUser.username,
          tabcoins: 2,
          tabcoins_credit: 1,
          tabcoins_debit: 0,
          children_deep_count: 1,
        });

        await orchestrator.createRate(firstRootContent, 1);

        const secondRootContent = await createContent(thirdUser, {
          title: 'Segundo conteúdo criado',
          status: 'published',
        });

        rootSortedByOld.push({
          id: secondRootContent.id,
          owner_id: thirdUser.id,
          parent_id: null,
          slug: 'segundo-conteudo-criado',
          title: 'Segundo conteúdo criado',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: secondRootContent.created_at.toISOString(),
          updated_at: secondRootContent.updated_at.toISOString(),
          published_at: secondRootContent.published_at.toISOString(),
          deleted_at: null,
          owner_username: thirdUser.username,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          children_deep_count: 1,
        });

        const firstComment = await createComment(firstUser, secondRootContent, 'Comentário #1');
        const secondComment = await createComment(thirdUser, firstRootContent, 'Comentário #2');
        await orchestrator.createRate(firstComment, 1);

        function createCommentExpect(comment, owner, parent, tabcoins = 0) {
          return {
            id: comment.id,
            owner_id: owner.id,
            parent_id: parent.id,
            slug: comment.slug,
            title: null,
            body: comment.body,
            status: 'published',
            type: 'content',
            source_url: null,
            created_at: comment.created_at.toISOString(),
            updated_at: comment.updated_at.toISOString(),
            published_at: comment.published_at.toISOString(),
            deleted_at: null,
            owner_username: owner.username,
            tabcoins,
            tabcoins_credit: tabcoins,
            tabcoins_debit: 0,
            children_deep_count: 0,
          };
        }

        childSortedByOld.push(
          createCommentExpect(firstComment, firstUser, secondRootContent, 1),
          createCommentExpect(secondComment, thirdUser, firstRootContent),
        );

        rootSortedByNew.push(...rootSortedByOld.slice().reverse());
        childSortedByNew.push(...childSortedByOld.slice().reverse());

        rootSortedByTabCoins.push(...rootSortedByNew.slice().sort((a, b) => b.tabcoins - a.tabcoins));
        childSortedByTabCoins.push(...childSortedByNew.slice().sort((a, b) => b.tabcoins - a.tabcoins));
      });

      test.each([
        {
          content: 'relevant root',
          params: [],
          responseLinkParams: ['strategy=relevant'],
          getExpected: () => rootSortedByTabCoins,
        },
        {
          content: 'relevant root',
          params: ['with_children=false'],
          responseLinkParams: ['strategy=relevant', 'with_children=false'],
          getExpected: () => rootSortedByTabCoins,
        },
        {
          content: 'relevant root and children',
          params: ['with_children=true'],
          responseLinkParams: ['strategy=relevant', 'with_children=true'],
          getExpected: () => [
            rootSortedByTabCoins[0],
            childSortedByTabCoins[0],
            rootSortedByTabCoins[1],
            childSortedByTabCoins[1],
          ],
        },
        {
          content: 'new root',
          params: ['with_children=false', 'with_root=true', 'strategy=new'],
          responseLinkParams: ['strategy=new', 'with_root=true', 'with_children=false'],
          getExpected: () => rootSortedByNew,
        },
        {
          content: 'new children',
          params: ['with_children=true', 'with_root=false', 'strategy=new'],
          responseLinkParams: ['strategy=new', 'with_root=false', 'with_children=true'],
          getExpected: () => childSortedByNew,
        },
        {
          content: 'new root and children',
          params: ['with_children=true', 'strategy=new'],
          responseLinkParams: ['strategy=new', 'with_children=true'],
          getExpected: () => [...childSortedByNew, ...rootSortedByNew],
        },
        {
          content: 'new root and children',
          params: ['with_children=true', 'with_root=true', 'strategy=new'],
          responseLinkParams: ['strategy=new', 'with_root=true', 'with_children=true'],
          getExpected: () => [...childSortedByNew, ...rootSortedByNew],
        },
        {
          content: 'new root',
          params: ['with_root=true', 'strategy=new'],
          responseLinkParams: ['strategy=new', 'with_root=true'],
          getExpected: () => rootSortedByNew,
        },
      ])('get $content with params: $params', async ({ params, responseLinkParams, getExpected }) => {
        const { response, responseBody } = await contentsRequestBuilder.get(`?${params.join('&')}`);

        expect.soft(response.status).toBe(200);
        expect(responseBody).toStrictEqual(getExpected());

        const linkParamsString = responseLinkParams.join('&');
        const responseLinkHeader = parseLinkHeader(response.headers.get('Link'));

        expect(responseLinkHeader.first.url).toBe(
          `${orchestrator.webserverUrl}/api/v1/contents?${linkParamsString}&page=1&per_page=30`,
        );
        expect(responseLinkHeader.last.url).toBe(
          `${orchestrator.webserverUrl}/api/v1/contents?${linkParamsString}&page=1&per_page=30`,
        );
      });
    });

    describe('Should not return "ad" regardless of strategy', () => {
      beforeAll(async () => {
        await orchestrator.dropAllTables();
        await orchestrator.runPendingMigrations();

        const firstUser = await orchestrator.createUser();
        const secondUser = await orchestrator.createUser();

        await orchestrator.createBalance({
          balanceType: 'user:tabcash',
          recipientId: firstUser.id,
          amount: defaultTabCashForAdCreation,
        });

        const adContent = await orchestrator.createContent({
          owner_id: firstUser.id,
          title: 'Ad Title',
          body: relevantBody,
          status: 'published',
          type: 'ad',
        });

        await orchestrator.createContent({
          parent_id: adContent.id,
          owner_id: secondUser.id,
          body: relevantBody,
          status: 'published',
        });
      });

      test.each(['', '?strategy=relevant', '?strategy=new', '?strategy=old'])(
        'get contents with params: %s',
        async (params) => {
          const { response, responseBody } = await contentsRequestBuilder.get(params);

          expect.soft(response.status).toBe(200);
          expect(responseBody).toStrictEqual([]);
        },
      );
    });
  });
});
</file>

<file path="tests/integration/api/v1/contents/options.test.js">
import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
});

describe('OPTIONS /api/v1/contents', () => {
  describe('Anonymous user', () => {
    test('Should return correct CORS headers for OPTIONS method', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/contents`, {
        method: 'options',
      });

      expect.soft(response.status).toBe(200);
      expect(response.headers.get('access-control-allow-methods')).toBe('GET,OPTIONS,PATCH,DELETE,POST,PUT');
      expect(response.headers.get('access-control-allow-origin')).toBe('*');
      expect(response.headers.get('access-control-allow-credentials')).toBe('true');
      expect(response.headers.get('access-control-allow-headers')).toBe(
        'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version',
      );
    });
  });
});
</file>

<file path="tests/integration/api/v1/contents/post.test.js">
import { version as uuidVersion } from 'uuid';

import database from 'infra/database';
import { defaultTabCashForAdCreation, maxSlugLength, maxTitleLength, relevantBody } from 'tests/constants-for-tests';
import orchestrator from 'tests/orchestrator.js';
import RequestBuilder from 'tests/request-builder';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('POST /api/v1/contents', () => {
  describe('Anonymous user', () => {
    test('Content with minimum valid data', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Anônimo tentando postar',
        body: 'Não deveria conseguir.',
      });

      expect.soft(response.status).toBe(403);
      expect.soft(responseBody.status_code).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Usuário não pode executar esta operação.');
      expect(responseBody.action).toBe('Verifique se este usuário possui a feature "create:content".');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND');
    });
  });

  describe('User without "create:content:text_root" feature', () => {
    test('"root" content with valid data', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser({ without: ['create:content:text_root'] });

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Usuário válido, tentando postar na raiz do site.',
        body: 'Não deveria conseguir, pois não possui a feature "create:content:text_root".',
      });

      expect.soft(response.status).toBe(403);
      expect.soft(responseBody.status_code).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Você não possui permissão para criar conteúdos na raiz do site.');
      expect(responseBody.action).toBe('Verifique se você possui a feature "create:content:text_root".');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe(
        'CONTROLLER:CONTENT:POST_HANDLER:CREATE:CONTENT:TEXT_ROOT:FEATURE_NOT_FOUND',
      );
    });
  });

  describe('User without "create:content:text_child" feature', () => {
    test('"child" content with valid data', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { responseBody: rootContent } = await contentsRequestBuilder.post({
        title: 'Conteúdo raiz',
        body: 'Body',
        status: 'published',
      });

      await contentsRequestBuilder.buildUser({ without: ['create:content:text_child'] });

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Usuário válido, tentando postar uma resposta.',
        body: 'Não deveria conseguir, pois não possui a feature "create:content:text_child".',
        parent_id: rootContent.id,
        status: 'published',
      });

      expect.soft(response.status).toBe(403);
      expect.soft(responseBody.status_code).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Você não possui permissão para criar conteúdos dentro de outros conteúdos.');
      expect(responseBody.action).toBe('Verifique se você possui a feature "create:content:text_child".');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe(
        'CONTROLLER:CONTENT:POST_HANDLER:CREATE:CONTENT:TEXT_CHILD:FEATURE_NOT_FOUND',
      );
    });
  });

  describe('Default user', () => {
    test('Content without POST Body and "Content-Type"', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();
      contentsRequestBuilder.buildHeaders({ 'Content-Type': undefined });

      const { response, responseBody } = await contentsRequestBuilder.post();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"body" enviado deve ser do tipo Object.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with POST Body containing an invalid JSON string', async () => {
      const contentsRequestBuilder = new RequestBuilder();
      await contentsRequestBuilder.buildUser();
      contentsRequestBuilder.buildHeaders({ 'Content-Type': undefined });

      const { response, responseBody } = await contentsRequestBuilder.post(
        '/api/v1/contents',
        'Texto corrido no lugar de um JSON',
      );

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"body" enviado deve ser do tipo Object.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "owner_id" pointing to another user', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const firstUser = await contentsRequestBuilder.buildUser();

      const secondUser = await orchestrator.createUser();
      await orchestrator.activateUser(secondUser);

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Tentando criar conteúdo em nome de outro usuário',
        body: 'Campo "owner_id" da request deveria ser ignorado e pego através da sessão.',
        owner_id: secondUser.id,
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: firstUser.id,
        parent_id: null,
        slug: 'tentando-criar-conteudo-em-nome-de-outro-usuario',
        title: 'Tentando criar conteúdo em nome de outro usuário',
        body: 'Campo "owner_id" da request deveria ser ignorado e pego através da sessão.',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: firstUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('Content with "body" not declared', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Não deveria conseguir, falta o "body".',
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"body" é um campo obrigatório.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "body" containing blank String', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Título normal',
        body: '',
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"body" não pode estar em branco.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "body" containing empty Markdown', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Título normal',
        body: `![](https://image-url.com/image.png)
          <div>\u00a0</div>
          <b>\u2800</b>
          <>\u200e</>
          <p>\u200f</p>
          <h1>\u0009</h1>
          <strong>\u0020</strong>
          <em><\u00ad/em>
          <abbr>͏</abbr>
          <address>\u061c</address>
          <bdo>\u180e</bdo>
          <q>\u2000</q>
          <code>\u2001</code>
          <ins>\u2002</ins>
          <del>\u2003</del>
          <dfn>\u2004</dfn>
          <kbd>\u2005</kbd>
          <pre>\u2006</pre>
          <samp>\u2007</samp>
          <var>\u2008</var>
          <br>\u2009</br>
          <div>\u200a</div>
          <a>\u200b</a>
          <base>\u200c</base>
          <img>\u200d</img>
          <area>\u200e</area>
          <map>\u200f</map>
          <param>\u205f</param>
          <object>\u2060</object>
          <ul>\u2061</ul>
          <ol>\u2062</ol>
          <li>\u2063</li>
          <dl>\u2064</dl>
          <dd>\u206a</dd>
          <h1>\u206b</h1>
          <h2>\u206c</h2>
          <h3>\u206d</h3>
          <h4>\u3000</h4>
          <h5>\ufeff</h5>
          <h6>𝅳</h6>
          <>𝅴</>
          <>𝅵</>
          <>𝅶</>
          <>𝅷</>
          <>𝅸</>
          <>𝅹</>
          <>𝅺</>
          <>\u115f</>
          <>\u1160</>
          <>\u17b4</>
          <>\u17b5</>
          <>\u3164</>
          <>\uffa0</>
          </code></a></div></other>
          <code><a><div><other>
          `,
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('Markdown deve conter algum texto.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "title", "body" and "source_url" containing \\u0000 null characters', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: '\u0000Começando com caractere proibido no Postgres',
        body: 'Terminando com caractere proibido no Postgres\u0000',
        source_url: 'https://teste-\u0000caractere.invalido/\u0000',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'comecando-com-caractere-proibido-no-postgres',
        title: 'Começando com caractere proibido no Postgres',
        body: 'Terminando com caractere proibido no Postgres',
        status: 'draft',
        type: 'content',
        source_url: 'https://teste-caractere.invalido/',
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('Content with "title" and "body" containing invalid characters', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: '\u200eTítulo começando e terminando com caracteres inválidos.\u2800',
        body: '\u200fTexto começando e terminando com caracteres inválidos.\u200e',
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"body" deve começar com caracteres visíveis.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "body" containing more than 20.000 characters', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Título normal',
        body: 'A'.repeat(20001),
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"body" deve conter no máximo 20000 caracteres.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "body" containing untrimmed values', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Título normal',
        body: ' Espaço no início e no fim ',
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"body" deve começar com caracteres visíveis.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "body" ending with untrimmed values', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Título normal',
        body: 'Espaço só no fim ',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'titulo-normal',
        title: 'Título normal',
        body: 'Espaço só no fim',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('Content with "body" containing Null value', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Título normal',
        body: null,
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"body" deve ser do tipo String.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "slug" containing a custom valid value', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Mini curso de Node.js',
        body: 'Instale o Node.js',
        slug: 'nodejs',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'nodejs',
        title: 'Mini curso de Node.js',
        body: 'Instale o Node.js',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('Content with "slug" containing a blank String', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Mini curso de Node.js',
        body: 'Instale o Node.js',
        slug: '',
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"slug" não pode estar em branco.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test(`Content with "slug" containing more than ${maxSlugLength} bytes`, async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Mini curso de Node.js',
        body: 'Instale o Node.js',
        slug: `this-slug-must-be-changed-from-${1 + maxSlugLength}-to-${maxSlugLength}-bytes`.padEnd(
          1 + maxSlugLength,
          's',
        ),
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: `this-slug-must-be-changed-from-${1 + maxSlugLength}-to-${maxSlugLength}-bytes`.padEnd(
          maxSlugLength,
          's',
        ),
        title: 'Mini curso de Node.js',
        body: 'Instale o Node.js',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('Content with "slug" containing special characters', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Mini curso de Node.js',
        body: 'Instale o Node.js',
        slug: 'slug-não-pode-ter-caracteres-especiais',
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"slug" está no formato errado.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "slug" containing Null value', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Mini curso de Node.js',
        body: 'Instale o Node.js',
        slug: null,
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"slug" deve ser do tipo String.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "slug" containing the same value of another content (same user, both "published" status)', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      await contentsRequestBuilder.post({
        title: 'Conteúdo existente',
        body: 'Conteúdo existente',
        slug: 'conteudo-existente',
        status: 'published',
      });

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Conteúdo existente',
        body: 'Outro body',
        slug: 'conteudo-existente',
        status: 'published',
      });

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: 'O conteúdo enviado parece ser duplicado.',
        action: 'Utilize um "title" ou "slug" com começo diferente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:CONTENT:CHECK_FOR_CONTENT_UNIQUENESS:ALREADY_EXISTS',
        key: 'slug',
      });
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('Content with "slug" containing the same value of another content (same user, one with "draft" and the other "published" status)', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      await contentsRequestBuilder.post({
        title: 'Conteúdo existente',
        body: 'Conteúdo existente',
        slug: 'conteudo-existente',
        status: 'draft',
      });

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Conteúdo existente',
        body: 'Outro body',
        slug: 'conteudo-existente',
        status: 'published',
      });

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: 'O conteúdo enviado parece ser duplicado.',
        action: 'Utilize um "title" ou "slug" com começo diferente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:CONTENT:CHECK_FOR_CONTENT_UNIQUENESS:ALREADY_EXISTS',
        key: 'slug',
      });
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('Content with "slug" containing the same value of another content (same user, one with "published" and the other "deleted" status)', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { responseBody: firstContent } = await contentsRequestBuilder.post({
        title: 'Conteúdo existente',
        body: 'Conteúdo existente',
        slug: 'conteudo-existente',
        status: 'published',
      });

      await orchestrator.updateContent(firstContent.id, {
        status: 'deleted',
      });

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Conteúdo existente',
        body: 'Outro body',
        slug: 'conteudo-existente',
        status: 'published',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'conteudo-existente',
        title: 'Conteúdo existente',
        body: 'Outro body',
        status: 'published',
        type: 'content',
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: responseBody.published_at,
        deleted_at: null,
        owner_username: defaultUser.username,
      });

      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.published_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('Content with "slug" with trailing hyphen', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Mini curso de Node.js',
        body: 'Instale o Node.js',
        slug: 'slug-with-trailing-hyphen---',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'slug-with-trailing-hyphen',
        title: 'Mini curso de Node.js',
        body: 'Instale o Node.js',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('Content with "title" containing a blank String', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: '',
        body: 'Qualquer coisa.',
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"title" não pode estar em branco.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test(`Content with "title" containing more than ${maxTitleLength} characters`, async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: `Este título possui ${1 + maxTitleLength} caracteres`.padEnd(1 + maxTitleLength, 's'),
        body: 'Qualquer coisa.',
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe(`"title" deve conter no máximo ${maxTitleLength} caracteres.`);
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test(`Content with "title" containing ${maxTitleLength} characters but more than ${maxTitleLength} bytes`, async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title:
          `Este título possui ${maxTitleLength} caracteres ocupando ${1 + maxTitleLength} bytes e deve com 100% de certeza gerar um slug limitado a ${maxSlugLength} bytes`.padEnd(
            maxTitleLength,
            's',
          ),
        body: 'Instale o Node.js',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: `este-titulo-possui-${maxTitleLength}-caracteres-ocupando-${1 + maxTitleLength}-bytes-e-deve-com-100-por-cento-de-certeza-gerar-um-slug-limitado-a-${maxSlugLength}-bytes`.padEnd(
          maxSlugLength,
          's',
        ),
        title:
          `Este título possui ${maxTitleLength} caracteres ocupando ${1 + maxTitleLength} bytes e deve com 100% de certeza gerar um slug limitado a ${maxSlugLength} bytes`.padEnd(
            maxTitleLength,
            's',
          ),
        body: 'Instale o Node.js',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('Content with "title" containing Braille Pattern Blank Unicode Character', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: '\u2800 Braille Pattern Blank Unicode Character \u2800',
        body: 'Instale o Node.js',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'braille-pattern-blank-unicode-character',
        title: 'Braille Pattern Blank Unicode Character',
        body: 'Instale o Node.js',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test(`Content with "title" containing special characters occupying more than ${maxTitleLength} bytes`, async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: '♥'.repeat(maxTitleLength),
        body: `The title is ${maxTitleLength} characters but 765 bytes and the slug should only be ${maxSlugLength} bytes`,
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: ''.padEnd(maxSlugLength, '4pml'),
        title: '♥'.repeat(maxTitleLength),
        body: `The title is ${maxTitleLength} characters but 765 bytes and the slug should only be ${maxSlugLength} bytes`,
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('Content with "title" containing untrimmed values', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: ' Título válido, mas com espaços em branco no início e no fim ',
        body: 'Qualquer coisa.',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'titulo-valido-mas-com-espacos-em-branco-no-inicio-e-no-fim',
        title: 'Título válido, mas com espaços em branco no início e no fim',
        body: 'Qualquer coisa.',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('Content with "title" containing unescaped characters', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: `Tab & News | Conteúdos com \n valor <strong>concreto</strong> e "massa"> participe! '\\o/'`,
        body: 'Qualquer coisa.',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'tab-e-news-conteudos-com-valor-strong-concreto-strong-e-massa-participe-o',
        title: `Tab & News | Conteúdos com \n valor <strong>concreto</strong> e "massa"> participe! '\\o/'`,
        body: 'Qualquer coisa.',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('Content with "status" set to "draft"', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Deveria criar um conteúdo com status "draft".',
        body: 'Qualquer coisa.',
        status: 'draft',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'deveria-criar-um-conteudo-com-status-draft',
        title: 'Deveria criar um conteúdo com status "draft".',
        body: 'Qualquer coisa.',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('Content with "status" set to "published"', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Deveria criar um conteúdo com status "published".',
        body: 'E isso vai fazer ter um "published_at" preenchido automaticamente.',
        status: 'published',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'deveria-criar-um-conteudo-com-status-published',
        title: 'Deveria criar um conteúdo com status "published".',
        body: 'E isso vai fazer ter um "published_at" preenchido automaticamente.',
        status: 'published',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: responseBody.published_at,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(Date.parse(responseBody.published_at)).not.toBeNaN();
    });

    test('Content with "status" set to "deleted"', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Deveria negar a criação de um conteúdo direto em "deleted".',
        body: 'Não faz sentido criar conteúdos deletados.',
        status: 'deleted',
      });

      expect.soft(response.status).toBe(400);
      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: 'Não é possível criar um novo conteúdo diretamente com status "deleted".',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:CONTENT:VALIDATE_CREATE_SCHEMA:INVALID_STATUS',
        key: 'status',
        type: 'any.only',
      });
    });

    test('Content with "status" set to "firewall"', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Title.',
        body: 'Body',
        status: 'firewall',
      });

      expect.soft(response.status).toBe(400);
      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: 'Não é possível criar um novo conteúdo diretamente com status "firewall".',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:CONTENT:VALIDATE_CREATE_SCHEMA:INVALID_STATUS',
        key: 'status',
        type: 'any.only',
      });
    });

    test('Content with "status" set to "non_existent_status"', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Deveria negar.',
        body: 'Qualquer coisa.',
        status: 'inexisting_status',
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe(
        '"status" deve possuir um dos seguintes valores: "draft", "published", "deleted", "firewall".',
      );
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "status" set to Null', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Deveria negar.',
        body: 'Qualquer coisa.',
        status: null,
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe(
        '"status" deve possuir um dos seguintes valores: "draft", "published", "deleted", "firewall".',
      );
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "status" set a blank String', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Deveria negar.',
        body: 'Qualquer coisa.',
        status: '',
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe(
        '"status" deve possuir um dos seguintes valores: "draft", "published", "deleted", "firewall".',
      );
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "source_url" containing a valid HTTP URL', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'TabNews',
        body: 'Somos pessoas brutalmente exatas e empáticas, simultaneamente.',
        source_url: 'http://www.tabnews.com.br/',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'tabnews',
        title: 'TabNews',
        body: 'Somos pessoas brutalmente exatas e empáticas, simultaneamente.',
        status: 'draft',
        type: 'content',
        source_url: 'http://www.tabnews.com.br/',
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('Content with "source_url" containing a valid HTTPS URL', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'TabNews: Onde Tudo Começou',
        body: 'Aqui você vai encontrar POCs que foram criadas pela turma no início do projeto.',
        source_url: 'https://www.tabnews.com.br/museu',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'tabnews-onde-tudo-comecou',
        title: 'TabNews: Onde Tudo Começou',
        body: 'Aqui você vai encontrar POCs que foram criadas pela turma no início do projeto.',
        status: 'draft',
        type: 'content',
        source_url: 'https://www.tabnews.com.br/museu',
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('Content with "source_url" containing a valid long TLD', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Um baita de um Top-Level Domain',
        body: 'O maior TLD listado em http://data.iana.org/TLD/tlds-alpha-by-domain.txt possuía 24 caracteres',
        source_url: 'http://nic.xn--vermgensberatung-pwb/',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'um-baita-de-um-top-level-domain',
        title: 'Um baita de um Top-Level Domain',
        body: 'O maior TLD listado em http://data.iana.org/TLD/tlds-alpha-by-domain.txt possuía 24 caracteres',
        status: 'draft',
        type: 'content',
        source_url: 'http://nic.xn--vermgensberatung-pwb/',
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('Content with "source_url" containing a valid short URL', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'URL bem curta',
        body: 'Por exemplo o encurtador do Telegram',
        source_url: 'https://t.me',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'url-bem-curta',
        title: 'URL bem curta',
        body: 'Por exemplo o encurtador do Telegram',
        status: 'draft',
        type: 'content',
        source_url: 'https://t.me',
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('Content with "source_url" containing a invalid short TLD', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Um Top-Level Domain menor que o permitido',
        body: 'TLDs precisam ter pelo menos dois caracteres',
        source_url: 'https://invalidtl.d',
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe(
        '"source_url" deve possuir uma URL válida e utilizando os protocolos HTTP ou HTTPS.',
      );
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "source_url" containing a invalid long TLD', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Um Top-Level Domain maior que o permitido',
        body: 'O maior TLD listado em http://data.iana.org/TLD/tlds-alpha-by-domain.txt possuía 24 caracteres',
        source_url: 'http://tl.dcomvinteecincocaracteres',
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe(
        '"source_url" deve possuir uma URL válida e utilizando os protocolos HTTP ou HTTPS.',
      );
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "source_url" containing a not accepted Protocol', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Titulo',
        body: 'Corpo',
        source_url: 'ftp://www.tabnews.com.br',
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe(
        '"source_url" deve possuir uma URL válida e utilizando os protocolos HTTP ou HTTPS.',
      );
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "source_url" not containing a protocol', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Titulo',
        body: 'Corpo',
        source_url: 'www.tabnews.com.br',
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe(
        '"source_url" deve possuir uma URL válida e utilizando os protocolos HTTP ou HTTPS.',
      );
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "source_url" containing an incomplete URL', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Titulo',
        body: 'Corpo',
        source_url: 'https://lol.',
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe(
        '"source_url" deve possuir uma URL válida e utilizando os protocolos HTTP ou HTTPS.',
      );
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "source_url" containing query parameters', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Titulo',
        body: 'Corpo',
        source_url: 'https://www.tabnews.com.br/api/v1/contents?strategy=old',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'titulo',
        title: 'Titulo',
        body: 'Corpo',
        status: 'draft',
        type: 'content',
        source_url: 'https://www.tabnews.com.br/api/v1/contents?strategy=old',
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('Content with "source_url" containing fragment component', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Titulo',
        body: 'Corpo',
        source_url: 'http://www.tabnews.com.br/#:~:text=TabNews,-Status',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'titulo',
        title: 'Titulo',
        body: 'Corpo',
        status: 'draft',
        type: 'content',
        source_url: 'http://www.tabnews.com.br/#:~:text=TabNews,-Status',
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('Content with "source_url" containing an empty String', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Titulo',
        body: 'Corpo',
        source_url: '',
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"source_url" não pode estar em branco.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Content with "source_url" containing a Null value', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Titulo',
        body: 'Corpo',
        source_url: null,
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'titulo',
        title: 'Titulo',
        body: 'Corpo',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('"root" content with minimum valid data', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title:
          'Deveria conseguir! E o campo "slug" é opcional & 95,5% dos usuários não usam :) [áéíóú?@#$*<>|+-=.,;:_] <- (caracteres especiais)',
        body: 'Deveria conseguir, pois atualmente todos os usuários recebem todas as features relacionadas a "content".',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'deveria-conseguir-e-o-campo-slug-e-opcional-e-95-5-por-cento-dos-usuarios-nao-usam-aeiou-caracteres-especiais',
        title:
          'Deveria conseguir! E o campo "slug" é opcional & 95,5% dos usuários não usam :) [áéíóú?@#$*<>|+-=.,;:_] <- (caracteres especiais)',
        body: 'Deveria conseguir, pois atualmente todos os usuários recebem todas as features relacionadas a "content".',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();

      const contentInDatabase = await database.query({
        text: 'SELECT * FROM contents WHERE id = $1',
        values: [responseBody.id],
      });

      expect(contentInDatabase.rows[0].path).toStrictEqual([]);
    });

    test('"root" content with "title" containing custom slug special characters', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'under_score 5% é >= 1 e <= 10 email@dominio.com #item1,item2 a&b | a & b/mil',
        body: 'Body',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: 'under-score-5-por-cento-e-1-e-10-email-dominio-com-item1-item2-a-e-b-a-e-b-mil',
        title: 'under_score 5% é >= 1 e <= 10 email@dominio.com #item1,item2 a&b | a & b/mil',
        body: 'Body',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    test('"root" content with "title" not declared', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        body: 'Não deveria conseguir, falta o "title".',
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"title" é um campo obrigatório.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:CONTENT:CHECK_ROOT_CONTENT_TITLE:MISSING_TITLE');
    });

    test('"root" content with "title" containing Null value', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: null,
        body: 'Não deveria conseguir, falta o "title".',
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"title" é um campo obrigatório.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:CONTENT:CHECK_ROOT_CONTENT_TITLE:MISSING_TITLE');
    });

    test('"child" content with minimum valid data', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { responseBody: rootContent } = await contentsRequestBuilder.post({
        title: 'Conteúdo raiz',
        body: 'Body',
        status: 'published',
      });

      const { response, responseBody } = await contentsRequestBuilder.post({
        body: 'Deveria conseguir, pois atualmente todos os usuários recebem todas as features relacionadas a "content".',
        parent_id: rootContent.id,
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: rootContent.id,
        slug: responseBody.slug,
        title: null,
        body: 'Deveria conseguir, pois atualmente todos os usuários recebem todas as features relacionadas a "content".',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(uuidVersion(responseBody.slug)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();

      const contentInDatabase = await database.query({
        text: 'SELECT * FROM contents WHERE id = $1',
        values: [responseBody.id],
      });

      expect(contentInDatabase.rows[0].path).toStrictEqual([rootContent.id]);
    });

    test('"child" content with "title" containing Null value', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');

      const defaultUser = await contentsRequestBuilder.buildUser();
      const { responseBody: rootContent } = await contentsRequestBuilder.post({
        title: 'Conteúdo raiz',
        body: 'Body',
        status: 'published',
      });

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: null,
        body: 'Deveria criar um slug com UUID V4',
        parent_id: rootContent.id,
        status: 'published',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: rootContent.id,
        slug: responseBody.slug,
        title: null,
        body: 'Deveria criar um slug com UUID V4',
        status: 'published',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: responseBody.published_at,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(uuidVersion(responseBody.slug)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(Date.parse(responseBody.published_at)).not.toBeNaN();
    });

    test('"child" content with "title"', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { responseBody: rootContent } = await contentsRequestBuilder.post({
        title: 'Conteúdo raiz',
        body: 'Body',
        status: 'published',
      });

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'Título em um child content! O que vai acontecer?',
        body: 'Deveria criar um slug baseado no "title"',
        parent_id: rootContent.id,
        status: 'published',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: rootContent.id,
        slug: 'titulo-em-um-child-content-o-que-vai-acontecer',
        title: 'Título em um child content! O que vai acontecer?',
        body: 'Deveria criar um slug baseado no "title"',
        status: 'published',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: responseBody.published_at,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(Date.parse(responseBody.published_at)).not.toBeNaN();
    });

    test('"child" content with "parent_id" containing a Number', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        body: 'Não deveria conseguir, pois o "parent_id" abaixo está num formato errado',
        parent_id: 123456,
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"parent_id" deve ser do tipo String.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('"child" content with "parent_id" containing a blank string', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        body: 'Não deveria conseguir, pois o "parent_id" abaixo está num formato errado',
        parent_id: '',
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"parent_id" não pode estar em branco.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('"child" content with "parent_id" containing a malformatted UUIDV4', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        body: 'Não deveria conseguir, pois o "parent_id" abaixo está num formato errado',
        parent_id: 'isso não é um UUID válido',
      });

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"parent_id" deve possuir um token UUID na versão 4.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('"child" content with "parent_id" that does not exists', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        body: 'Não deveria conseguir, pois o "parent_id" aqui embaixo não existe.',
        parent_id: 'fe2e20f5-9296-45ea-9a0f-401866819b9e',
      });

      expect.soft(response.status).toBe(400);
      expect(responseBody).toStrictEqual({
        status_code: 400,
        name: 'ValidationError',
        message: 'Você está tentando criar um comentário em um conteúdo que não existe.',
        action: 'Utilize um "parent_id" que aponte para um conteúdo existente.',
        error_location_code: 'MODEL:CONTENT:CHECK_IF_PARENT_ID_EXISTS:NOT_FOUND',
        key: 'parent_id',
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
      });
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('Content with "title" containing 100.000 invalid characters', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: '!' + '\uffa0'.repeat(100_000) + '\uffa0!',
        body: 'With invalid title',
        slug: 'nodejs',
      });

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        status_code: 400,
        name: 'ValidationError',
        message: '"title" deve conter no máximo 255 caracteres.',
        action: 'Ajuste os dados enviados e tente novamente.',
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'title',
        type: 'string.max',
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('Content with "body" containing 100.000 invalid characters', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: 'With invalid body',
        body: '!' + '\u034f'.repeat(100_000) + '\u034f!',
        slug: 'nodejs',
      });

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        status_code: 400,
        name: 'ValidationError',
        message: '"body" deve conter no máximo 20000 caracteres.',
        action: 'Ajuste os dados enviados e tente novamente.',
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'body',
        type: 'string.max',
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('Content containing emojis', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { response, responseBody } = await contentsRequestBuilder.post({
        title: '🚀 🎉 🙃',
        body: '👍 🤔 🤷',
      });

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        owner_id: defaultUser.id,
        parent_id: null,
        slug: '8jagcdwn46jipcfmym',
        title: '🚀 🎉 🙃',
        body: '👍 🤔 🤷',
        status: 'draft',
        type: 'content',
        source_url: null,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
        published_at: null,
        deleted_at: null,
        tabcoins: 0,
        tabcoins_credit: 0,
        tabcoins_debit: 0,
        owner_username: defaultUser.username,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
    });

    describe('Notifications', () => {
      test('Create "root" content', async () => {
        await orchestrator.deleteAllEmails();

        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        await contentsRequestBuilder.buildUser();

        const { response } = await contentsRequestBuilder.post({
          title: 'Usuário não deveria receber email de notificação',
          body: 'Ele não deveria ser notificado sobre suas próprias criações',
          status: 'published',
        });

        expect.soft(response.status).toBe(201);
        expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);
      });

      test('My "root" content replied by myself', async () => {
        await orchestrator.deleteAllEmails();

        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        await contentsRequestBuilder.buildUser();

        const { responseBody: rootContent } = await contentsRequestBuilder.post({
          title: 'Conteúdo raiz',
          body: 'Body',
          status: 'published',
        });

        const { response, responseBody } = await contentsRequestBuilder.post({
          title: 'Novamente, não deveria receber notificação',
          body: 'Continua não sendo notificado sobre suas próprias criações',
          parent_id: rootContent.id,
          status: 'published',
        });

        expect.soft(response.status).toBe(201);
        expect(responseBody.parent_id).toBe(rootContent.id);
        expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);
      });

      test('My "root" content with short "title" replied by other user', async () => {
        await orchestrator.deleteAllEmails();

        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const firstUser = await contentsRequestBuilder.buildUser();

        const { responseBody: rootContent } = await contentsRequestBuilder.post({
          title: 'Título curto do conteúdo raiz',
          body: 'Body',
          status: 'published',
        });

        const secondUser = await contentsRequestBuilder.buildUser();

        const { response, responseBody } = await contentsRequestBuilder.post({
          body: 'Autor do `parent_id` deve receber notificação avisando que eu respondi o conteúdo dele.',
          parent_id: rootContent.id,
          status: 'published',
        });

        const getLastEmail = await orchestrator.waitForFirstEmail();

        const childContentUrl = `${orchestrator.webserverUrl}/${secondUser.username}/${responseBody.slug}`;

        expect.soft(response.status).toBe(201);
        expect(responseBody.parent_id).toBe(rootContent.id);
        expect(getLastEmail.recipients[0].includes(firstUser.email)).toBe(true);
        expect(getLastEmail.subject).toBe(`"${secondUser.username}" comentou em "Título curto do conteúdo raiz"`);
        expect(getLastEmail.text).toContain(firstUser.username);
        expect(getLastEmail.html).toContain(firstUser.username);
        expect(getLastEmail.text).toContain(secondUser.username);
        expect(getLastEmail.html).toContain(secondUser.username);
        expect(getLastEmail.text).toContain(rootContent.title);
        expect(getLastEmail.html).toContain(rootContent.title);
        expect(getLastEmail.text).toContain('respondeu à sua publicação');
        expect(getLastEmail.html).toContain('respondeu à sua publicação');
        expect(getLastEmail.text).toContain(childContentUrl);
        expect(getLastEmail.html).toContain(childContentUrl);
      });

      test('My "root" content with long "title" replied by other user', async () => {
        await orchestrator.deleteAllEmails();

        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const firstUser = await contentsRequestBuilder.buildUser();

        const { responseBody: rootContent } = await contentsRequestBuilder.post({
          title: 'Título longo do conteúdo raiz, deveria cortar o título para caber título no email',
          body: 'Body',
          status: 'published',
        });

        const secondUser = await contentsRequestBuilder.buildUser();

        const { response, responseBody } = await contentsRequestBuilder.post({
          body: 'Autor do `parent_id` deve receber notificação avisando que eu respondi o conteúdo dele.',
          parent_id: rootContent.id,
          status: 'published',
        });

        const getLastEmail = await orchestrator.waitForFirstEmail();

        const childContentUrl = `${orchestrator.webserverUrl}/${secondUser.username}/${responseBody.slug}`;

        expect.soft(response.status).toBe(201);
        expect(responseBody.parent_id).toBe(rootContent.id);
        expect(getLastEmail.recipients[0].includes(firstUser.email)).toBe(true);
        expect(getLastEmail.subject).toBe(
          `"${secondUser.username}" comentou em "Título longo do conteúdo raiz, deveria cortar o título..."`,
        );
        expect(getLastEmail.text).toContain(rootContent.title);
        expect(getLastEmail.html).toContain(rootContent.title);
        expect(getLastEmail.text).toContain(`Olá, ${firstUser.username}`);
        expect(getLastEmail.html).toContain(`Olá, ${firstUser.username}`);
        expect(getLastEmail.text).toContain(`"${secondUser.username}" respondeu à sua publicação`);
        expect(getLastEmail.html).toContain(secondUser.username);
        expect(getLastEmail.html).toContain('respondeu à sua publicação');
        expect(getLastEmail.text).toContain(childContentUrl);
        expect(getLastEmail.html).toContain(childContentUrl);
      });

      test('My "root" content replied by other user, but the reply does not have a "published" status', async () => {
        await orchestrator.deleteAllEmails();

        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        await contentsRequestBuilder.buildUser();

        const { responseBody: rootContent } = await contentsRequestBuilder.post({
          title: 'Título do conteúdo raiz',
          body: 'Body',
          status: 'published',
        });

        await contentsRequestBuilder.buildUser();

        const { response, responseBody } = await contentsRequestBuilder.post({
          body: 'Autor do `parent_id` não deve receber notificação de resposta que não está pública',
          parent_id: rootContent.id,
          status: 'draft',
        });
        expect.soft(response.status).toBe(201);

        expect(responseBody.parent_id).toBe(rootContent.id);
        expect(responseBody.owner_id).not.toBe(rootContent.owner_id);
        expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);
      });

      test('My "child" content replied by other user', async () => {
        await orchestrator.deleteAllEmails();

        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const firstUser = await contentsRequestBuilder.buildUser();

        const { responseBody: rootContent } = await contentsRequestBuilder.post({
          title: 'Testando resposta ao conteúdo child',
          body: 'Body.',
          status: 'published',
        });

        const secondUser = await contentsRequestBuilder.buildUser();

        const { responseBody: childContentFromSecondUser } = await contentsRequestBuilder.post({
          parent_id: rootContent.id,
          body: 'Este conteúdo será respondido pelo "firstUser" no passo seguinte.',
          status: 'published',
        });

        await contentsRequestBuilder.setUser(firstUser);

        const { response, responseBody } = await contentsRequestBuilder.post({
          body: 'Este conteúdo deverá disparar uma notificação ao "secondUser',
          parent_id: childContentFromSecondUser.id,
          status: 'published',
        });

        const getLastEmail = await orchestrator.waitForNthEmail(2);

        const childContentUrl = `${orchestrator.webserverUrl}/${firstUser.username}/${responseBody.slug}`;

        expect.soft(response.status).toBe(201);
        expect(responseBody.parent_id).toBe(childContentFromSecondUser.id);
        expect(getLastEmail.recipients[0].includes(secondUser.email)).toBe(true);
        expect(getLastEmail.subject).toBe(`"${firstUser.username}" comentou em "Testando resposta ao conteúdo child"`);
        expect(getLastEmail.text).toContain(`Olá, ${secondUser.username}`);
        expect(getLastEmail.html).toContain(`Olá, ${secondUser.username}`);
        expect(getLastEmail.text).toContain(rootContent.title);
        expect(getLastEmail.html).toContain(rootContent.title);
        expect(getLastEmail.text).toContain(`"${firstUser.username}" respondeu ao seu comentário na publicação`);
        expect(getLastEmail.html).toContain(firstUser.username);
        expect(getLastEmail.html).toContain('respondeu ao seu comentário na publicação');
        expect(getLastEmail.text).toContain(childContentUrl);
        expect(getLastEmail.html).toContain(childContentUrl);
      });

      test('My "child" content replied by other user, but "root" with "deleted" status', async () => {
        await orchestrator.deleteAllEmails();

        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const firstUser = await contentsRequestBuilder.buildUser();

        const { responseBody: rootContent } = await contentsRequestBuilder.post({
          title: 'Testando resposta ao conteúdo child',
          body: 'Body',
          status: 'published',
        });

        const secondUser = await contentsRequestBuilder.buildUser();

        const { responseBody: childContentFromSecondUser } = await contentsRequestBuilder.post({
          parent_id: rootContent.id,
          body: 'Este conteúdo será respondido pelo "firstUser" no passo seguinte.',
          status: 'published',
        });

        await orchestrator.updateContent(rootContent.id, {
          status: 'deleted',
        });

        await contentsRequestBuilder.setUser(firstUser);

        const { response, responseBody } = await contentsRequestBuilder.post({
          body: 'Este conteúdo deverá disparar uma notificação ao "secondUser',
          parent_id: childContentFromSecondUser.id,
          status: 'published',
        });

        const getLastEmail = await orchestrator.waitForNthEmail(2);

        const childContentUrl = `${orchestrator.webserverUrl}/${firstUser.username}/${responseBody.slug}`;

        expect.soft(response.status).toBe(201);
        expect(responseBody.parent_id).toBe(childContentFromSecondUser.id);
        expect(getLastEmail.recipients[0].includes(secondUser.email)).toBe(true);
        expect(getLastEmail.subject).toBe(`"${firstUser.username}" comentou em "[Não disponível]"`);
        expect(getLastEmail.text).toContain(`Olá, ${secondUser.username}`);
        expect(getLastEmail.html).toContain(`Olá, ${secondUser.username}`);
        expect(getLastEmail.text).not.toContain(rootContent.title);
        expect(getLastEmail.html).not.toContain(rootContent.title);
        expect(getLastEmail.text).toContain(
          `"${firstUser.username}" respondeu ao seu comentário na publicação "[Não disponível]"`,
        );
        expect(getLastEmail.html).toContain(firstUser.username);
        expect(getLastEmail.html).toContain('respondeu ao seu comentário na publicação');
        expect(getLastEmail.html).toContain('[Não disponível]');
        expect(getLastEmail.text).toContain(childContentUrl);
        expect(getLastEmail.html).toContain(childContentUrl);
      });

      test('My "root" content replied by other user (with "notifications" disabled)', async () => {
        await orchestrator.deleteAllEmails();

        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const userRequestBuilder = new RequestBuilder('/api/v1/user');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');

        const firstUser = await contentsRequestBuilder.buildUser();
        await userRequestBuilder.setUser(firstUser);
        await usersRequestBuilder.setUser(firstUser);

        // 1) CHECK IF BY DEFAULT FIRST USER HAS `notifications` ENABLED
        const { responseBody: userGetResponseCheck1Body } = await userRequestBuilder.get();

        expect(userGetResponseCheck1Body.notifications).toBe(true);

        // 2) DISABLE NOTIFICATIONS FOR FIRST USER
        const { response: userPatchResponse1 } = await usersRequestBuilder.patch(`/${firstUser.username}`, {
          notifications: false,
        });

        expect.soft(userPatchResponse1.status).toBe(200);

        const { responseBody: userGetResponseCheck2Body } = await userRequestBuilder.get();

        expect(userGetResponseCheck2Body.notifications).toBe(false);

        // 3) CREATE A CONTENT WITH FIRST USER
        const { responseBody: rootContent } = await contentsRequestBuilder.post({
          title: 'Testando sistema de notificação',
          body: 'Body',
          status: 'published',
        });

        // 4) REPLY TO CONTENT WITH SECOND USER
        const { response: contentResponse1 } = await contentsRequestBuilder.post({
          body: 'Autor do `parent_id` NÃO deve receber notificação avisando que eu respondi o conteúdo dele.',
          parent_id: rootContent.id,
          status: 'published',
        });

        expect.soft(contentResponse1.status).toBe(201);

        // 5) CHECK IF FIRST USER RECEIVED ANY EMAIL
        expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);

        // 6) ENABLE NOTIFICATIONS FOR FIRST USER
        const { response: userPatchResponse2 } = await usersRequestBuilder.patch(`/${firstUser.username}`, {
          notifications: true,
        });

        expect.soft(userPatchResponse2.status).toBe(200);

        // 7) REPLY AGAIN TO CONTENT WITH SECOND USER
        const secondUser = await contentsRequestBuilder.buildUser();

        const { response: contentResponse2, responseBody: contentResponse2Body } = await contentsRequestBuilder.post({
          body: 'Agora sim autor do `parent_id` deveria receber notificação.',
          parent_id: rootContent.id,
          status: 'published',
        });

        expect.soft(contentResponse2.status).toBe(201);

        // 8) CHECK IF FIRST USER RECEIVED ANY EMAIL
        const getLastEmail2 = await orchestrator.waitForFirstEmail();

        const childContentUrl = `${orchestrator.webserverUrl}/${secondUser.username}/${contentResponse2Body.slug}`;

        expect(getLastEmail2.recipients[0].includes(firstUser.email)).toBe(true);
        expect(getLastEmail2.subject).toBe(`"${secondUser.username}" comentou em "Testando sistema de notificação"`);
        expect(getLastEmail2.text).toContain(firstUser.username);
        expect(getLastEmail2.text).toContain(secondUser.username);
        expect(getLastEmail2.text).toContain(rootContent.title);
        expect(getLastEmail2.text).toContain('respondeu à sua publicação');
        expect(getLastEmail2.text).toContain(childContentUrl);
        expect(getLastEmail2.html).toContain(firstUser.username);
        expect(getLastEmail2.html).toContain(secondUser.username);
        expect(getLastEmail2.html).toContain(rootContent.title);
        expect(getLastEmail2.html).toContain('respondeu à sua publicação');
        expect(getLastEmail2.html).toContain(childContentUrl);
      });
    });

    describe('Stream Response', () => {
      test('Reply with body containing 20k characters', async () => {
        await orchestrator.deleteAllEmails();

        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const firstUser = await contentsRequestBuilder.buildUser();

        const { responseBody: rootContent } = await contentsRequestBuilder.post({
          title: 'Título do conteúdo raiz',
          body: 'Body',
          status: 'published',
        });

        contentsRequestBuilder.buildHeaders({
          Accept: 'application/json, application/x-ndjson',
        });
        const secondUser = await contentsRequestBuilder.buildUser();

        const { response, responseBody } = await contentsRequestBuilder.post({
          body: '100 characters repeated in 200 linessssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\n'.repeat(
            200,
          ),
          parent_id: rootContent.id,
          status: 'published',
        });

        expect(response.ok).toBe(true);
        expect.soft(response.status).toBe(201);
        expect(response.headers.get('content-Type')).toBe('application/x-ndjson');

        const getLastEmail = await orchestrator.waitForFirstEmail();

        const childContentUrl = `${orchestrator.webserverUrl}/${secondUser.username}/${responseBody.slug}`;

        expect(responseBody.body).toBe(
          '100 characters repeated in 200 linessssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\n'
            .repeat(200)
            .slice(0, 19999),
        );
        expect(responseBody.parent_id).toBe(rootContent.id);
        expect(getLastEmail.recipients[0].includes(firstUser.email)).toBe(true);
        expect(getLastEmail.subject).toBe(`"${secondUser.username}" comentou em "Título do conteúdo raiz"`);
        expect(getLastEmail.text).toContain(firstUser.username);
        expect(getLastEmail.html).toContain(firstUser.username);
        expect(getLastEmail.text).toContain(secondUser.username);
        expect(getLastEmail.html).toContain(secondUser.username);
        expect(getLastEmail.text).toContain(rootContent.title);
        expect(getLastEmail.html).toContain(rootContent.title);
        expect(getLastEmail.text).toContain('respondeu à sua publicação');
        expect(getLastEmail.html).toContain('respondeu à sua publicação');
        expect(getLastEmail.text).toContain(childContentUrl);
        expect(getLastEmail.html).toContain(childContentUrl);
      });
    });

    describe('TabCoins', () => {
      test('"root" content with "draft" status', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();

        const { responseBody } = await contentsRequestBuilder.post({
          title: 'Title',
          body: relevantBody,
        });

        expect(responseBody.tabcoins).toBe(0);

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcoins).toBe(0);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('"root" content with "published" status', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();

        await orchestrator.createPrestige(defaultUser.id);

        const { responseBody } = await contentsRequestBuilder.post({
          title: 'Title',
          body: relevantBody,
          status: 'published',
        });

        expect(responseBody.tabcoins).toBe(1);

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcoins).toBe(2);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('"child" content with "draft" status', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        await contentsRequestBuilder.buildUser();

        const { responseBody: rootContent } = await contentsRequestBuilder.post({
          title: 'Root',
          body: relevantBody,
          status: 'published',
        });

        const secondUser = await contentsRequestBuilder.buildUser();

        const { responseBody } = await contentsRequestBuilder.post({
          body: relevantBody,
          parent_id: rootContent.id,
          status: 'draft',
        });

        expect(responseBody.tabcoins).toBe(0);

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${secondUser.username}`);

        expect(userResponseBody.tabcoins).toBe(0);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('"child" content with "published" status (same user)', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();

        await orchestrator.createPrestige(defaultUser.id);

        // User will receive tabcoins for publishing a root content.
        const { responseBody: rootContent } = await contentsRequestBuilder.post({
          title: 'Root',
          body: relevantBody,
          status: 'published',
        });

        // But user will not receive additional tabcoins for
        // publishing a child content to itself.
        const { responseBody } = await contentsRequestBuilder.post({
          body: relevantBody,
          parent_id: rootContent.id,
          status: 'published',
        });

        expect(responseBody.tabcoins).toBe(0);

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcoins).toBe(2);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('"child" content with "published" status (different user)', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        await contentsRequestBuilder.buildUser();

        const { responseBody: rootContent } = await contentsRequestBuilder.post({
          title: 'Root',
          body: relevantBody,
          status: 'published',
        });

        const secondUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(secondUser.id);

        const { responseBody } = await contentsRequestBuilder.post({
          body: relevantBody,
          parent_id: rootContent.id,
          status: 'published',
        });

        expect(responseBody.tabcoins).toBe(1);

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${secondUser.username}`);

        expect(userResponseBody.tabcoins).toBe(2);
        expect(userResponseBody.tabcash).toBe(0);
      });
    });

    describe('Prestige', () => {
      test('should not be able to create "root" content with negative prestige by more than threshold', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const defaultUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(defaultUser.id, { rootPrestigeNumerator: -1, rootPrestigeDenominator: 2 });

        const { response, responseBody } = await contentsRequestBuilder.post({
          title: 'Title',
          body: relevantBody,
          status: 'published',
        });

        expect.soft(response.status).toBe(403);
        expect.soft(responseBody.status_code).toBe(403);
        expect(responseBody.name).toBe('ForbiddenError');
        expect(responseBody.message).toBe(
          'Não é possível publicar porque há outras publicações mal avaliadas que ainda não foram excluídas.',
        );
        expect(responseBody.action).toBe(
          'Exclua seus conteúdos mais recentes que estiverem classificados como não relevantes.',
        );
        expect(uuidVersion(responseBody.error_id)).toBe(4);
        expect(uuidVersion(responseBody.request_id)).toBe(4);
        expect(responseBody.error_location_code).toBe('MODEL:CONTENT:CREDIT_OR_DEBIT_TABCOINS:NEGATIVE_USER_EARNINGS');
      });

      test('should not be able to create "child" content with negative prestige by more than threshold', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        await contentsRequestBuilder.buildUser();

        const { responseBody: rootContent } = await contentsRequestBuilder.post({
          title: 'Conteúdo raiz',
          body: 'Body',
          status: 'published',
        });

        const secondUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(secondUser.id, { childPrestigeNumerator: -5, childPrestigeDenominator: 1 });

        const { response, responseBody } = await contentsRequestBuilder.post({
          body: 'Não deveria conseguir por possuir comentários mal avaliados.',
          parent_id: rootContent.id,
          status: 'published',
        });

        expect.soft(response.status).toBe(403);
        expect.soft(responseBody.status_code).toBe(403);
        expect(responseBody.name).toBe('ForbiddenError');
        expect(responseBody.message).toBe(
          'Não é possível publicar porque há outras publicações mal avaliadas que ainda não foram excluídas.',
        );
        expect(responseBody.action).toBe(
          'Exclua seus conteúdos mais recentes que estiverem classificados como não relevantes.',
        );
        expect(uuidVersion(responseBody.error_id)).toBe(4);
        expect(uuidVersion(responseBody.request_id)).toBe(4);
        expect(responseBody.error_location_code).toBe('MODEL:CONTENT:CREDIT_OR_DEBIT_TABCOINS:NEGATIVE_USER_EARNINGS');
      });

      test('Should be able to create "root" content with negative prestige at the threshold', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(defaultUser.id, { rootPrestigeNumerator: -9, rootPrestigeDenominator: 20 });

        const { response, responseBody } = await contentsRequestBuilder.post({
          title: 'Title',
          body: relevantBody,
          status: 'published',
        });

        expect.soft(response.status).toBe(201);

        expect(responseBody).toStrictEqual({
          id: responseBody.id,
          owner_id: defaultUser.id,
          parent_id: null,
          slug: 'title',
          title: 'Title',
          body: relevantBody,
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: responseBody.created_at,
          updated_at: responseBody.updated_at,
          published_at: responseBody.published_at,
          deleted_at: null,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: defaultUser.username,
        });

        expect(uuidVersion(responseBody.id)).toBe(4);
        expect(Date.parse(responseBody.created_at)).not.toBeNaN();
        expect(Date.parse(responseBody.updated_at)).not.toBeNaN();

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcoins).toBe(0);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('Should be able to create "child" content with negative prestige at the threshold', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        await contentsRequestBuilder.buildUser();

        const { responseBody: rootContent } = await contentsRequestBuilder.post({
          title: 'Conteúdo raiz',
          body: 'Body',
          status: 'published',
        });

        const secondUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(secondUser.id, { childPrestigeNumerator: -6, childPrestigeDenominator: 6 });

        const { response, responseBody } = await contentsRequestBuilder.post({
          body: 'Deveria conseguir mesmo com alguns comentários mal avaliados.',
          parent_id: rootContent.id,
          status: 'published',
        });

        expect.soft(response.status).toBe(201);

        expect(responseBody).toStrictEqual({
          id: responseBody.id,
          owner_id: secondUser.id,
          parent_id: rootContent.id,
          slug: responseBody.slug,
          title: null,
          body: 'Deveria conseguir mesmo com alguns comentários mal avaliados.',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: responseBody.created_at,
          updated_at: responseBody.updated_at,
          published_at: responseBody.published_at,
          deleted_at: null,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: secondUser.username,
        });

        expect(uuidVersion(responseBody.id)).toBe(4);
        expect(Date.parse(responseBody.created_at)).not.toBeNaN();
        expect(Date.parse(responseBody.updated_at)).not.toBeNaN();

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${secondUser.username}`);

        expect(userResponseBody.tabcoins).toBe(0);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('Should not be able to earn tabcoins if it has less than threshold prestige in "root" content', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(defaultUser.id, { rootPrestigeNumerator: 1, rootPrestigeDenominator: 10 });

        const { response, responseBody } = await contentsRequestBuilder.post({
          title: 'Title',
          body: relevantBody,
          status: 'published',
        });

        expect.soft(response.status).toBe(201);

        expect(responseBody).toStrictEqual({
          id: responseBody.id,
          owner_id: defaultUser.id,
          parent_id: null,
          slug: 'title',
          title: 'Title',
          body: relevantBody,
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: responseBody.created_at,
          updated_at: responseBody.updated_at,
          published_at: responseBody.published_at,
          deleted_at: null,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: defaultUser.username,
        });

        expect(uuidVersion(responseBody.id)).toBe(4);
        expect(Date.parse(responseBody.created_at)).not.toBeNaN();
        expect(Date.parse(responseBody.updated_at)).not.toBeNaN();

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcoins).toBe(0);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('Should not be able to earn tabcoins if it has less than threshold prestige in "child" content', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        await contentsRequestBuilder.buildUser();

        const { responseBody: rootContent } = await contentsRequestBuilder.post({
          title: 'Conteúdo raiz',
          body: 'Body',
          status: 'published',
        });

        const secondUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(secondUser.id, { childPrestigeNumerator: -1 });

        const { response, responseBody } = await contentsRequestBuilder.post({
          body: 'Deve conseguir publicar, mas não deve ganhar TabCoins sem prestígio suficiente.',
          parent_id: rootContent.id,
          status: 'published',
        });

        expect.soft(response.status).toBe(201);

        expect(responseBody).toStrictEqual({
          id: responseBody.id,
          owner_id: secondUser.id,
          parent_id: rootContent.id,
          slug: responseBody.slug,
          title: null,
          body: 'Deve conseguir publicar, mas não deve ganhar TabCoins sem prestígio suficiente.',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: responseBody.created_at,
          updated_at: responseBody.updated_at,
          published_at: responseBody.published_at,
          deleted_at: null,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: secondUser.username,
        });

        expect(uuidVersion(responseBody.id)).toBe(4);
        expect(Date.parse(responseBody.created_at)).not.toBeNaN();
        expect(Date.parse(responseBody.updated_at)).not.toBeNaN();

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${secondUser.username}`);

        expect(userResponseBody.tabcoins).toBe(0);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('Should be able to earn tabcoins if it has minimum prestige in "root" content', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(defaultUser.id, { rootPrestigeNumerator: 2, rootPrestigeDenominator: 10 });

        const { response, responseBody } = await contentsRequestBuilder.post({
          title: 'Title',
          body: relevantBody,
          status: 'published',
        });

        expect.soft(response.status).toBe(201);

        expect(responseBody).toStrictEqual({
          id: responseBody.id,
          owner_id: defaultUser.id,
          parent_id: null,
          slug: 'title',
          title: 'Title',
          body: relevantBody,
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: responseBody.created_at,
          updated_at: responseBody.updated_at,
          published_at: responseBody.published_at,
          deleted_at: null,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: defaultUser.username,
        });

        expect(uuidVersion(responseBody.id)).toBe(4);
        expect(Date.parse(responseBody.created_at)).not.toBeNaN();
        expect(Date.parse(responseBody.updated_at)).not.toBeNaN();

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcoins).toBe(1);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('Should be able to earn tabcoins if it has minimum prestige in "child" content', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        await contentsRequestBuilder.buildUser();

        const { responseBody: rootContent } = await contentsRequestBuilder.post({
          title: 'Conteúdo raiz',
          body: 'Body',
          status: 'published',
        });

        const secondUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(secondUser.id, { childPrestigeNumerator: 0, childPrestigeDenominator: 6 });

        const { response, responseBody } = await contentsRequestBuilder.post({
          body: relevantBody,
          parent_id: rootContent.id,
          status: 'published',
        });

        expect.soft(response.status).toBe(201);

        expect(responseBody).toStrictEqual({
          id: responseBody.id,
          owner_id: secondUser.id,
          parent_id: rootContent.id,
          slug: responseBody.slug,
          title: null,
          body: relevantBody,
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: responseBody.created_at,
          updated_at: responseBody.updated_at,
          published_at: responseBody.published_at,
          deleted_at: null,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: secondUser.username,
        });

        expect(uuidVersion(responseBody.id)).toBe(4);
        expect(Date.parse(responseBody.created_at)).not.toBeNaN();
        expect(Date.parse(responseBody.updated_at)).not.toBeNaN();

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${secondUser.username}`);

        expect(userResponseBody.tabcoins).toBe(1);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('Should be able to publish even with a negative ad balance', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();

        vi.useFakeTimers({
          now: new Date(Date.now() - 1000 * 60 * 60 * 24 * 3), // 3 days ago
        });

        await orchestrator.createBalance({
          balanceType: 'user:tabcash',
          recipientId: defaultUser.id,
          amount: defaultTabCashForAdCreation,
        });

        const adContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: 'Ad Title',
          status: 'published',
          body: relevantBody,
          type: 'ad',
        });

        await orchestrator.createRate(adContent, -999);

        vi.useRealTimers();

        const rootContent = await contentsRequestBuilder.post({
          title: 'Title',
          body: relevantBody,
          status: 'published',
        });
        expect.soft(rootContent.response.status).toBe(201);

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);
        expect(userResponseBody.tabcoins).toBe(-999);
        expect(userResponseBody.tabcash).toBe(0);

        const otherUser = await orchestrator.createUser();
        const secondRootContent = await orchestrator.createContent({
          owner_id: otherUser.id,
          title: 'Title',
          body: 'Body',
          status: 'published',
        });

        const childContent = await contentsRequestBuilder.post({
          parent_id: secondRootContent.id,
          body: relevantBody,
          status: 'published',
        });
        expect.soft(childContent.response.status).toBe(201);

        const { responseBody: userResponseBody2 } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody2.tabcoins).toBe(-999);
        expect(userResponseBody2.tabcash).toBe(0);
      });

      test('Should not earn TabCoins even with a positive ad balance', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();

        vi.useFakeTimers({
          now: new Date(Date.now() - 1000 * 60 * 60 * 24 * 3), // 3 days ago
        });

        await orchestrator.createBalance({
          balanceType: 'user:tabcash',
          recipientId: defaultUser.id,
          amount: defaultTabCashForAdCreation,
        });

        const adContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: 'Ad Title',
          status: 'published',
          body: relevantBody,
          type: 'ad',
        });

        await orchestrator.createRate(adContent, 999);

        vi.useRealTimers();

        const rootContent = await contentsRequestBuilder.post({
          title: 'Title',
          body: relevantBody,
          status: 'published',
        });
        expect.soft(rootContent.response.status).toBe(201);

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcoins).toBe(999);
        expect(userResponseBody.tabcash).toBe(0);

        const otherUser = await orchestrator.createUser();
        const secondRootContent = await orchestrator.createContent({
          owner_id: otherUser.id,
          title: 'Title',
          body: 'Body',
          status: 'published',
        });

        const childContent = await contentsRequestBuilder.post({
          parent_id: secondRootContent.id,
          body: relevantBody,
          status: 'published',
        });
        expect.soft(childContent.response.status).toBe(201);

        const { responseBody: userResponseBody2 } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody2.tabcoins).toBe(999);
        expect(userResponseBody2.tabcash).toBe(0);
      });
    });

    describe('No minimum amount of relevant words', () => {
      test('should not be able to create "root" content without prestige', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const defaultUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(defaultUser.id, { rootPrestigeNumerator: -6, rootPrestigeDenominator: 10 });

        const { response, responseBody } = await contentsRequestBuilder.post({
          title: 'Title',
          body: 'Body',
          status: 'published',
        });

        expect.soft(response.status).toBe(403);
        expect.soft(responseBody.status_code).toBe(403);
        expect(responseBody.name).toBe('ForbiddenError');
        expect(responseBody.message).toBe(
          'Não é possível publicar porque há outras publicações mal avaliadas que ainda não foram excluídas.',
        );
        expect(responseBody.action).toBe(
          'Exclua seus conteúdos mais recentes que estiverem classificados como não relevantes.',
        );
        expect(uuidVersion(responseBody.error_id)).toBe(4);
        expect(uuidVersion(responseBody.request_id)).toBe(4);
        expect(responseBody.error_location_code).toBe('MODEL:CONTENT:CREDIT_OR_DEBIT_TABCOINS:NEGATIVE_USER_EARNINGS');
      });

      test('Should not be able to earn tabcoins in "root" content', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(defaultUser.id);

        const { response, responseBody } = await contentsRequestBuilder.post({
          title: 'Title',
          body: 'Body with no minimum amount of relevant words',
          status: 'published',
        });

        expect.soft(response.status).toBe(201);

        expect(responseBody).toStrictEqual({
          id: responseBody.id,
          owner_id: defaultUser.id,
          parent_id: null,
          slug: 'title',
          title: 'Title',
          body: 'Body with no minimum amount of relevant words',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: responseBody.created_at,
          updated_at: responseBody.updated_at,
          published_at: responseBody.published_at,
          deleted_at: null,
          tabcoins: 0,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: defaultUser.username,
        });

        expect(uuidVersion(responseBody.id)).toBe(4);
        expect(Date.parse(responseBody.created_at)).not.toBeNaN();
        expect(Date.parse(responseBody.updated_at)).not.toBeNaN();

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcoins).toBe(0);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('Should not be able to earn tabcoins in "child" content', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        await contentsRequestBuilder.buildUser();

        const { responseBody: rootContent } = await contentsRequestBuilder.post({
          title: 'Conteúdo raiz',
          body: 'Body',
          status: 'published',
        });

        const secondUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(secondUser.id);

        const { response, responseBody } = await contentsRequestBuilder.post({
          body: 'Body with no minimum amount of relevant words',
          parent_id: rootContent.id,
          status: 'published',
        });

        expect.soft(response.status).toBe(201);

        expect(responseBody).toStrictEqual({
          id: responseBody.id,
          owner_id: secondUser.id,
          parent_id: rootContent.id,
          slug: responseBody.slug,
          title: null,
          body: 'Body with no minimum amount of relevant words',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: responseBody.created_at,
          updated_at: responseBody.updated_at,
          published_at: responseBody.published_at,
          deleted_at: null,
          tabcoins: 0,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: secondUser.username,
        });

        expect(uuidVersion(responseBody.id)).toBe(4);
        expect(Date.parse(responseBody.created_at)).not.toBeNaN();
        expect(Date.parse(responseBody.updated_at)).not.toBeNaN();

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${secondUser.username}`);

        expect(userResponseBody.tabcoins).toBe(0);
        expect(userResponseBody.tabcash).toBe(0);
      });
    });

    describe('With minimal amount of relevant words', () => {
      test('Should be able to earn tabcoins in "root" content', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(defaultUser.id, { rootPrestigeNumerator: 2, rootPrestigeDenominator: 10 });

        const { response, responseBody } = await contentsRequestBuilder.post({
          title: 'Title',
          body: relevantBody,
          status: 'published',
        });

        expect.soft(response.status).toBe(201);

        expect(responseBody).toStrictEqual({
          id: responseBody.id,
          owner_id: defaultUser.id,
          parent_id: null,
          slug: 'title',
          title: 'Title',
          body: relevantBody,
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: responseBody.created_at,
          updated_at: responseBody.updated_at,
          published_at: responseBody.published_at,
          deleted_at: null,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: defaultUser.username,
        });

        expect(uuidVersion(responseBody.id)).toBe(4);
        expect(Date.parse(responseBody.created_at)).not.toBeNaN();
        expect(Date.parse(responseBody.updated_at)).not.toBeNaN();

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcoins).toBe(1);
        expect(userResponseBody.tabcash).toBe(0);
      });

      test('Should be able to earn tabcoins in "child" content', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        await contentsRequestBuilder.buildUser();

        const { responseBody: rootContent } = await contentsRequestBuilder.post({
          title: 'Conteúdo raiz',
          body: 'Body',
          status: 'published',
        });

        const secondUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(secondUser.id, { childPrestigeNumerator: 0, childPrestigeDenominator: 6 });

        const { response, responseBody } = await contentsRequestBuilder.post({
          body: relevantBody,
          parent_id: rootContent.id,
          status: 'published',
        });

        expect.soft(response.status).toBe(201);

        expect(responseBody).toStrictEqual({
          id: responseBody.id,
          owner_id: secondUser.id,
          parent_id: rootContent.id,
          slug: responseBody.slug,
          title: null,
          body: relevantBody,
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: responseBody.created_at,
          updated_at: responseBody.updated_at,
          published_at: responseBody.published_at,
          deleted_at: null,
          tabcoins: 1,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: secondUser.username,
        });

        expect(uuidVersion(responseBody.id)).toBe(4);
        expect(Date.parse(responseBody.created_at)).not.toBeNaN();
        expect(Date.parse(responseBody.updated_at)).not.toBeNaN();

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${secondUser.username}`);

        expect(userResponseBody.tabcoins).toBe(1);
        expect(userResponseBody.tabcash).toBe(0);
      });
    });

    describe('With "type: ad"', () => {
      test('Should be able to create "ad" type content', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const defaultUser = await contentsRequestBuilder.buildUser();

        await orchestrator.createBalance({
          balanceType: 'user:tabcash',
          recipientId: defaultUser.id,
          amount: defaultTabCashForAdCreation,
        });

        const { response, responseBody } = await contentsRequestBuilder.post({
          title: 'Ad title',
          body: 'Ad body',
          status: 'published',
          type: 'ad',
          source_url: 'https://www.tabnews.com.br',
        });

        expect.soft(response.status).toBe(201);

        expect(responseBody).toStrictEqual({
          id: responseBody.id,
          owner_id: defaultUser.id,
          parent_id: null,
          slug: 'ad-title',
          title: 'Ad title',
          body: 'Ad body',
          status: 'published',
          type: 'ad',
          source_url: 'https://www.tabnews.com.br',
          created_at: responseBody.created_at,
          updated_at: responseBody.updated_at,
          published_at: responseBody.published_at,
          deleted_at: null,
          tabcoins: 0,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          tabcash: defaultTabCashForAdCreation,
          owner_username: defaultUser.username,
        });

        expect(uuidVersion(responseBody.id)).toBe(4);
        expect(Date.parse(responseBody.created_at)).not.toBeNaN();
        expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      });

      test(`Should debit ${defaultTabCashForAdCreation} TabCash`, async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();

        await orchestrator.createBalance({
          balanceType: 'user:tabcash',
          recipientId: defaultUser.id,
          amount: 1_000 + defaultTabCashForAdCreation,
        });

        const { response: contentResponse, responseBody: contentResponseBody } = await contentsRequestBuilder.post({
          title: 'Ad title',
          body: 'Ad body',
          status: 'published',
          type: 'ad',
        });

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect.soft(contentResponse.status).toBe(201);
        expect(contentResponseBody.tabcash).toBe(defaultTabCashForAdCreation);
        expect(userResponseBody.tabcash).toBe(1_000);
      });

      test(`Should not be able to create without enough TabCash`, async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();

        await orchestrator.createBalance({
          balanceType: 'user:tabcash',
          recipientId: defaultUser.id,
          amount: defaultTabCashForAdCreation - 1,
        });

        const { response, responseBody } = await contentsRequestBuilder.post({
          title: 'Ad title',
          body: 'Ad body',
          status: 'published',
          type: 'ad',
        });

        expect.soft(response.status).toBe(422);

        expect(responseBody).toStrictEqual({
          name: 'UnprocessableEntityError',
          message: 'Não foi possível criar a publicação.',
          action: `Você precisa de pelo menos ${defaultTabCashForAdCreation} TabCash para realizar esta ação.`,
          status_code: 422,
          error_id: responseBody.error_id,
          request_id: responseBody.request_id,
          error_location_code: 'MODEL:CONTENT:UPDATE_TABCASH:NOT_ENOUGH',
        });

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect(userResponseBody.tabcash).toBe(defaultTabCashForAdCreation - 1);
      });

      test('Should not be able to create with "parent_id"', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const defaultUser = await contentsRequestBuilder.buildUser();

        const { responseBody: rootContent } = await contentsRequestBuilder.post({
          title: 'Root title',
          body: 'Root body',
          status: 'published',
        });

        await orchestrator.createBalance({
          balanceType: 'user:tabcash',
          recipientId: defaultUser.id,
          amount: defaultTabCashForAdCreation,
        });

        const { response, responseBody } = await contentsRequestBuilder.post({
          title: 'Ad title',
          body: 'Ad body',
          status: 'published',
          type: 'ad',
          parent_id: rootContent.id,
        });

        expect.soft(response.status).toBe(201);

        expect(responseBody).toStrictEqual({
          id: responseBody.id,
          owner_id: defaultUser.id,
          parent_id: rootContent.id,
          slug: 'ad-title',
          title: 'Ad title',
          body: 'Ad body',
          status: 'published',
          type: 'content',
          source_url: null,
          created_at: responseBody.created_at,
          updated_at: responseBody.updated_at,
          published_at: responseBody.published_at,
          deleted_at: null,
          tabcoins: 0,
          tabcoins_credit: 0,
          tabcoins_debit: 0,
          owner_username: defaultUser.username,
        });

        expect(uuidVersion(responseBody.id)).toBe(4);
        expect(Date.parse(responseBody.created_at)).not.toBeNaN();
        expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      });

      test('Should not credit TabCoins to the user', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await contentsRequestBuilder.buildUser();
        await orchestrator.createPrestige(defaultUser.id, { rootPrestigeNumerator: 2, rootPrestigeDenominator: 10 });

        await orchestrator.createBalance({
          balanceType: 'user:tabcash',
          recipientId: defaultUser.id,
          amount: defaultTabCashForAdCreation,
        });

        const { response: contentResponse, responseBody: contentResponseBody } = await contentsRequestBuilder.post({
          title: 'Title',
          body: relevantBody,
          status: 'published',
          type: 'ad',
        });

        const { responseBody: userResponseBody } = await usersRequestBuilder.get(`/${defaultUser.username}`);

        expect.soft(contentResponse.status).toBe(201);
        expect(contentResponseBody.tabcoins).toBe(1);
        expect(contentResponseBody.type).toBe('ad');
        expect(userResponseBody.tabcoins).toBe(0);
        expect(userResponseBody.tabcash).toBe(0);
      });
    });

    describe('With invalid "type"', () => {
      test('Should not be able to POST with invalid "type"', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const defaultUser = await contentsRequestBuilder.buildUser();

        await orchestrator.createBalance({
          balanceType: 'user:tabcash',
          recipientId: defaultUser.id,
          amount: defaultTabCashForAdCreation,
        });

        const { response, responseBody } = await contentsRequestBuilder.post({
          title: 'Ad title',
          body: 'Ad body',
          status: 'published',
          type: 'invalid_type',
        });

        expect.soft(response.status).toBe(400);

        expect(responseBody).toStrictEqual({
          name: 'ValidationError',
          message: '"type" deve possuir um dos seguintes valores: "content", "ad".',
          action: 'Ajuste os dados enviados e tente novamente.',
          status_code: 400,
          error_id: responseBody.error_id,
          request_id: responseBody.request_id,
          error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
          key: 'type',
          type: 'any.only',
        });
      });
    });
  });
});
</file>

<file path="tests/integration/api/v1/email-confirmation/patch.test.js">
import { version as uuidVersion } from 'uuid';

import emailConfirmation from 'models/email-confirmation.js';
import user from 'models/user.js';
import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
  await orchestrator.deleteAllEmails();
});

describe('PATCH /api/v1/email-confirmation', () => {
  describe('Anonymous user', () => {
    test('With blank body', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/email-confirmation`, {
        method: 'PATCH',
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"body" enviado deve ser do tipo Object.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'object',
        type: 'object.base',
      });
    });

    test('With a null token', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/email-confirmation`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: null,
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"token_id" deve ser do tipo String.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'token_id',
        type: 'string.base',
      });
    });

    test('With a malformatted number token', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/email-confirmation`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: 10000000,
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"token_id" deve ser do tipo String.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'token_id',
        type: 'string.base',
      });
    });

    test('With an empty string token', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/email-confirmation`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: '',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"token_id" não pode estar em branco.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'token_id',
        type: 'string.empty',
      });
    });

    test('With a malformatted string token', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/email-confirmation`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: '10000000',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"token_id" deve possuir um token UUID na versão 4.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'token_id',
        type: 'string.guid',
      });
    });

    test('With a fresh and valid token', async () => {
      // 1) UPDATE USER EMAIL
      const defaultUser = await orchestrator.createUser({
        email: 'fresh.valid.token@email.com',
      });
      await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const updateUserResponse = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },

        body: JSON.stringify({
          email: 'new@email.com',
        }),
      });

      expect.soft(updateUserResponse.status).toBe(200);

      // Attention: it should not update the email in the database
      // before the user clicks on the confirmation link sent to the new email.
      // See `/tests/integration/email-confirmation` for more details.
      const userInDatabaseCheck1 = await user.findOneById(defaultUser.id);
      expect(userInDatabaseCheck1.email).toBe('fresh.valid.token@email.com');

      // 2) RECEIVE CONFIRMATION EMAIL
      const confirmationEmail = await orchestrator.waitForFirstEmail();

      const tokenObjectInDatabase = await emailConfirmation.findOneTokenByUserId(defaultUser.id);
      const emailConfirmationPageEndpoint = emailConfirmation.getEmailConfirmationPageEndpoint(
        tokenObjectInDatabase.id,
      );

      expect(confirmationEmail.sender).toBe('<contato@tabnews.com.br>');
      expect(confirmationEmail.recipients).toStrictEqual(['<new@email.com>']);
      expect(confirmationEmail.subject).toBe('Confirme seu novo email');
      expect(confirmationEmail.text).toContain(defaultUser.username);
      expect(confirmationEmail.html).toContain(defaultUser.username);
      expect(confirmationEmail.text).toContain('Uma alteração de email foi solicitada.');
      expect(confirmationEmail.html).toContain('Uma alteração de email foi solicitada.');
      expect(confirmationEmail.text).toContain(emailConfirmationPageEndpoint);
      expect(confirmationEmail.html).toContain(emailConfirmationPageEndpoint);

      // 3) USE CONFIRMATION TOKEN
      const emailConfirmationResponse = await fetch(`${orchestrator.webserverUrl}/api/v1/email-confirmation`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: tokenObjectInDatabase.id,
        }),
      });

      const emailConfirmationResponseBody = await emailConfirmationResponse.json();

      expect.soft(emailConfirmationResponse.status).toBe(200);

      expect(emailConfirmationResponseBody).toStrictEqual({
        id: emailConfirmationResponseBody.id,
        used: true,
        expires_at: tokenObjectInDatabase.expires_at.toISOString(),
        created_at: tokenObjectInDatabase.created_at.toISOString(),
        updated_at: emailConfirmationResponseBody.updated_at,
      });

      expect(uuidVersion(emailConfirmationResponseBody.id)).toBe(4);
      expect(emailConfirmationResponseBody.updated_at > tokenObjectInDatabase.updated_at.toISOString()).toBe(true);

      // 4) CHECK IF EMAIL WAS UPDATED
      const userInDatabaseCheck2 = await user.findOneById(defaultUser.id);
      expect(userInDatabaseCheck2.email).toBe('new@email.com');
    });

    test('With an already used, but valid token', async () => {
      const defaultUser = await orchestrator.createUser({
        email: 'already.used.token@email.com',
      });

      const emailConfirmationToken = await emailConfirmation.create(defaultUser.id, 'not.idempotent@patch.com');

      const firstTryResponse = await fetch(`${orchestrator.webserverUrl}/api/v1/email-confirmation`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: emailConfirmationToken.id,
        }),
      });

      expect.soft(firstTryResponse.status).toBe(200);

      const userInDatabase = await user.findOneById(defaultUser.id);
      expect(userInDatabase.email).toBe('not.idempotent@patch.com');

      const secondTryResponse = await fetch(`${orchestrator.webserverUrl}/api/v1/email-confirmation`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: emailConfirmationToken.id,
        }),
      });

      const secondTryResponseBody = await secondTryResponse.json();

      expect.soft(secondTryResponse.status).toBe(404);

      expect(secondTryResponseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'O token de confirmação de email utilizado não foi encontrado no sistema ou expirou.',
        action: 'Solicite uma nova alteração de email.',
        status_code: 404,
        error_id: secondTryResponseBody.error_id,
        request_id: secondTryResponseBody.request_id,
        error_location_code: 'MODEL:EMAIL_CONFIRMATION:FIND_ONE_VALID_TOKEN_BY_ID:NOT_FOUND',
        key: 'token_id',
      });
    });

    test('With an already used email (before creating the token)', async () => {
      await orchestrator.deleteAllEmails();

      let firstUser = await orchestrator.createUser({
        email: 'validation.error@before.com',
      });
      firstUser = await orchestrator.activateUser(firstUser);
      const firstUserSession = await orchestrator.createSession(firstUser);

      await orchestrator.createUser({
        email: 'other.user.email@before.com',
      });

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${firstUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${firstUserSession.token}`,
        },

        body: JSON.stringify({
          email: 'other.user.email@before.com',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: firstUser.id,
        username: firstUser.username,
        email: firstUser.email,
        description: firstUser.description,
        features: firstUser.features,
        notifications: firstUser.notifications,
        created_at: firstUser.created_at.toISOString(),
        updated_at: firstUser.updated_at.toISOString(),
      });

      const userInDatabaseCheck1 = await user.findOneById(firstUser.id);
      expect(userInDatabaseCheck1.email).toBe('validation.error@before.com');

      expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);
    });

    test('With an already used email (after creating the token)', async () => {
      const firstUser = await orchestrator.createUser({
        email: 'validation.error@after.com',
      });

      const emailConfirmationToken = await emailConfirmation.create(firstUser.id, 'other.user.email@after.com');

      await orchestrator.createUser({
        email: 'other.user.email@after.com',
      });

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/email-confirmation`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: emailConfirmationToken.id,
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: 'O email informado já está sendo usado.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:USER:VALIDATE_UNIQUE_EMAIL:ALREADY_EXISTS',
        key: 'email',
      });

      const userInDatabaseCheck1 = await user.findOneById(firstUser.id);
      expect(userInDatabaseCheck1.email).toBe('validation.error@after.com');
    });

    test('With an expired token', async () => {
      const defaultUser = await orchestrator.createUser({
        email: 'expired.token@email.com',
      });

      const emailConfirmationToken = await emailConfirmation.create(
        defaultUser.id,
        'expired.token.will.reject@email.com',
      );

      await orchestrator.updateEmailConfirmationToken(emailConfirmationToken.id, {
        expires_at: new Date(Date.now() - 1000),
      });

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/email-confirmation`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: emailConfirmationToken.id,
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'O token de confirmação de email utilizado não foi encontrado no sistema ou expirou.',
        action: 'Solicite uma nova alteração de email.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:EMAIL_CONFIRMATION:FIND_ONE_VALID_TOKEN_BY_ID:NOT_FOUND',
        key: 'token_id',
      });

      const userInDatabaseCheck1 = await user.findOneById(defaultUser.id);
      expect(userInDatabaseCheck1.email).toBe('expired.token@email.com');
    });
  });
});
</file>

<file path="tests/integration/api/v1/events/firewall/[id]/get.test.js">
import { randomUUID } from 'node:crypto';
import { version as uuidVersion } from 'uuid';

import content from 'models/content';
import user from 'models/user';
import orchestrator from 'tests/orchestrator';
import RequestBuilder from 'tests/request-builder';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
  await orchestrator.createFirewallTestFunctions();
});

describe('GET /api/v1/events/firewall/[id]', () => {
  describe('Anonymous user', () => {
    test('Should not retrieve firewall event', async () => {
      const eventId = randomUUID();
      const firewallRequestBuilder = new RequestBuilder(`/api/v1/events/firewall/${eventId}`);
      const { response, responseBody } = await firewallRequestBuilder.get();

      expect.soft(response.status).toBe(403);

      expect(responseBody).toStrictEqual({
        name: 'ForbiddenError',
        message: 'Usuário não pode executar esta operação.',
        action: 'Verifique se este usuário possui a feature "read:firewall".',
        status_code: 403,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });
  });

  describe('Default user', () => {
    test('Should not retrieve firewall event', async () => {
      const eventId = randomUUID();

      const firewallRequestBuilder = new RequestBuilder(`/api/v1/events/firewall/${eventId}`);
      await firewallRequestBuilder.buildUser();

      const { response, responseBody } = await firewallRequestBuilder.get();

      expect.soft(response.status).toBe(403);

      expect(responseBody).toStrictEqual({
        name: 'ForbiddenError',
        message: 'Usuário não pode executar esta operação.',
        action: 'Verifique se este usuário possui a feature "read:firewall".',
        status_code: 403,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });
  });

  describe('User with "read:firewall" feature', () => {
    beforeEach(async () => {
      await orchestrator.dropAllTables();
      await orchestrator.runPendingMigrations();
      await orchestrator.createFirewallTestFunctions();
    });

    test('With a malformatted string as "id"', async () => {
      const firewallRequestBuilder = new RequestBuilder('/api/v1/events/firewall/random');
      await firewallRequestBuilder.buildUser({ with: ['read:firewall'] });

      const { response, responseBody } = await firewallRequestBuilder.get();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"id" deve possuir um token UUID na versão 4.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'id',
        type: 'string.guid',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With an "id" that does not exist', async () => {
      const eventId = randomUUID();
      const firewallRequestBuilder = new RequestBuilder(`/api/v1/events/firewall/${eventId}`);
      await firewallRequestBuilder.buildUser({ with: ['read:firewall'] });

      const { response, responseBody } = await firewallRequestBuilder.get();

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: `O id "${eventId}" não foi encontrado no sistema.`,
        action: 'Verifique se o "id" está digitado corretamente.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:FIREWALL:FIND_BY_EVENT_ID:NOT_FOUND',
        key: 'id',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With an "id" that is not a firewall event', async () => {
      const firewallRequestBuilder = new RequestBuilder(`/api/v1/events/firewall`);
      const user = await firewallRequestBuilder.buildUser({ with: ['read:firewall'] });

      await orchestrator.createContent({
        owner_id: user.id,
        status: 'published',
        title: 'Create event',
      });
      const lastEvent = await orchestrator.getLastEvent();

      const { response, responseBody } = await firewallRequestBuilder.get(`/${lastEvent.id}`);

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: `O id "${lastEvent.id}" não foi encontrado no sistema.`,
        action: 'Verifique se o "id" está digitado corretamente.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:FIREWALL:FIND_BY_EVENT_ID:NOT_FOUND',
        key: 'id',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With a "firewall:block_users" event', async () => {
      const usersRequestBuilder = new RequestBuilder('/api/v1/users');
      const firewallRequestBuilder = new RequestBuilder(`/api/v1/events/firewall`);
      await firewallRequestBuilder.buildUser({ with: ['read:firewall'] });

      // Create users
      const { responseBody: user1 } = await usersRequestBuilder.post({
        username: 'firstUser',
        email: 'first-user@gmail.com',
        password: 'password',
      });
      const { responseBody: user2 } = await usersRequestBuilder.post({
        username: 'secondUser',
        email: 'second-user@gmail.com',
        password: 'password',
      });
      const { response: user3Response } = await usersRequestBuilder.post({
        username: 'thirdUser',
        email: 'third-user@gmail.com',
        password: 'password',
      });

      expect.soft(user3Response.status).toBe(429);

      // Get firewall side-effect
      const firewallEvent = await orchestrator.getLastEvent();

      const { response, responseBody } = await firewallRequestBuilder.get(`/${firewallEvent.id}`);

      expect.soft(response.status).toBe(200);

      const expectedAffectedUsers = mapAffectedUsersData(user1, user2);

      expect(responseBody).toStrictEqual({
        affected: {
          users: expectedAffectedUsers,
        },
        events: [
          {
            created_at: firewallEvent.created_at.toISOString(),
            id: firewallEvent.id,
            metadata: {
              from_rule: 'create:user',
              users: expectedAffectedUsers.map((user) => user.id),
            },
            originator_user_id: null,
            type: 'firewall:block_users',
          },
        ],
      });
    });

    test('With two consecutive "firewall:block_users" events from the same IP', async () => {
      const usersRequestBuilder = new RequestBuilder('/api/v1/users');
      const firewallRequestBuilder = new RequestBuilder(`/api/v1/events/firewall`);
      await firewallRequestBuilder.buildUser({ with: ['read:firewall'] });

      // Create users
      const { responseBody: user1 } = await usersRequestBuilder.post({
        username: 'firstUser',
        email: 'first-user@gmail.com',
        password: 'password',
      });
      const { responseBody: user2 } = await usersRequestBuilder.post({
        username: 'secondUser',
        email: 'second-user@gmail.com',
        password: 'password',
      });
      const { response: user3Response } = await usersRequestBuilder.post({
        username: 'thirdUser',
        email: 'third-user@gmail.com',
        password: 'password',
      });

      expect.soft(user3Response.status).toBe(429);

      const firstFirewallEvent = await orchestrator.getLastEvent();

      const { response: user4Response } = await usersRequestBuilder.post({
        username: 'fourthUser',
        email: 'fourth-user@gmail.com',
        password: 'password',
      });

      expect.soft(user4Response.status).toBe(429);

      const secondFirewallEvent = await orchestrator.getLastEvent();

      expect(firstFirewallEvent.id).not.toBe(secondFirewallEvent.id);

      // Get firewall side-effects
      const { response: firstFirewallResponse, responseBody: firstFirewallResponseBody } =
        await firewallRequestBuilder.get(`/${firstFirewallEvent.id}`);
      const { response: secondFirewallResponse, responseBody: secondFirewallResponseBody } =
        await firewallRequestBuilder.get(`/${secondFirewallEvent.id}`);

      expect.soft(firstFirewallResponse.status).toBe(200);
      expect.soft(secondFirewallResponse.status).toBe(200);

      const expectedAffectedUsers = mapAffectedUsersData(user1, user2);

      const expectedEvents = mapEventsData([firstFirewallEvent, secondFirewallEvent], {
        metadata: {
          from_rule: 'create:user',
          users: expectedAffectedUsers.map((user) => user.id),
        },
        type: 'firewall:block_users',
      });

      expect(expectedEvents).toStrictEqual(expect.arrayContaining(firstFirewallResponseBody.events));
      expect(firstFirewallResponseBody).toStrictEqual({
        affected: {
          users: expectedAffectedUsers,
        },
        events: expect.arrayContaining(expectedEvents),
      });

      expect(expectedEvents).toStrictEqual(expect.arrayContaining(secondFirewallResponseBody.events));
      expect(secondFirewallResponseBody).toStrictEqual({
        affected: {
          users: expectedAffectedUsers,
        },
        events: expect.arrayContaining(expectedEvents),
      });
    });

    test.each([
      {
        action: 'undo',
        eventType: 'moderation:unblock_users',
      },
      {
        action: 'confirm',
        eventType: 'moderation:block_users',
      },
    ])('With a review $action "firewall:block_users" event', async ({ action, eventType }) => {
      const usersRequestBuilder = new RequestBuilder('/api/v1/users');
      const firewallRequestBuilder = new RequestBuilder(`/api/v1/events/firewall`);
      const firewallUser = await firewallRequestBuilder.buildUser({ with: ['read:firewall', 'review:firewall'] });

      // Create users
      const { responseBody: user1 } = await usersRequestBuilder.post({
        username: 'firstUser',
        email: 'first-user@gmail.com',
        password: 'password',
      });
      const { responseBody: user2 } = await usersRequestBuilder.post({
        username: 'secondUser',
        email: 'second-user@gmail.com',
        password: 'password',
      });
      const { response: user3Response } = await usersRequestBuilder.post({
        username: 'thirdUser',
        email: 'third-user@gmail.com',
        password: 'password',
      });

      expect.soft(user3Response.status).toBe(429);

      // Check firewall side-effect
      const firewallEvent = await orchestrator.getLastEvent();

      expect(firewallEvent.type).toBe('firewall:block_users');
      expect(firewallEvent.metadata.users).toStrictEqual([user1.id, user2.id]);

      // Review firewall side-effect
      const reviewFirewallRequestBuilder = new RequestBuilder(
        `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
      );
      await reviewFirewallRequestBuilder.setUser(firewallUser);
      const { response: reviewResponse } = await reviewFirewallRequestBuilder.post({ action: action });
      expect.soft(reviewResponse.status).toBe(200);

      // Get reviewed firewall event
      const reviewEvent = await orchestrator.getLastEvent();

      const { response, responseBody } = await firewallRequestBuilder.get(`/${firewallEvent.id}`);

      const user1AfterFirewall = await user.findOneById(user1.id);
      const user2AfterFirewall = await user.findOneById(user2.id);

      const expectedEvents = mapEventsData([
        {
          ...firewallEvent,
          metadata: {
            users: [user1.id, user2.id],
            from_rule: 'create:user',
          },
          type: 'firewall:block_users',
        },
        {
          ...reviewEvent,
          metadata: {
            users: [user1.id, user2.id],
            related_events: [firewallEvent.id],
          },
          type: eventType,
        },
      ]);

      expect.soft(response.status).toBe(200);

      expect.soft(expectedEvents).toStrictEqual(expect.arrayContaining(responseBody.events));
      expect(responseBody).toStrictEqual({
        affected: {
          users: mapUsersData(user1AfterFirewall, user2AfterFirewall),
        },
        events: expect.arrayContaining(expectedEvents),
      });
    });

    test('With a "firewall:block_contents:text_root" event', async () => {
      const firewallRequestBuilder = new RequestBuilder(`/api/v1/events/firewall`);
      await firewallRequestBuilder.buildUser({ with: ['read:firewall'] });

      // Create user and contents
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const user1 = await contentsRequestBuilder.buildUser();

      const { responseBody: content1 } = await createContentViaApi(contentsRequestBuilder);
      const { responseBody: content2 } = await createContentViaApi(contentsRequestBuilder);
      const { response: responseContent3 } = await createContentViaApi(contentsRequestBuilder);

      expect.soft(responseContent3.status).toBe(429);

      // Get firewall side-effect
      const firewallEvent = await orchestrator.getLastEvent();

      const { response, responseBody } = await firewallRequestBuilder.get(`/${firewallEvent.id}`);

      expect.soft(response.status).toBe(200);

      const expectedAffectedUsers = mapUsersData(user1);

      const expectedAffectedContents = mapAffectedContentsData(content1, content2);

      expect(responseBody).toStrictEqual({
        affected: {
          contents: expectedAffectedContents,
          users: expectedAffectedUsers,
        },
        events: [
          {
            created_at: firewallEvent.created_at.toISOString(),
            id: firewallEvent.id,
            metadata: {
              from_rule: 'create:content:text_root',
              contents: [content1.id, content2.id],
            },
            originator_user_id: user1.id,
            type: 'firewall:block_contents:text_root',
          },
        ],
      });
    });

    test('With two consecutive "firewall:block_contents:text_root" events (same time window)', async () => {
      const firewallRequestBuilder = new RequestBuilder('/api/v1/events/firewall/');
      await firewallRequestBuilder.buildUser({ with: ['read:firewall'] });
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const owner = await contentsRequestBuilder.buildUser();

      const content1 = await createContentViaApi(contentsRequestBuilder);
      expect.soft(content1.response.status).toBe(201);
      const content1CreateContentEvent = await orchestrator.getLastEvent();

      const content2 = await createContentViaApi(contentsRequestBuilder);
      expect.soft(content2.response.status).toBe(201);

      const content3 = await createContentViaApi(contentsRequestBuilder);
      expect.soft(content3.response.status).toBe(429);

      const firewallEvent1 = await orchestrator.getLastEvent();
      const firewall1Get1 = await firewallRequestBuilder.get(firewallEvent1.id);
      expect.soft(firewall1Get1.response.status).toBe(200);

      // Update content1 event to simulate a different `firewall`, but same `affected` time window
      await orchestrator.updateEventCreatedAt(content1CreateContentEvent.id, new Date(Date.now() - 1000 * 6));

      const content4 = await createContentViaApi(contentsRequestBuilder);
      expect.soft(content4.response.status).toBe(201);

      const content5 = await createContentViaApi(contentsRequestBuilder);
      expect.soft(content5.response.status).toBe(429);

      const firewallEvent2 = await orchestrator.getLastEvent();
      expect.soft(firewallEvent1.id).not.toBe(firewallEvent2.id);

      const firewall1Get2 = await firewallRequestBuilder.get(firewallEvent1.id);
      expect.soft(firewall1Get2.response.status).toBe(200);

      const firewall2Get = await firewallRequestBuilder.get(firewallEvent2.id);
      expect.soft(firewall2Get.response.status).toBe(200);

      const expectedAffected1 = mapAffectedContentsData(content1, content2);
      const expectedAffected2 = mapAffectedContentsData(content1, content2, content4);
      const expectedAllAffected = expectedAffected2;
      const expectedUsers = mapUsersData(owner);
      const expectedEvents = mapEventsData(
        [
          {
            ...firewallEvent1,
            metadata: {
              contents: expect.arrayContaining(expectedAffected1.map((content) => content.id)),
            },
          },
          {
            ...firewallEvent2,
            metadata: {
              contents: expect.arrayContaining(expectedAffected2.map((content) => content.id)),
            },
          },
        ],
        {
          metadata: {
            from_rule: 'create:content:text_root',
          },
          originator_user_id: owner.id,
          type: 'firewall:block_contents:text_root',
        },
      );

      expect.soft(expectedAffected1).toEqual(expect.arrayContaining(firewall1Get1.responseBody.affected.contents));
      expect(firewall1Get1.responseBody).toStrictEqual({
        affected: {
          contents: expect.arrayContaining(expectedAffected1),
          users: expectedUsers,
        },
        events: [expectedEvents[0]],
      });

      expect.soft(expectedAllAffected).toEqual(expect.arrayContaining(firewall1Get2.responseBody.affected.contents));
      expect.soft(expectedEvents).toEqual(expect.arrayContaining(firewall1Get2.responseBody.events));
      expect(firewall1Get2.responseBody).toStrictEqual({
        affected: {
          contents: expect.arrayContaining(expectedAllAffected),
          users: expectedUsers,
        },
        events: expect.arrayContaining(expectedEvents),
      });

      expect.soft(expectedAllAffected).toEqual(expect.arrayContaining(firewall2Get.responseBody.affected.contents));
      expect.soft(expectedEvents).toEqual(expect.arrayContaining(firewall2Get.responseBody.events));
      expect(firewall2Get.responseBody).toStrictEqual({
        affected: {
          contents: expect.arrayContaining(expectedAllAffected),
          users: expectedUsers,
        },
        events: expect.arrayContaining(expectedEvents),
      });
    });

    test('With a "firewall:block_contents:text_root" and contents deleted before the firewall catch', async () => {
      const usersRequestBuilder = new RequestBuilder('/api/v1/users');
      const firewallRequestBuilder = new RequestBuilder(`/api/v1/events/firewall`);
      await firewallRequestBuilder.buildUser({ with: ['read:firewall'] });

      // Create user and contents
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const user1 = await contentsRequestBuilder.buildUser();

      const { responseBody: content1 } = await createContentViaApi(contentsRequestBuilder);
      const { responseBody: content2 } = await createContentViaApi(contentsRequestBuilder);

      await orchestrator.updateContent(content1.id, { status: 'deleted' });
      await orchestrator.updateContent(content2.id, { status: 'deleted' });

      const { response: responseContent3 } = await createContentViaApi(contentsRequestBuilder);

      expect.soft(responseContent3.status).toBe(429);

      // Get firewall side-effect
      const firewallEvent = await orchestrator.getLastEvent();

      const { response, responseBody } = await firewallRequestBuilder.get(`/${firewallEvent.id}`);

      expect.soft(response.status).toBe(200);

      const { responseBody: user1AfterFirewall } = await usersRequestBuilder.get(`/${user1.username}`);

      const content1AfterFirewall = await content.findOne({ where: { id: content1.id } });
      const content2AfterFirewall = await content.findOne({ where: { id: content2.id } });

      expect(responseBody).toStrictEqual({
        affected: {
          contents: [mapContentData(content1AfterFirewall), mapContentData(content2AfterFirewall)],
          users: [user1AfterFirewall],
        },
        events: [
          {
            created_at: firewallEvent.created_at.toISOString(),
            id: firewallEvent.id,
            metadata: {
              from_rule: 'create:content:text_root',
              contents: [content1.id, content2.id],
            },
            originator_user_id: user1.id,
            type: 'firewall:block_contents:text_root',
          },
        ],
      });
    });

    test.each([
      {
        action: 'undo',
        eventType: 'moderation:unblock_contents:text_root',
      },
      {
        action: 'confirm',
        eventType: 'moderation:block_contents:text_root',
      },
    ])('With a review $action "firewall:block_contents:text_root" event', async ({ action, eventType }) => {
      const firewallRequestBuilder = new RequestBuilder(`/api/v1/events/firewall`);
      const firewallUser = await firewallRequestBuilder.buildUser({ with: ['read:firewall', 'review:firewall'] });

      // Create users and contents
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const user1 = await contentsRequestBuilder.buildUser();

      const { responseBody: content1 } = await createContentViaApi(contentsRequestBuilder);
      const { responseBody: content2 } = await createContentViaApi(contentsRequestBuilder);
      const { response: responseContent3 } = await createContentViaApi(contentsRequestBuilder);

      expect.soft(responseContent3.status).toBe(429);

      // Check firewall side-effect
      const firewallEvent = await orchestrator.getLastEvent();

      expect(firewallEvent.type).toBe('firewall:block_contents:text_root');
      expect(firewallEvent.metadata.contents).toStrictEqual([content1.id, content2.id]);

      // Review firewall side-effect
      const reviewFirewallRequestBuilder = new RequestBuilder(
        `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
      );
      await reviewFirewallRequestBuilder.setUser(firewallUser);
      const { response: reviewResponse } = await reviewFirewallRequestBuilder.post({ action: action });

      expect.soft(reviewResponse.status).toBe(200);

      // Get reviewed firewall event
      const reviewEvent = await orchestrator.getLastEvent();

      const { response, responseBody } = await firewallRequestBuilder.get(`/${firewallEvent.id}`);

      const user1AfterFirewall = await user.findOneById(user1.id);

      const content1AfterFirewall = await content.findOne({ where: { id: content1.id } });
      const content2AfterFirewall = await content.findOne({ where: { id: content2.id } });

      const expectedEvents = mapEventsData([
        {
          ...firewallEvent,
          metadata: {
            from_rule: 'create:content:text_root',
            contents: [content1.id, content2.id],
          },
          type: 'firewall:block_contents:text_root',
        },
        {
          ...reviewEvent,
          metadata: {
            contents: [content1.id, content2.id],
            related_events: [firewallEvent.id],
          },
          type: eventType,
        },
      ]);

      expect.soft(response.status).toBe(200);

      expect.soft(expectedEvents).toEqual(expect.arrayContaining(responseBody.events));
      expect(responseBody).toStrictEqual({
        affected: {
          contents: [mapContentData(content1AfterFirewall), mapContentData(content2AfterFirewall)],
          users: mapUsersData(user1AfterFirewall),
        },
        events: expect.arrayContaining(expectedEvents),
      });
    });

    test('With a "firewall:block_contents:text_child" event', async () => {
      const usersRequestBuilder = new RequestBuilder('/api/v1/users');
      const firewallRequestBuilder = new RequestBuilder(`/api/v1/events/firewall`);
      const firewallUser = await firewallRequestBuilder.buildUser({ with: ['read:firewall'] });

      // Create user and contents
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.setUser(firewallUser);

      const { responseBody: rootContent } = await createContentViaApi(contentsRequestBuilder);

      const user1 = await contentsRequestBuilder.buildUser();

      const { responseBody: content1 } = await createContentViaApi(contentsRequestBuilder, {
        parent_id: rootContent.id,
      });
      const { responseBody: content2 } = await createContentViaApi(contentsRequestBuilder, {
        parent_id: rootContent.id,
      });
      const { response: responseContent3 } = await createContentViaApi(contentsRequestBuilder, {
        parent_id: rootContent.id,
      });

      expect.soft(responseContent3.status).toBe(429);

      // Get firewall side-effect
      const firewallEvent = await orchestrator.getLastEvent();

      const { response, responseBody } = await firewallRequestBuilder.get(`/${firewallEvent.id}`);

      expect.soft(response.status).toBe(200);

      const { responseBody: user1AfterFirewall } = await usersRequestBuilder.get(`/${user1.username}`);

      const content1AfterFirewall = await content.findOne({ where: { id: content1.id } });
      const content2AfterFirewall = await content.findOne({ where: { id: content2.id } });

      expect(responseBody).toStrictEqual({
        affected: {
          contents: [mapContentData(content1AfterFirewall), mapContentData(content2AfterFirewall)],
          users: [user1AfterFirewall],
        },
        events: [
          {
            created_at: firewallEvent.created_at.toISOString(),
            id: firewallEvent.id,
            metadata: {
              from_rule: 'create:content:text_child',
              contents: [content1.id, content2.id],
            },
            originator_user_id: user1.id,
            type: 'firewall:block_contents:text_child',
          },
        ],
      });
    });

    test.each([
      {
        action: 'undo',
        eventType: 'moderation:unblock_contents:text_child',
      },
      {
        action: 'confirm',
        eventType: 'moderation:block_contents:text_child',
      },
    ])('With a review $action "firewall:block_contents:text_child" event', async ({ action, eventType }) => {
      const firewallRequestBuilder = new RequestBuilder(`/api/v1/events/firewall`);
      const firewallUser = await firewallRequestBuilder.buildUser({ with: ['read:firewall', 'review:firewall'] });

      // Create users and contents
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.setUser(firewallUser);

      const { responseBody: rootContent } = await createContentViaApi(contentsRequestBuilder);

      const user1 = await contentsRequestBuilder.buildUser();

      const { responseBody: content1 } = await createContentViaApi(contentsRequestBuilder, {
        parent_id: rootContent.id,
      });
      const { responseBody: content2 } = await createContentViaApi(contentsRequestBuilder, {
        parent_id: rootContent.id,
      });
      const { response: responseContent3 } = await createContentViaApi(contentsRequestBuilder, {
        parent_id: rootContent.id,
      });

      expect.soft(responseContent3.status).toBe(429);

      // Check firewall side-effect
      const firewallEvent = await orchestrator.getLastEvent();

      expect(firewallEvent.type).toBe('firewall:block_contents:text_child');
      expect(firewallEvent.metadata.contents).toStrictEqual([content1.id, content2.id]);

      // Review firewall side-effect
      const reviewFirewallRequestBuilder = new RequestBuilder(
        `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
      );
      await reviewFirewallRequestBuilder.setUser(firewallUser);
      const { response: reviewResponse } = await reviewFirewallRequestBuilder.post({ action: action });

      expect.soft(reviewResponse.status).toBe(200);

      // Get reviewed firewall event
      const reviewEvent = await orchestrator.getLastEvent();

      const { response, responseBody } = await firewallRequestBuilder.get(`/${firewallEvent.id}`);

      const user1AfterFirewall = await user.findOneById(user1.id);

      const content1AfterFirewall = await content.findOne({ where: { id: content1.id } });
      const content2AfterFirewall = await content.findOne({ where: { id: content2.id } });

      const expectedEvents = mapEventsData([
        {
          ...firewallEvent,
          metadata: {
            from_rule: 'create:content:text_child',
            contents: [content1.id, content2.id],
          },
          type: 'firewall:block_contents:text_child',
        },
        {
          ...reviewEvent,
          metadata: {
            contents: [content1.id, content2.id],
            related_events: [firewallEvent.id],
          },
          type: eventType,
        },
      ]);

      expect.soft(response.status).toBe(200);

      expect.soft(expectedEvents).toEqual(expect.arrayContaining(responseBody.events));
      expect(responseBody).toStrictEqual({
        affected: {
          contents: [mapContentData(content1AfterFirewall), mapContentData(content2AfterFirewall)],
          users: mapUsersData(user1AfterFirewall),
        },
        events: expect.arrayContaining(expectedEvents),
      });
    });

    test('With a "firewall:block_contents:text_child" event involving multiple users', async () => {
      const usersRequestBuilder = new RequestBuilder('/api/v1/users');
      const firewallRequestBuilder = new RequestBuilder(`/api/v1/events/firewall`);
      const firewallUser = await firewallRequestBuilder.buildUser({ with: ['read:firewall'] });

      // Create user and contents
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentsRequestBuilder.setUser(firewallUser);

      const rootContent = await orchestrator.createContent({
        owner_id: firewallUser.id,
        status: 'published',
        title: 'Root content',
      });

      const user1 = await contentsRequestBuilder.buildUser();

      const { responseBody: content1 } = await createContentViaApi(contentsRequestBuilder, {
        parent_id: rootContent.id,
      });

      const user2 = await contentsRequestBuilder.buildUser();

      const { responseBody: content2 } = await createContentViaApi(contentsRequestBuilder, {
        parent_id: rootContent.id,
      });
      const { response: responseContent3 } = await createContentViaApi(contentsRequestBuilder, {
        parent_id: rootContent.id,
      });

      expect.soft(responseContent3.status).toBe(429);

      // Get firewall side-effect
      const firewallEvent = await orchestrator.getLastEvent();

      const { response, responseBody } = await firewallRequestBuilder.get(`/${firewallEvent.id}`);

      expect.soft(response.status).toBe(200);

      const { responseBody: user1AfterFirewall } = await usersRequestBuilder.get(`/${user1.username}`);
      const { responseBody: user2AfterFirewall } = await usersRequestBuilder.get(`/${user2.username}`);

      const content1AfterFirewall = await content.findOne({ where: { id: content1.id } });
      const content2AfterFirewall = await content.findOne({ where: { id: content2.id } });

      expect(responseBody).toStrictEqual({
        affected: {
          contents: [mapContentData(content1AfterFirewall), mapContentData(content2AfterFirewall)],
          users: [user1AfterFirewall, user2AfterFirewall],
        },
        events: [
          {
            created_at: firewallEvent.created_at.toISOString(),
            id: firewallEvent.id,
            metadata: {
              from_rule: 'create:content:text_child',
              contents: [content1.id, content2.id],
            },
            originator_user_id: user2.id,
            type: 'firewall:block_contents:text_child',
          },
        ],
      });
    });

    test('With two consecutive "firewall:block_contents:text_child" events (different time window)', async () => {
      const firewallRequestBuilder = new RequestBuilder('/api/v1/events/firewall/');
      await firewallRequestBuilder.buildUser({ with: ['read:firewall'] });
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const user1 = await contentsRequestBuilder.buildUser();

      const rootContent = await orchestrator.createContent({
        owner_id: user1.id,
        status: 'published',
        title: 'Root content',
      });

      const child1 = await createContentViaApi(contentsRequestBuilder, {
        parent_id: rootContent.id,
      });
      expect.soft(child1.response.status).toBe(201);
      const child1CreateContentEvent = await orchestrator.getLastEvent();

      // Update child1 event to simulate a different `firewall`, but same `affected` time window
      await orchestrator.updateEventCreatedAt(child1CreateContentEvent.id, new Date(Date.now() - 1000 * 6));

      const child2 = await createContentViaApi(contentsRequestBuilder, {
        parent_id: rootContent.id,
      });
      expect.soft(child2.response.status).toBe(201);
      const child2CreateContentEvent = await orchestrator.getLastEvent();

      const child3 = await createContentViaApi(contentsRequestBuilder, {
        parent_id: rootContent.id,
      });
      expect.soft(child3.response.status).toBe(201);

      const child4 = await createContentViaApi(contentsRequestBuilder, {
        parent_id: rootContent.id,
      });
      expect.soft(child4.response.status).toBe(429);

      const firewallEvent1 = await orchestrator.getLastEvent();
      const firewall1Get1 = await firewallRequestBuilder.get(firewallEvent1.id);
      expect.soft(firewall1Get1.response.status).toBe(200);

      // Update child2 event to simulate a different `firewall` time window
      await orchestrator.updateEventCreatedAt(child2CreateContentEvent.id, new Date(Date.now() - 1000 * 6));

      // Update child1 event to simulate a different `affected` time window
      await orchestrator.updateEventCreatedAt(child1CreateContentEvent.id, new Date(Date.now() - 1000 * 60 * 11));

      const user2 = await contentsRequestBuilder.buildUser();

      const child5 = await createContentViaApi(contentsRequestBuilder, {
        parent_id: rootContent.id,
      });
      expect.soft(child5.response.status).toBe(201);

      const child6 = await createContentViaApi(contentsRequestBuilder, {
        parent_id: rootContent.id,
      });
      expect.soft(child6.response.status).toBe(429);

      const firewallEvent2 = await orchestrator.getLastEvent();
      expect.soft(firewallEvent1.id).not.toBe(firewallEvent2.id);

      const firewall1Get2 = await firewallRequestBuilder.get(firewallEvent1.id);
      expect.soft(firewall1Get2.response.status).toBe(200);

      const firewall2Get = await firewallRequestBuilder.get(firewallEvent2.id);
      expect.soft(firewall2Get.response.status).toBe(200);

      const expectedAffected1 = mapAffectedContentsData(child1, child2, child3);
      const expectedAffected2 = mapAffectedContentsData(child2, child3, child5);
      const expectedAllAffected = mapAffectedContentsData(child1, child2, child3, child5);
      const expectedUsers = mapUsersData(user1, user2);
      const expectedEvents = mapEventsData(
        [
          {
            ...firewallEvent1,
            metadata: {
              contents: expect.arrayContaining(expectedAffected1.map((content) => content.id)),
            },
          },
          {
            ...firewallEvent2,
            metadata: {
              contents: expect.arrayContaining(expectedAffected2.map((content) => content.id)),
            },
          },
        ],
        {
          metadata: {
            from_rule: 'create:content:text_child',
          },
          type: 'firewall:block_contents:text_child',
        },
      );

      expect.soft(expectedAffected1).toEqual(expect.arrayContaining(firewall1Get1.responseBody.affected.contents));
      expect(firewall1Get1.responseBody).toStrictEqual({
        affected: {
          contents: expect.arrayContaining(expectedAffected1),
          users: [expectedUsers[0]],
        },
        events: [expectedEvents[0]],
      });

      expect.soft(expectedAllAffected).toEqual(expect.arrayContaining(firewall1Get2.responseBody.affected.contents));
      expect.soft(expectedEvents).toEqual(expect.arrayContaining(firewall1Get2.responseBody.events));
      expect(firewall1Get2.responseBody).toStrictEqual({
        affected: {
          contents: expect.arrayContaining(expectedAllAffected),
          users: expectedUsers,
        },
        events: expect.arrayContaining(expectedEvents),
      });

      expect.soft(expectedAllAffected).toEqual(expect.arrayContaining(firewall2Get.responseBody.affected.contents));
      expect.soft(expectedEvents).toEqual(expect.arrayContaining(firewall2Get.responseBody.events));
      expect(firewall2Get.responseBody).toStrictEqual({
        affected: {
          contents: expect.arrayContaining(expectedAllAffected),
          users: expectedUsers,
        },
        events: expect.arrayContaining(expectedEvents),
      });
    });
  });
});

async function createContentViaApi(contentsRequestBuilder, body) {
  return await contentsRequestBuilder.post({
    title: `New content - ${new Date().getTime()}`,
    body: 'body',
    status: 'published',
    parent_id: body?.parent_id,
  });
}

function mapContentData(content) {
  return {
    body: content.body,
    children_deep_count: +content.children_deep_count || 0,
    created_at:
      typeof content.created_at?.toISOString === 'function' ? content.created_at.toISOString() : content.created_at,
    deleted_at:
      typeof content.deleted_at?.toISOString === 'function'
        ? content.deleted_at.toISOString()
        : (content.deleted_at ?? null),
    id: content.id,
    owner_id: content.owner_id,
    owner_username: content.owner_username,
    parent_id: content.parent_id,
    published_at:
      typeof content.published_at?.toISOString === 'function'
        ? content.published_at.toISOString()
        : content.published_at,
    slug: content.slug,
    source_url: content.source_url,
    status: content.status,
    tabcoins: +content.tabcoins,
    tabcoins_credit: +content.tabcoins_credit,
    tabcoins_debit: +content.tabcoins_debit,
    title: content.title,
    type: content.type,
    updated_at:
      typeof content.updated_at?.toISOString === 'function' ? content.updated_at.toISOString() : content.updated_at,
  };
}

function mapAffectedContentsData(...affected) {
  return affected.map((content) =>
    mapContentData({
      ...content,
      ...content.responseBody,
      status: 'firewall',
    }),
  );
}

function mapUsersData(...users) {
  return users.map((user) => ({
    id: user.id,
    username: user.username,
    created_at: user.created_at.toISOString(),
    updated_at: user.updated_at.toISOString(),
    description: user.description,
    features: user.features,
    tabcash: 0,
    tabcoins: 0,
  }));
}

function mapAffectedUsersData(...affected) {
  return affected.map((user) => ({
    ...user,
    features: [],
  }));
}

function mapEventsData(events, commonData) {
  return events.map((event) => ({
    created_at: typeof event.created_at.toISOString === 'function' ? event.created_at.toISOString() : event.created_at,
    id: event.id,
    originator_user_id: event.originator_user_id ?? null,
    type: event.type,
    ...commonData,
    metadata: {
      ...event.metadata,
      ...commonData?.metadata,
    },
  }));
}
</file>

<file path="tests/integration/api/v1/migrations/get.test.js">
import { version as uuidVersion } from 'uuid';

import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('GET /api/v1/migrations', () => {
  describe('Anonymous user', () => {
    test('Retrieving pending migrations', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/migrations`);

      const responseBody = await response.json();

      expect.soft(response.status).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Usuário não pode executar esta operação.');
      expect(responseBody.action).toBe('Verifique se este usuário possui a feature "read:migration".');
      expect.soft(responseBody.status_code).toBe(403);
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND');
    });
  });

  describe('Default user', () => {
    test('Retrieving pending migrations', async () => {
      let defaultUser = await orchestrator.createUser();
      defaultUser = await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/migrations`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Usuário não pode executar esta operação.');
      expect(responseBody.action).toBe('Verifique se este usuário possui a feature "read:migration".');
      expect.soft(responseBody.status_code).toBe(403);
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND');
    });
  });

  describe('User with "read:migration" feature', () => {
    let privilegedUser;
    let privilegedUserSession;

    beforeEach(async () => {
      privilegedUser = await orchestrator.createUser();
      privilegedUser = await orchestrator.activateUser(privilegedUser);
      privilegedUser = await orchestrator.addFeaturesToUser(privilegedUser, ['read:migration']);
      privilegedUserSession = await orchestrator.createSession(privilegedUser);
    });

    test('Retrieving pending migrations', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/migrations`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${privilegedUserSession.token}`,
        },
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);
      expect(Array.isArray(responseBody)).toBe(true);
    });

    describe('Same user after losing "read:migration" feature', () => {
      test('Retrieving pending migrations', async () => {
        await orchestrator.removeFeaturesFromUser(privilegedUser, ['read:migration']);

        const responseAfter = await fetch(`${orchestrator.webserverUrl}/api/v1/migrations`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            cookie: `session_id=${privilegedUserSession.token}`,
          },
        });

        const responseBody = await responseAfter.json();

        expect(responseAfter.status).toBe(403);
        expect(responseBody.name).toBe('ForbiddenError');
        expect(responseBody.message).toBe('Usuário não pode executar esta operação.');
        expect(responseBody.action).toBe('Verifique se este usuário possui a feature "read:migration".');
        expect.soft(responseBody.status_code).toBe(403);
        expect(uuidVersion(responseBody.error_id)).toBe(4);
        expect(uuidVersion(responseBody.request_id)).toBe(4);
        expect(responseBody.error_location_code).toBe('MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND');
      });
    });
  });
});
</file>

<file path="tests/integration/api/v1/migrations/post.test.js">
import { version as uuidVersion } from 'uuid';

import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('POST /api/v1/migrations', () => {
  describe('Anonymous user', () => {
    test('Running pending migrations', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/migrations`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Usuário não pode executar esta operação.');
      expect(responseBody.action).toBe('Verifique se este usuário possui a feature "create:migration".');
      expect.soft(responseBody.status_code).toBe(403);
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND');
    });
  });

  describe('User with default features', () => {
    test('Running pending migrations', async () => {
      const defaultUser = await orchestrator.createUser();
      await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/migrations`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Usuário não pode executar esta operação.');
      expect(responseBody.action).toBe('Verifique se este usuário possui a feature "create:migration".');
      expect.soft(responseBody.status_code).toBe(403);
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND');
    });
  });

  describe('User with "create:migration" feature', () => {
    test('Running pending migrations', async () => {
      const privilegedUser = await orchestrator.createUser();
      await orchestrator.activateUser(privilegedUser);
      await orchestrator.addFeaturesToUser(privilegedUser, ['create:migration']);

      const privilegedUserSession = await orchestrator.createSession(privilegedUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/migrations`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${privilegedUserSession.token}`,
        },
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);
      expect(Array.isArray(responseBody)).toBe(true);
    });
  });
});
</file>

<file path="tests/integration/api/v1/moderations/review_firewall/[id]/post.test.js">
import { randomUUID } from 'node:crypto';
import { version as uuidVersion } from 'uuid';

import content from 'models/content';
import user from 'models/user';
import orchestrator from 'tests/orchestrator';
import RequestBuilder from 'tests/request-builder';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
  await orchestrator.createFirewallTestFunctions();
});

describe('POST /api/v1/moderations/review_firewall/[id]', () => {
  async function createContentViaApi(contentsRequestBuilder, body) {
    return await contentsRequestBuilder.post({
      title: `New content - ${new Date().getTime()}`,
      body: 'body',
      status: 'published',
      parent_id: body?.parent_id,
    });
  }

  describe('Anonymous user', () => {
    test('Reviewing a firewall side-effect', async () => {
      const eventId = randomUUID();
      const reviewFirewallRequestBuilder = new RequestBuilder(`/api/v1/moderations/review_firewall/${eventId}`);

      const { response, responseBody } = await reviewFirewallRequestBuilder.post({
        action: 'undo',
      });

      expect.soft(response.status).toBe(403);

      expect(responseBody).toStrictEqual({
        name: 'ForbiddenError',
        message: 'Usuário não pode executar esta operação.',
        action: 'Verifique se este usuário possui a feature "review:firewall".',
        status_code: 403,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });
  });

  describe('Default user', () => {
    test('Reviewing a firewall side-effect', async () => {
      const eventId = randomUUID();
      const reviewFirewallRequestBuilder = new RequestBuilder(`/api/v1/moderations/review_firewall/${eventId}`);
      await reviewFirewallRequestBuilder.buildUser();

      const { response, responseBody } = await reviewFirewallRequestBuilder.post({
        action: 'undo',
      });

      expect.soft(response.status).toBe(403);

      expect(responseBody).toStrictEqual({
        name: 'ForbiddenError',
        message: 'Usuário não pode executar esta operação.',
        action: 'Verifique se este usuário possui a feature "review:firewall".',
        status_code: 403,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });
  });

  describe('User with "review:firewall" feature', () => {
    beforeEach(async () => {
      await orchestrator.dropAllTables();
      await orchestrator.runPendingMigrations();
      await orchestrator.createFirewallTestFunctions();
    });

    test('With a malformatted string as "id"', async () => {
      const reviewFirewallRequestBuilder = new RequestBuilder('/api/v1/moderations/review_firewall/random');
      await reviewFirewallRequestBuilder.buildUser({ with: ['review:firewall'] });

      const { response, responseBody } = await reviewFirewallRequestBuilder.post({
        action: 'confirm',
      });

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"id" deve possuir um token UUID na versão 4.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'id',
        type: 'string.guid',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('Body containing an empty Object', async () => {
      const eventId = randomUUID();
      const reviewFirewallRequestBuilder = new RequestBuilder(`/api/v1/moderations/review_firewall/${eventId}`);
      await reviewFirewallRequestBuilder.buildUser({ with: ['review:firewall'] });

      const { response, responseBody } = await reviewFirewallRequestBuilder.post({});

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"action" é um campo obrigatório.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'action',
        type: 'any.required',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With an invalid "action"', async () => {
      const eventId = randomUUID();
      const reviewFirewallRequestBuilder = new RequestBuilder(`/api/v1/moderations/review_firewall/${eventId}`);
      await reviewFirewallRequestBuilder.buildUser({ with: ['review:firewall'] });

      const { response, responseBody } = await reviewFirewallRequestBuilder.post({
        action: 'review',
      });

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"action" deve possuir um dos seguintes valores: "confirm", "undo".',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'action',
        type: 'any.only',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With an "id" that does not exist', async () => {
      const eventId = randomUUID();
      const reviewFirewallRequestBuilder = new RequestBuilder(`/api/v1/moderations/review_firewall/${eventId}`);
      await reviewFirewallRequestBuilder.buildUser({ with: ['review:firewall'] });

      const { response, responseBody } = await reviewFirewallRequestBuilder.post({
        action: 'undo',
      });

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: `O id "${eventId}" não foi encontrado no sistema.`,
        action: 'Verifique se o "id" está digitado corretamente.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:FIREWALL:VALIDATE_AND_GET_FIREWALL_EVENT_TO_REVIEW:NOT_FOUND',
        key: 'id',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With an "id" that is not a firewall event', async () => {
      const user = await orchestrator.createUser();

      await orchestrator.createContent({
        owner_id: user.id,
        status: 'published',
        title: 'Create event',
      });
      const lastEvent = await orchestrator.getLastEvent();

      const reviewFirewallRequestBuilder = new RequestBuilder(`/api/v1/moderations/review_firewall/${lastEvent.id}`);
      await reviewFirewallRequestBuilder.buildUser({ with: ['review:firewall'] });

      const { response, responseBody } = await reviewFirewallRequestBuilder.post({
        action: 'undo',
      });

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: `O id "${lastEvent.id}" não foi encontrado no sistema.`,
        action: 'Verifique se o "id" está digitado corretamente.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:FIREWALL:VALIDATE_AND_GET_FIREWALL_EVENT_TO_REVIEW:NOT_FOUND',
        key: 'id',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('Review the same event twice', async () => {
      const usersRequestBuilder = new RequestBuilder('/api/v1/users');

      // Create users
      const { responseBody: user1 } = await usersRequestBuilder.post({
        username: 'firstUser',
        email: 'first-user@gmail.com',
        password: 'password',
      });
      const { responseBody: user2 } = await usersRequestBuilder.post({
        username: 'secondUser',
        email: 'second-user@gmail.com',
        password: 'password',
      });
      const { response: user3Response } = await usersRequestBuilder.post({
        username: 'thirdUser',
        email: 'third-user@gmail.com',
        password: 'password',
      });

      expect.soft(user3Response.status).toBe(429);

      // Check firewall side-effect
      const firewallEvent = await orchestrator.getLastEvent();

      expect(firewallEvent.type).toBe('firewall:block_users');
      expect(firewallEvent.metadata.users).toStrictEqual([user1.id, user2.id]);

      // Review firewall
      const reviewFirewallRequestBuilder = new RequestBuilder(
        `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
      );
      await reviewFirewallRequestBuilder.buildUser({ with: ['review:firewall'] });

      const { response } = await reviewFirewallRequestBuilder.post({
        action: 'confirm',
      });

      expect.soft(response.status).toBe(200);

      // Review firewall again
      const { response: responseAgain, responseBody: responseAgainBody } = await reviewFirewallRequestBuilder.post({
        action: 'undo',
      });

      expect.soft(responseAgain.status).toBe(400);

      expect(responseAgainBody).toStrictEqual({
        name: 'ValidationError',
        message: 'Você está tentando analisar um evento que já foi analisado.',
        action: 'Utilize um "id" que aponte para um evento de firewall que ainda não foi analisado.',
        status_code: 400,
        error_id: responseAgainBody.error_id,
        request_id: responseAgainBody.request_id,
        error_location_code: 'MODEL:FIREWALL:VALIDATE_AND_GET_FIREWALL_EVENT_TO_REVIEW:EVENT_ALREADY_REVIEWED',
        key: 'id',
      });
    });

    test('Review related events twice', async () => {
      const usersRequestBuilder = new RequestBuilder('/api/v1/users');

      // Create users
      const { responseBody: user1 } = await usersRequestBuilder.post({
        username: 'firstUser',
        email: 'first-user@gmail.com',
        password: 'password',
      });
      const { responseBody: user2 } = await usersRequestBuilder.post({
        username: 'secondUser',
        email: 'second-user@gmail.com',
        password: 'password',
      });
      const { response: user3Response } = await usersRequestBuilder.post({
        username: 'thirdUser',
        email: 'third-user@gmail.com',
        password: 'password',
      });
      const firewallEvent1 = await orchestrator.getLastEvent();

      const { response: user4Response } = await usersRequestBuilder.post({
        username: 'fourthUser',
        email: 'fourth-user@gmail.com',
        password: 'password',
      });
      const firewallEvent2 = await orchestrator.getLastEvent();

      expect.soft(user3Response.status).toBe(429);
      expect.soft(user4Response.status).toBe(429);

      // Check firewall side-effect
      expect(firewallEvent1.type).toBe('firewall:block_users');
      expect(firewallEvent2.type).toBe('firewall:block_users');

      expect(firewallEvent1.metadata.users).toStrictEqual([user1.id, user2.id]);

      // Review firewall
      const reviewEventRequestBuilder = new RequestBuilder(`/api/v1/moderations/review_firewall`);
      await reviewEventRequestBuilder.buildUser({ with: ['review:firewall'] });

      const { response } = await reviewEventRequestBuilder.post(`/${firewallEvent1.id}`, {
        action: 'confirm',
      });

      expect.soft(response.status).toBe(200);

      // Review related event
      const { response: responseAgain, responseBody: responseAgainBody } = await reviewEventRequestBuilder.post(
        `/${firewallEvent2.id}`,
        { action: 'undo' },
      );

      expect.soft(responseAgain.status).toBe(400);

      expect(responseAgainBody).toStrictEqual({
        name: 'ValidationError',
        message: 'Você está tentando analisar um evento que já foi analisado.',
        action: 'Utilize um "id" que aponte para um evento de firewall que ainda não foi analisado.',
        status_code: 400,
        error_id: responseAgainBody.error_id,
        request_id: responseAgainBody.request_id,
        error_location_code: 'MODEL:FIREWALL:VALIDATE_AND_GET_FIREWALL_EVENT_TO_REVIEW:EVENT_ALREADY_REVIEWED',
        key: 'id',
      });
    });

    describe('With action = "undo"', () => {
      test('With a "firewall:block_users" event', async () => {
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');

        // Create users
        const ignoredUser = await orchestrator.createUser();

        const { responseBody: user1ResponseBody } = await usersRequestBuilder.post({
          username: 'firstUser',
          email: 'first-user@gmail.com',
          password: 'password',
        });
        await orchestrator.activateUser(user1ResponseBody);

        const user1 = await user.findOneById(user1ResponseBody.id, { withBalance: true });
        expect(user1.features).toStrictEqual([
          'create:session',
          'read:session',
          'create:content',
          'create:content:text_root',
          'create:content:text_child',
          'update:content',
          'update:user',
        ]);

        const { responseBody: user2ResponseBody } = await usersRequestBuilder.post({
          username: 'secondUser',
          email: 'second-user@gmail.com',
          password: 'password',
        });

        const user2 = await user.findOneById(user2ResponseBody.id, { withBalance: true });
        expect(user2.features).toStrictEqual(['read:activation_token']);

        const { response: user3Response } = await usersRequestBuilder.post({
          username: 'thirdUser',
          email: 'third-user@gmail.com',
          password: 'password',
        });

        expect.soft(user3Response.status).toBe(429);

        // Check firewall side-effect
        const firewallEvent = await orchestrator.getLastEvent();
        expect(firewallEvent.metadata.users).toStrictEqual([user1.id, user2.id]);

        // Undo firewall side-effect
        const reviewFirewallRequestBuilder = new RequestBuilder(
          `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
        );
        const firewallUser = await reviewFirewallRequestBuilder.buildUser({
          with: ['read:firewall', 'review:firewall'],
        });

        const { response, responseBody } = await reviewFirewallRequestBuilder.post({
          action: 'undo',
        });

        expect.soft(response.status).toBe(200);

        expect.soft(user1.features).toStrictEqual(expect.arrayContaining(responseBody.affected.users[0].features));
        expect.soft(user2.features).toStrictEqual(expect.arrayContaining(responseBody.affected.users[1].features));
        expect(responseBody).toStrictEqual({
          affected: {
            users: [
              mapUserData({ ...user1, features: expect.arrayContaining(user1.features) }),
              mapUserData({ ...user2, features: expect.arrayContaining(user2.features) }),
            ],
          },
          events: [
            mapFirewallEventData(firewallEvent),
            {
              created_at: responseBody.events[1].created_at,
              id: responseBody.events[1].id,
              metadata: {
                related_events: [firewallEvent.id],
                users: firewallEvent.metadata.users,
              },
              originator_user_id: firewallUser.id,
              type: 'moderation:unblock_users',
            },
          ],
        });

        const createdEventResponse = responseBody.events[1];
        expect(Date.parse(createdEventResponse.created_at)).not.toBeNaN();
        expect(uuidVersion(createdEventResponse.id)).toBe(4);

        // Check users
        const user1AfterUndo = await user.findOneById(user1.id, { withBalance: true });
        const user2AfterUndo = await user.findOneById(user2.id, { withBalance: true });
        const ignoredUserAfterUndo = await user.findOneById(ignoredUser.id, { withBalance: true });

        expect(ignoredUserAfterUndo).toStrictEqual(ignoredUser);

        expect(user1AfterUndo).toStrictEqual({
          ...user1,
          features: responseBody.affected.users[0].features,
        });

        expect(user2AfterUndo).toStrictEqual({
          ...user2,
          features: responseBody.affected.users[1].features,
        });
      });

      test('With a "firewall:block_users" event without "read:firewall" feature', async () => {
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');

        // Create users
        await usersRequestBuilder.post({
          username: 'firstUser',
          email: 'first-user@gmail.com',
          password: 'password',
        });

        await usersRequestBuilder.post({
          username: 'secondUser',
          email: 'second-user@gmail.com',
          password: 'password',
        });

        const { response: user3Response } = await usersRequestBuilder.post({
          username: 'thirdUser',
          email: 'third-user@gmail.com',
          password: 'password',
        });

        expect.soft(user3Response.status).toBe(429);

        // Check firewall side-effect
        const firewallEvent = await orchestrator.getLastEvent();
        expect(firewallEvent.type).toBe('firewall:block_users');

        // Undo firewall side-effect
        const reviewFirewallRequestBuilder = new RequestBuilder(
          `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
        );
        await reviewFirewallRequestBuilder.buildUser({ with: ['review:firewall'] });

        const { response, responseBody } = await reviewFirewallRequestBuilder.post({
          action: 'undo',
        });

        expect.soft(response.status).toBe(200);

        expect(responseBody).toStrictEqual({});

        // Check "undo" event
        const undoEvent = await orchestrator.getLastEvent();
        expect(undoEvent.type).toBe('moderation:unblock_users');
      });

      test('With a "firewall:block_contents:text_root" event', async () => {
        // Create user and contents
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const user1 = await contentsRequestBuilder.buildUser();

        const ignoredUser = await orchestrator.createUser();
        let ignoredContent = await orchestrator.createContent({
          owner_id: ignoredUser.id,
          status: 'published',
          title: 'Ignored content',
        });
        ignoredContent = await content.findOne({ where: { id: ignoredContent.id } });

        const { responseBody: content1 } = await createContentViaApi(contentsRequestBuilder);
        const { responseBody: content2 } = await createContentViaApi(contentsRequestBuilder);
        const { response: responseContent3 } = await createContentViaApi(contentsRequestBuilder);

        expect.soft(responseContent3.status).toBe(429);

        // Check firewall side-effect
        const content1AfterSideEffect = await content.findOne({ where: { id: content1.id } });
        const content2AfterSideEffect = await content.findOne({ where: { id: content2.id } });

        expect(content1AfterSideEffect.status).toBe('firewall');
        expect(content2AfterSideEffect.status).toBe('firewall');

        const firewallEvent = await orchestrator.getLastEvent();
        expect(firewallEvent.metadata.contents).toStrictEqual([content1.id, content2.id]);

        // Undo firewall side-effect
        const reviewFirewallRequestBuilder = new RequestBuilder(
          `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
        );
        const firewallUser = await reviewFirewallRequestBuilder.buildUser({
          with: ['read:firewall', 'review:firewall'],
        });

        const { response, responseBody } = await reviewFirewallRequestBuilder.post({
          action: 'undo',
        });

        const expectedAffectedContents = [mapContentData(content1), mapContentData(content2)];

        expect.soft(response.status).toBe(200);

        expect.soft(expectedAffectedContents).toStrictEqual(expect.arrayContaining(responseBody.affected.contents));
        expect(responseBody).toStrictEqual({
          affected: {
            contents: expect.arrayContaining(expectedAffectedContents),
            users: [mapUserData(user1)],
          },
          events: [
            mapFirewallEventData(firewallEvent),
            {
              created_at: responseBody.events[1].created_at,
              id: responseBody.events[1].id,
              metadata: {
                related_events: [firewallEvent.id],
                contents: firewallEvent.metadata.contents,
              },
              originator_user_id: firewallUser.id,
              type: 'moderation:unblock_contents:text_root',
            },
          ],
        });

        const createdEventResponse = responseBody.events[1];
        expect(Date.parse(createdEventResponse.created_at)).not.toBeNaN();
        expect(uuidVersion(createdEventResponse.id)).toBe(4);

        // Check contents
        const content1AfterUndo = await content.findOne({ where: { id: content1.id } });
        const content2AfterUndo = await content.findOne({ where: { id: content2.id } });
        const ignoredContentAfterUndo = await content.findOne({ where: { id: ignoredContent.id } });

        expect(ignoredContentAfterUndo).toStrictEqual(ignoredContent);

        expect(content1AfterUndo).toStrictEqual({
          ...content1AfterSideEffect,
          status: 'published',
        });

        expect(content2AfterUndo).toStrictEqual({
          ...content2AfterSideEffect,
          status: 'published',
        });
      });

      test('With a "firewall:block_contents:text_root" event with TabCoins and a deleted content', async () => {
        // Create users and contents
        const ignoredUser = await orchestrator.createUser();

        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');

        const user1 = await contentsRequestBuilder.buildUser();
        const { responseBody: content1 } = await createContentViaApi(contentsRequestBuilder);

        const user2 = await contentsRequestBuilder.buildUser();
        const { responseBody: content2 } = await createContentViaApi(contentsRequestBuilder);

        await orchestrator.createRate(content1, 8);
        await orchestrator.createRate(content2, 15);

        const content1Deleted = await orchestrator.updateContent(content1.id, { status: 'deleted' });

        const user1AfterContentDeleted = await user.findOneById(user1.id, { withBalance: true });
        expect(user1AfterContentDeleted.tabcoins).toBe(0);

        const user2AfterRate = await user.findOneById(user2.id, { withBalance: true });
        expect(user2AfterRate.tabcoins).toBe(15);

        await contentsRequestBuilder.setUser(user1);
        const { response: responseContent3 } = await createContentViaApi(contentsRequestBuilder);

        expect.soft(responseContent3.status).toBe(429);

        // Check firewall side-effect
        const content1AfterSideEffect = await content.findOne({ where: { id: content1.id } });
        const content2AfterSideEffect = await content.findOne({ where: { id: content2.id } });

        expect(content1AfterSideEffect.status).toBe('firewall');
        expect(content2AfterSideEffect.status).toBe('firewall');

        const firewallEvent = await orchestrator.getLastEvent();
        expect(firewallEvent.metadata.contents).toStrictEqual([content1.id, content2.id]);

        // Undo firewall side-effect
        const reviewFirewallRequestBuilder = new RequestBuilder(
          `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
        );
        const firewallUser = await reviewFirewallRequestBuilder.buildUser({
          with: ['read:firewall', 'review:firewall'],
        });

        const { response, responseBody } = await reviewFirewallRequestBuilder.post({
          action: 'undo',
        });

        expect.soft(response.status).toBe(200);

        expect(responseBody).toStrictEqual({
          affected: {
            contents: [
              mapContentData(content1Deleted),
              mapContentData({ ...content2, tabcoins: 15, tabcoins_credit: 15 }),
            ],
            users: [mapUserData(user1), mapUserData(user2AfterRate)],
          },
          events: [
            mapFirewallEventData(firewallEvent),
            {
              created_at: responseBody.events[1].created_at,
              id: responseBody.events[1].id,
              metadata: {
                related_events: [firewallEvent.id],
                contents: firewallEvent.metadata.contents,
              },
              originator_user_id: firewallUser.id,
              type: 'moderation:unblock_contents:text_root',
            },
          ],
        });

        // Check contents
        const content1AfterUndo = await content.findOne({ where: { id: content1.id } });
        const content2AfterUndo = await content.findOne({ where: { id: content2.id } });

        expect(content1AfterUndo.status).toBe('deleted');
        expect(content2AfterUndo.status).toBe('published');

        // Check users
        const ignoredUserAfterUndo = await user.findOneById(ignoredUser.id, { withBalance: true });
        const user1AfterUndo = await user.findOneById(user1.id, { withBalance: true });
        const user2AfterUndo = await user.findOneById(user2.id, { withBalance: true });

        expect(ignoredUserAfterUndo).toStrictEqual(ignoredUser);
        expect(user1AfterUndo).toStrictEqual(user1AfterContentDeleted);
        expect(user2AfterUndo).toStrictEqual(user2AfterRate);
      });

      test('With a "firewall:block_contents:text_root" event with a content with negative TabCoins', async () => {
        // Create users and contents
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');

        const user1 = await contentsRequestBuilder.buildUser();
        const { responseBody: content1 } = await createContentViaApi(contentsRequestBuilder);
        const { responseBody: content2 } = await createContentViaApi(contentsRequestBuilder);

        await orchestrator.createRate(content2, 1);
        await orchestrator.createRate(content2, -3);

        const user1AfterRate = await user.findOneById(user1.id, { withBalance: true });
        expect(user1AfterRate.tabcoins).toBe(-2);

        await contentsRequestBuilder.setUser(user1);
        const { response: responseContent3 } = await createContentViaApi(contentsRequestBuilder);

        expect.soft(responseContent3.status).toBe(429);

        // Check firewall side-effect
        const content1AfterSideEffect = await content.findOne({ where: { id: content1.id } });
        const content2AfterSideEffect = await content.findOne({ where: { id: content2.id } });

        expect(content1AfterSideEffect.status).toBe('firewall');
        expect(content2AfterSideEffect.status).toBe('firewall');

        const firewallEvent = await orchestrator.getLastEvent();
        expect(firewallEvent.metadata.contents).toStrictEqual([content1.id, content2.id]);

        // Undo firewall side-effect
        const reviewFirewallRequestBuilder = new RequestBuilder(
          `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
        );
        const firewallUser = await reviewFirewallRequestBuilder.buildUser({
          with: ['read:firewall', 'review:firewall'],
        });

        const { response, responseBody } = await reviewFirewallRequestBuilder.post({
          action: 'undo',
        });

        const expectedAffectedContents = [
          mapContentData(content1),
          mapContentData({ ...content2, tabcoins: -2, tabcoins_credit: 1, tabcoins_debit: -3 }),
        ];

        expect.soft(response.status).toBe(200);

        expect.soft(expectedAffectedContents).toStrictEqual(expect.arrayContaining(responseBody.affected.contents));
        expect(responseBody).toStrictEqual({
          affected: {
            contents: expect.arrayContaining(expectedAffectedContents),
            users: [mapUserData(user1AfterRate)],
          },
          events: [
            mapFirewallEventData(firewallEvent),
            {
              created_at: responseBody.events[1].created_at,
              id: responseBody.events[1].id,
              metadata: {
                related_events: [firewallEvent.id],
                contents: firewallEvent.metadata.contents,
              },
              originator_user_id: firewallUser.id,
              type: 'moderation:unblock_contents:text_root',
            },
          ],
        });

        // Check users
        const user1AfterUndo = await user.findOneById(user1.id, { withBalance: true });
        expect(user1AfterUndo).toStrictEqual(user1AfterRate);
      });

      test('With three "firewall:block_contents:text_root" events for the same contents', async () => {
        // Create user and contents
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const defaultUser = await contentsRequestBuilder.buildUser();

        const { responseBody: content1 } = await createContentViaApi(contentsRequestBuilder);
        const { responseBody: content2 } = await createContentViaApi(contentsRequestBuilder);
        const { response: responseContent3 } = await createContentViaApi(contentsRequestBuilder);
        const firewallEvent1 = await orchestrator.getLastEvent();
        const { response: responseContent4 } = await createContentViaApi(contentsRequestBuilder);
        const firewallEvent2 = await orchestrator.getLastEvent();
        const { response: responseContent5 } = await createContentViaApi(contentsRequestBuilder);
        const firewallEvent3 = await orchestrator.getLastEvent();

        expect.soft(responseContent3.status).toBe(429);
        expect.soft(responseContent4.status).toBe(429);
        expect.soft(responseContent5.status).toBe(429);

        // Check firewall side-effect
        const content1AfterSideEffect = await content.findOne({ where: { id: content1.id } });
        const content2AfterSideEffect = await content.findOne({ where: { id: content2.id } });

        expect(content1AfterSideEffect.status).toBe('firewall');
        expect(content2AfterSideEffect.status).toBe('firewall');

        expect(firewallEvent1.type).toBe('firewall:block_contents:text_root');
        expect(firewallEvent2.type).toBe('firewall:block_contents:text_root');
        expect(firewallEvent3.type).toBe('firewall:block_contents:text_root');

        expect(firewallEvent1.metadata.contents).toStrictEqual([content1.id, content2.id]);

        expect(firewallEvent2).toStrictEqual({
          ...firewallEvent1,
          id: firewallEvent2.id,
          created_at: firewallEvent2.created_at,
        });

        expect(firewallEvent3).toStrictEqual({
          ...firewallEvent1,
          id: firewallEvent3.id,
          created_at: firewallEvent3.created_at,
        });

        expect(firewallEvent1.id).not.toBe(firewallEvent2.id);
        expect(firewallEvent1.id).not.toBe(firewallEvent3.id);
        expect(firewallEvent2.id).not.toBe(firewallEvent3.id);

        // Undo firewall side-effect from second event
        const reviewFirewallRequestBuilder = new RequestBuilder(
          `/api/v1/moderations/review_firewall/${firewallEvent2.id}`,
        );
        const firewallUser = await reviewFirewallRequestBuilder.buildUser({
          with: ['read:firewall', 'review:firewall'],
        });

        const { response, responseBody } = await reviewFirewallRequestBuilder.post({
          action: 'undo',
        });

        const expectedAffectedContents = [mapContentData(content1), mapContentData(content2)];
        const expectedRelatedEvents = [firewallEvent1.id, firewallEvent2.id, firewallEvent3.id];
        const expectedEvents = [
          mapFirewallEventData(firewallEvent1),
          mapFirewallEventData(firewallEvent2),
          mapFirewallEventData(firewallEvent3),
          {
            created_at: responseBody.events[3].created_at,
            id: responseBody.events[3].id,
            metadata: {
              related_events: expect.arrayContaining(expectedRelatedEvents),
              contents: [content1.id, content2.id],
            },
            originator_user_id: firewallUser.id,
            type: 'moderation:unblock_contents:text_root',
          },
        ];

        expect.soft(response.status).toBe(200);

        expect.soft(expectedAffectedContents).toStrictEqual(expect.arrayContaining(responseBody.affected.contents));
        expect.soft(expectedEvents).toStrictEqual(expect.arrayContaining(responseBody.events));
        expect
          .soft(expectedRelatedEvents)
          .toStrictEqual(expect.arrayContaining(responseBody.events[3].metadata.related_events));
        expect(responseBody).toStrictEqual({
          affected: {
            contents: expect.arrayContaining(expectedAffectedContents),
            users: [mapUserData(defaultUser)],
          },
          events: expect.arrayContaining(expectedEvents),
        });

        const createdEventResponse = responseBody.events[1];
        expect(Date.parse(createdEventResponse.created_at)).not.toBeNaN();

        // Check contents
        const content1AfterUndo = await content.findOne({ where: { id: content1.id } });
        const content2AfterUndo = await content.findOne({ where: { id: content2.id } });

        expect(content1AfterUndo).toStrictEqual({
          ...content1AfterSideEffect,
          status: 'published',
        });

        expect(content2AfterUndo).toStrictEqual({
          ...content2AfterSideEffect,
          status: 'published',
        });
      });

      test('With a "firewall:block_contents:text_child" event', async () => {
        // Create user and contents
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const user1 = await contentsRequestBuilder.buildUser();

        const ignoredUser = await orchestrator.createUser();
        let rootContent = await orchestrator.createContent({
          owner_id: ignoredUser.id,
          status: 'published',
          title: 'Ignored content',
        });

        const { responseBody: content1 } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContent.id,
        });
        const { responseBody: content2 } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: content1.id,
        });

        await orchestrator.createContent({
          body: 'Ignored child content',
          owner_id: ignoredUser.id,
          status: 'published',
          parent_id: content1.id,
        });

        rootContent = await content.findOne({ where: { id: rootContent.id } });

        const { response: responseContent3 } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContent.id,
        });

        expect.soft(responseContent3.status).toBe(429);

        // Check firewall side-effect
        const content1AfterSideEffect = await content.findOne({ where: { id: content1.id } });
        const content2AfterSideEffect = await content.findOne({ where: { id: content2.id } });

        expect(content1AfterSideEffect.status).toBe('firewall');
        expect(content2AfterSideEffect.status).toBe('firewall');

        const firewallEvent = await orchestrator.getLastEvent();
        expect(firewallEvent.metadata.contents).toStrictEqual([content1.id, content2.id]);

        // Undo firewall side-effect
        const reviewFirewallRequestBuilder = new RequestBuilder(
          `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
        );
        const firewallUser = await reviewFirewallRequestBuilder.buildUser({
          with: ['read:firewall', 'review:firewall'],
        });

        const { response, responseBody } = await reviewFirewallRequestBuilder.post({
          action: 'undo',
        });

        const expectedAffectedContents = [
          mapContentData({ ...content1, children_deep_count: 2 }),
          mapContentData(content2),
        ];

        expect.soft(response.status).toBe(200);

        expect.soft(expectedAffectedContents).toStrictEqual(expect.arrayContaining(responseBody.affected.contents));
        expect(responseBody).toStrictEqual({
          affected: {
            contents: expect.arrayContaining(expectedAffectedContents),
            users: [mapUserData(user1)],
          },
          events: [
            mapFirewallEventData(firewallEvent),
            {
              created_at: responseBody.events[1].created_at,
              id: responseBody.events[1].id,
              metadata: {
                related_events: [firewallEvent.id],
                contents: firewallEvent.metadata.contents,
              },
              originator_user_id: firewallUser.id,
              type: 'moderation:unblock_contents:text_child',
            },
          ],
        });

        const createdEventResponse = responseBody.events[1];
        expect(Date.parse(createdEventResponse.created_at)).not.toBeNaN();
        expect(uuidVersion(createdEventResponse.id)).toBe(4);

        // Check contents
        const content1AfterUndo = await content.findOne({ where: { id: content1.id } });
        const content2AfterUndo = await content.findOne({ where: { id: content2.id } });
        const rootContentAfterUndo = await content.findOne({ where: { id: rootContent.id } });

        expect(rootContentAfterUndo).toStrictEqual(rootContent);

        expect(content1AfterUndo).toStrictEqual({
          ...content1AfterSideEffect,
          children_deep_count: '2',
          status: 'published',
        });

        expect(content2AfterUndo).toStrictEqual({
          ...content2AfterSideEffect,
          status: 'published',
        });
      });

      test('With a "firewall:block_contents:text_child" event and a deleted content', async () => {
        // Create user and contents
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const user1 = await contentsRequestBuilder.buildUser();

        const ignoredUser = await orchestrator.createUser();
        const rootContent = await orchestrator.createContent({
          owner_id: ignoredUser.id,
          status: 'published',
          title: 'Ignored content',
        });

        const { responseBody: content1 } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContent.id,
        });
        const { responseBody: content2 } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContent.id,
        });

        const content2Deleted = await content.update(content2.id, { status: 'deleted' });

        const { response: responseContent3 } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContent.id,
        });

        expect.soft(responseContent3.status).toBe(429);

        // Check firewall side-effect
        const content1AfterSideEffect = await content.findOne({ where: { id: content1.id } });
        const content2AfterSideEffect = await content.findOne({ where: { id: content2.id } });

        expect(content1AfterSideEffect.status).toBe('firewall');
        expect(content2AfterSideEffect.status).toBe('firewall');

        const firewallEvent = await orchestrator.getLastEvent();
        expect(firewallEvent.metadata.contents).toStrictEqual([content1.id, content2.id]);

        // Undo firewall side-effect
        const reviewFirewallRequestBuilder = new RequestBuilder(
          `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
        );
        const firewallUser = await reviewFirewallRequestBuilder.buildUser({
          with: ['read:firewall', 'review:firewall'],
        });

        const { response, responseBody } = await reviewFirewallRequestBuilder.post({
          action: 'undo',
        });

        const expectedAffectedContents = [mapContentData(content1), mapContentData(content2Deleted)];

        expect.soft(response.status).toBe(200);

        expect.soft(expectedAffectedContents).toStrictEqual(expect.arrayContaining(responseBody.affected.contents));
        expect(responseBody).toStrictEqual({
          affected: {
            contents: expect.arrayContaining(expectedAffectedContents),
            users: [mapUserData(user1)],
          },
          events: [
            mapFirewallEventData(firewallEvent),
            {
              created_at: responseBody.events[1].created_at,
              id: responseBody.events[1].id,
              metadata: {
                related_events: [firewallEvent.id],
                contents: firewallEvent.metadata.contents,
              },
              originator_user_id: firewallUser.id,
              type: 'moderation:unblock_contents:text_child',
            },
          ],
        });

        // Check contents
        const content1AfterUndo = await content.findOne({ where: { id: content1.id } });
        const content2AfterUndo = await content.findOne({ where: { id: content2.id } });

        expect(content1AfterUndo.status).toBe('published');
        expect(content2AfterUndo.status).toBe('deleted');
      });

      test('With a "firewall:block_contents:text_child" event and contents deleted before the firewall catch', async () => {
        // Create user and contents
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const user1 = await contentsRequestBuilder.buildUser();

        const ignoredUser = await orchestrator.createUser();
        const rootContent = await orchestrator.createContent({
          owner_id: ignoredUser.id,
          status: 'published',
          title: 'Ignored content',
        });

        const { responseBody: content1 } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContent.id,
        });
        const { responseBody: content2 } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContent.id,
        });

        const content1Deleted = await content.update(content1.id, { status: 'deleted' });
        const content2Deleted = await content.update(content2.id, { status: 'deleted' });

        const { response: responseContent3 } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContent.id,
        });

        expect.soft(responseContent3.status).toBe(429);

        // Check firewall side-effect
        const content1AfterSideEffect = await content.findOne({ where: { id: content1.id } });
        const content2AfterSideEffect = await content.findOne({ where: { id: content2.id } });

        expect(content1AfterSideEffect.status).toBe('firewall');
        expect(content2AfterSideEffect.status).toBe('firewall');

        const firewallEvent = await orchestrator.getLastEvent();
        expect(firewallEvent.metadata.contents).toStrictEqual([content1.id, content2.id]);

        // Undo firewall side-effect
        const reviewFirewallRequestBuilder = new RequestBuilder(
          `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
        );
        const firewallUser = await reviewFirewallRequestBuilder.buildUser({
          with: ['read:firewall', 'review:firewall'],
        });

        const { response, responseBody } = await reviewFirewallRequestBuilder.post({
          action: 'undo',
        });

        const expectedAffectedContents = [
          mapContentData({ ...content1Deleted, owner_username: user1.username }),
          mapContentData({ ...content2Deleted, owner_username: user1.username }),
        ];

        expect.soft(response.status).toBe(200);

        expect.soft(expectedAffectedContents).toStrictEqual(expect.arrayContaining(responseBody.affected.contents));
        expect(responseBody).toStrictEqual({
          affected: {
            contents: expect.arrayContaining(expectedAffectedContents),
            users: [mapUserData(user1)],
          },
          events: [
            mapFirewallEventData(firewallEvent),
            {
              created_at: responseBody.events[1].created_at,
              id: responseBody.events[1].id,
              metadata: {
                related_events: [firewallEvent.id],
                contents: [content1.id, content2.id],
              },
              originator_user_id: firewallUser.id,
              type: 'moderation:unblock_contents:text_child',
            },
          ],
        });

        // Check contents
        const content1AfterUndo = await content.findOne({ where: { id: content1.id } });
        const content2AfterUndo = await content.findOne({ where: { id: content2.id } });

        expect(content1AfterUndo.status).toBe('deleted');
        expect(content2AfterUndo.status).toBe('deleted');
      });
    });

    describe('With action = "confirm"', () => {
      test('With a "firewall:block_users" event', async () => {
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');

        // Create users
        const ignoredUser = await orchestrator.createUser();

        const { responseBody: user1ResponseBody } = await usersRequestBuilder.post({
          username: 'firstUser',
          email: 'first-user@gmail.com',
          password: 'password',
        });
        await orchestrator.activateUser(user1ResponseBody);

        const user1 = await user.findOneById(user1ResponseBody.id, { withBalance: true });
        const user1FeaturesNotRemoved = [
          'create:content',
          'create:content:text_root',
          'create:content:text_child',
          'update:content',
          'update:user',
        ];
        expect(user1.features).toStrictEqual(['create:session', 'read:session', ...user1FeaturesNotRemoved]);

        const { responseBody: user2ResponseBody } = await usersRequestBuilder.post({
          username: 'secondUser',
          email: 'second-user@gmail.com',
          password: 'password',
        });

        const user2 = await user.findOneById(user2ResponseBody.id, { withBalance: true });
        expect(user2.features).toStrictEqual(['read:activation_token']);

        const { response: user3Response } = await usersRequestBuilder.post({
          username: 'thirdUser',
          email: 'third-user@gmail.com',
          password: 'password',
        });

        expect.soft(user3Response.status).toBe(429);

        // Check firewall side-effect
        const firewallEvent = await orchestrator.getLastEvent();
        expect(firewallEvent.metadata.users).toStrictEqual([user1ResponseBody.id, user2ResponseBody.id]);

        // Confirm firewall side-effect
        const reviewFirewallRequestBuilder = new RequestBuilder(
          `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
        );
        const firewallUser = await reviewFirewallRequestBuilder.buildUser({
          with: ['read:firewall', 'review:firewall'],
        });

        const { response, responseBody } = await reviewFirewallRequestBuilder.post({
          action: 'confirm',
        });

        expect.soft(response.status).toBe(200);

        expect(responseBody).toStrictEqual({
          affected: {
            users: [
              mapUserData({
                ...user1ResponseBody,
                features: [...user1FeaturesNotRemoved, 'nuked'],
                updated_at: user1.updated_at.toISOString(),
              }),
              mapUserData({
                ...user2ResponseBody,
                features: ['nuked'],
                updated_at: user2.updated_at.toISOString(),
              }),
            ],
          },
          events: [
            mapFirewallEventData(firewallEvent),
            {
              created_at: responseBody.events[1].created_at,
              id: responseBody.events[1].id,
              metadata: {
                related_events: [firewallEvent.id],
                users: firewallEvent.metadata.users,
              },
              originator_user_id: firewallUser.id,
              type: 'moderation:block_users',
            },
          ],
        });

        const createdEventResponse = responseBody.events[1];
        expect(Date.parse(createdEventResponse.created_at)).not.toBeNaN();
        expect(uuidVersion(createdEventResponse.id)).toBe(4);

        // Check users
        const user1AfterConfirm = await user.findOneById(user1ResponseBody.id, { withBalance: true });
        const user2AfterConfirm = await user.findOneById(user2ResponseBody.id, { withBalance: true });
        const ignoredUserAfterConfirm = await user.findOneById(ignoredUser.id, { withBalance: true });

        expect(ignoredUserAfterConfirm).toStrictEqual(ignoredUser);

        expect(user1AfterConfirm).toStrictEqual({
          ...user1,
          features: [...user1FeaturesNotRemoved, 'nuked'],
        });

        expect(user2AfterConfirm).toStrictEqual({
          ...user2,
          features: ['nuked'],
        });
      });

      test('With a "firewall:block_contents:text_root" event with TabCoins', async () => {
        // Create users and contents
        const ignoredUser = await orchestrator.createUser();

        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');

        const user1 = await contentsRequestBuilder.buildUser();
        const { responseBody: content1 } = await createContentViaApi(contentsRequestBuilder);

        const user2 = await contentsRequestBuilder.buildUser();
        const { responseBody: content2 } = await createContentViaApi(contentsRequestBuilder);

        await orchestrator.createRate(content1, 8);
        await orchestrator.createRate(content2, 15);

        const user1AfterRate = await user.findOneById(user1.id, { withBalance: true });
        expect(user1AfterRate.tabcoins).toBe(8);

        const user2AfterRate = await user.findOneById(user2.id, { withBalance: true });
        expect(user2AfterRate.tabcoins).toBe(15);

        await contentsRequestBuilder.setUser(user1);
        const { response: responseContent3 } = await createContentViaApi(contentsRequestBuilder);

        expect.soft(responseContent3.status).toBe(429);

        // Check firewall side-effect
        const content1AfterSideEffect = await content.findOne({ where: { id: content1.id } });
        const content2AfterSideEffect = await content.findOne({ where: { id: content2.id } });

        expect(content1AfterSideEffect.status).toBe('firewall');
        expect(content2AfterSideEffect.status).toBe('firewall');

        const firewallEvent = await orchestrator.getLastEvent();
        expect(firewallEvent.metadata.contents).toStrictEqual([content1.id, content2.id]);

        // Confirm firewall side-effect
        const reviewFirewallRequestBuilder = new RequestBuilder(
          `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
        );
        const firewallUser = await reviewFirewallRequestBuilder.buildUser({
          with: ['read:firewall', 'review:firewall'],
        });

        const { response, responseBody } = await reviewFirewallRequestBuilder.post({
          action: 'confirm',
        });

        expect.soft(response.status).toBe(200);

        expect(responseBody).toStrictEqual({
          affected: {
            contents: [
              mapContentData({
                ...content1,
                deleted_at: responseBody.affected.contents[0].deleted_at,
                owner_username: user1.username,
                status: 'deleted',
                tabcoins: 8,
                tabcoins_credit: 8,
              }),
              mapContentData({
                ...content2,
                deleted_at: responseBody.affected.contents[1].deleted_at,
                owner_username: user2.username,
                status: 'deleted',
                tabcoins: 15,
                tabcoins_credit: 15,
              }),
            ],
            users: [mapUserData(user1), mapUserData(user2)],
          },
          events: [
            mapFirewallEventData(firewallEvent),
            {
              created_at: responseBody.events[1].created_at,
              id: responseBody.events[1].id,
              metadata: {
                related_events: [firewallEvent.id],
                contents: firewallEvent.metadata.contents,
              },
              originator_user_id: firewallUser.id,
              type: 'moderation:block_contents:text_root',
            },
          ],
        });

        // Check contents
        const content1AfterConfirm = await content.findOne({ where: { id: content1.id } });
        const content2AfterConfirm = await content.findOne({ where: { id: content2.id } });

        expect(content1AfterConfirm.deleted_at.toISOString()).toBe(responseBody.affected.contents[0].deleted_at);
        expect(content1AfterConfirm.status).toBe('deleted');

        expect(content2AfterConfirm.deleted_at.toISOString()).toBe(responseBody.affected.contents[1].deleted_at);
        expect(content2AfterConfirm.status).toBe('deleted');

        // Check users
        const ignoredUserAfterConfirm = await user.findOneById(ignoredUser.id, { withBalance: true });
        const user1AfterConfirm = await user.findOneById(user1.id, { withBalance: true });
        const user2AfterConfirm = await user.findOneById(user2.id, { withBalance: true });

        expect(ignoredUserAfterConfirm).toStrictEqual(ignoredUser);
        expect(user1AfterConfirm).toStrictEqual({
          ...user1,
          tabcoins: 0,
          tabcash: 0,
        });
        expect(user2AfterConfirm).toStrictEqual({
          ...user2,
          tabcoins: 0,
          tabcash: 0,
        });
      });

      test('With a "firewall:block_contents:text_root" event with a content with negative TabCoins', async () => {
        // Create users and contents
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');

        const user1 = await contentsRequestBuilder.buildUser();
        const { responseBody: content1 } = await createContentViaApi(contentsRequestBuilder);
        const { responseBody: content2 } = await createContentViaApi(contentsRequestBuilder);

        await orchestrator.createRate(content1, -4);
        await orchestrator.createRate(content1, 1);
        await orchestrator.createRate(content2, 1);

        const user1AfterRate = await user.findOneById(user1.id, { withBalance: true });
        expect(user1AfterRate.tabcoins).toBe(-2);

        const { response: responseContent3 } = await createContentViaApi(contentsRequestBuilder);

        expect.soft(responseContent3.status).toBe(429);

        // Check firewall side-effect
        const content1AfterSideEffect = await content.findOne({ where: { id: content1.id } });
        const content2AfterSideEffect = await content.findOne({ where: { id: content2.id } });

        expect(content1AfterSideEffect.status).toBe('firewall');
        expect(content2AfterSideEffect.status).toBe('firewall');

        const firewallEvent = await orchestrator.getLastEvent();
        expect(firewallEvent.metadata.contents).toStrictEqual([content1.id, content2.id]);

        // Confirm firewall side-effect
        const reviewFirewallRequestBuilder = new RequestBuilder(
          `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
        );
        const firewallUser = await reviewFirewallRequestBuilder.buildUser({
          with: ['read:firewall', 'review:firewall'],
        });

        const { response, responseBody } = await reviewFirewallRequestBuilder.post({
          action: 'confirm',
        });

        const expectedAffectedContents = [
          mapContentData({
            ...content1,
            deleted_at: responseBody.affected.contents[0].deleted_at,
            owner_username: user1.username,
            status: 'deleted',
            tabcoins: -3,
            tabcoins_credit: 1,
            tabcoins_debit: -4,
          }),
          mapContentData({
            ...content2,
            deleted_at: responseBody.affected.contents[1].deleted_at,
            owner_username: user1.username,
            status: 'deleted',
            tabcoins: 1,
            tabcoins_credit: 1,
          }),
        ];

        expect.soft(response.status).toBe(200);

        expect.soft(expectedAffectedContents).toStrictEqual(expect.arrayContaining(responseBody.affected.contents));
        expect(responseBody).toStrictEqual({
          affected: {
            contents: expect.arrayContaining(expectedAffectedContents),
            users: [mapUserData({ ...user1, tabcoins: -3 })],
          },
          events: [
            mapFirewallEventData(firewallEvent),
            {
              created_at: responseBody.events[1].created_at,
              id: responseBody.events[1].id,
              metadata: {
                related_events: [firewallEvent.id],
                contents: firewallEvent.metadata.contents,
              },
              originator_user_id: firewallUser.id,
              type: 'moderation:block_contents:text_root',
            },
          ],
        });

        // Check users
        const user1AfterConfirm = await user.findOneById(user1.id, { withBalance: true });
        expect(user1AfterConfirm).toStrictEqual({
          ...user1,
          tabcoins: -3,
          tabcash: 0,
        });
      });

      test('With a "firewall:block_contents:text_child" event with a deleted content', async () => {
        // Create user and contents
        const ignoredUser = await orchestrator.createUser();
        let rootContent = await orchestrator.createContent({
          owner_id: ignoredUser.id,
          status: 'published',
          title: 'Ignored content',
        });

        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const user1 = await contentsRequestBuilder.buildUser();

        const { responseBody: content1 } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContent.id,
        });
        const { responseBody: content2 } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: content1.id,
        });

        await orchestrator.createContent({
          body: 'Ignored child content',
          owner_id: ignoredUser.id,
          status: 'published',
          parent_id: content1.id,
        });

        const content1Deleted = await orchestrator.updateContent(content1.id, { status: 'deleted' });

        rootContent = await content.findOne({ where: { id: rootContent.id } });

        const { response: responseContent3 } = await createContentViaApi(contentsRequestBuilder, {
          parent_id: rootContent.id,
        });

        expect.soft(responseContent3.status).toBe(429);

        // Check firewall side-effect
        const content1AfterSideEffect = await content.findOne({ where: { id: content1.id } });
        const content2AfterSideEffect = await content.findOne({ where: { id: content2.id } });

        expect(content1AfterSideEffect.status).toBe('firewall');
        expect(content2AfterSideEffect.status).toBe('firewall');

        const firewallEvent = await orchestrator.getLastEvent();
        expect(firewallEvent.metadata.contents).toStrictEqual([content1.id, content2.id]);

        // Confirm firewall side-effect
        const reviewFirewallRequestBuilder = new RequestBuilder(
          `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
        );
        const firewallUser = await reviewFirewallRequestBuilder.buildUser({
          with: ['read:firewall', 'review:firewall'],
        });

        const { response, responseBody } = await reviewFirewallRequestBuilder.post({
          action: 'confirm',
        });

        const expectedAffectedContents = [
          mapContentData({ ...content1Deleted, children_deep_count: 1, owner_username: user1.username }),
          mapContentData({
            ...content2,
            deleted_at: expect.any(String),
            owner_username: user1.username,
            status: 'deleted',
          }),
        ];

        expect.soft(response.status).toBe(200);

        expect.soft(expectedAffectedContents).toStrictEqual(expect.arrayContaining(responseBody.affected.contents));
        expect(responseBody).toStrictEqual({
          affected: {
            contents: expect.arrayContaining(expectedAffectedContents),
            users: [mapUserData(user1)],
          },
          events: [
            mapFirewallEventData(firewallEvent),
            {
              created_at: responseBody.events[1].created_at,
              id: responseBody.events[1].id,
              metadata: {
                related_events: [firewallEvent.id],
                contents: firewallEvent.metadata.contents,
              },
              originator_user_id: firewallUser.id,
              type: 'moderation:block_contents:text_child',
            },
          ],
        });

        const createdEventResponse = responseBody.events[1];
        expect(Date.parse(createdEventResponse.created_at)).not.toBeNaN();
        expect(uuidVersion(createdEventResponse.id)).toBe(4);

        // Check contents
        const content1AfterConfirm = await content.findOne({ where: { id: content1.id } });
        const content2AfterConfirm = await content.findOne({ where: { id: content2.id } });
        const rootContentAfterConfirm = await content.findOne({ where: { id: rootContent.id } });

        expect(rootContentAfterConfirm).toStrictEqual({
          ...rootContent,
          children_deep_count: '1',
        });

        expect(content1AfterConfirm.deleted_at.toISOString()).toBe(content1Deleted.deleted_at.toISOString());
        expect(content1AfterConfirm.status).toBe('deleted');

        const responseContent2 = responseBody.affected.contents.find((c) => c.id === content2.id);
        expect(content2AfterConfirm.deleted_at.toISOString()).toBe(responseContent2.deleted_at);
        expect(content2AfterConfirm.status).toBe('deleted');
      });
    });

    describe('Different firewall events containing an element in common', () => {
      test('Confirm with two "firewall:block_users" events', async () => {
        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const { response: response1, responseBody: user1 } = await usersRequestBuilder.post({
          username: 'request1',
          email: 'request1@gmail.com',
          password: 'password',
        });

        const createUserEvent1 = await orchestrator.getLastEvent();

        const { response: response2, responseBody: user2 } = await usersRequestBuilder.post({
          username: 'request2',
          email: 'request2@gmail.com',
          password: 'password',
        });

        const { response: response3 } = await usersRequestBuilder.post({
          username: 'request3',
          email: 'request3@gmail.com',
          password: 'password',
        });

        const firewallEvent1 = await orchestrator.getLastEvent();

        await orchestrator.updateEventCreatedAt(createUserEvent1.id, new Date(Date.now() - 1000 * 60 * 30));

        const { response: response4, responseBody: user4 } = await usersRequestBuilder.post({
          username: 'request4',
          email: 'request4@gmail.com',
          password: 'password',
        });

        const { response: response5 } = await usersRequestBuilder.post({
          username: 'request5',
          email: 'request5@gmail.com',
          password: 'password',
        });

        const firewallEvent2 = await orchestrator.getLastEvent();

        expect.soft(response1.status).toBe(201);
        expect.soft(response2.status).toBe(201);
        expect.soft(response3.status).toBe(429);
        expect.soft(response4.status).toBe(201);
        expect.soft(response5.status).toBe(429);

        expect(firewallEvent1.type).toBe('firewall:block_users');
        expect(firewallEvent2.type).toBe('firewall:block_users');

        // Confirm first event
        const reviewFirewallRequestBuilder = new RequestBuilder(`/api/v1/moderations/review_firewall`);
        const firewallUser = await reviewFirewallRequestBuilder.buildUser({
          with: ['read:firewall', 'review:firewall'],
        });

        const { response: responseConfirm, responseBody: responseBodyConfirm } =
          await reviewFirewallRequestBuilder.post(`/${firewallEvent1.id}`, {
            action: 'confirm',
          });

        const expectedAffectedUsers = [
          mapUserData({ ...user1, features: ['nuked'] }),
          mapUserData({ ...user2, features: ['nuked'] }),
          mapUserData({ ...user4, features: ['nuked'] }),
        ];
        const expectedMetadataUsers = [user1.id, user2.id, user4.id];
        const expectedRelatedEvents = [firewallEvent1.id, firewallEvent2.id];
        const expectedEvents = [
          mapFirewallEventData(firewallEvent1),
          mapFirewallEventData(firewallEvent2),
          {
            created_at: responseBodyConfirm.events[2].created_at,
            id: responseBodyConfirm.events[2].id,
            metadata: {
              related_events: expect.arrayContaining(expectedRelatedEvents),
              users: expect.arrayContaining(expectedMetadataUsers),
            },
            originator_user_id: firewallUser.id,
            type: 'moderation:block_users',
          },
        ];

        expect.soft(responseConfirm.status).toBe(200);

        expect.soft(expectedEvents).toStrictEqual(expect.arrayContaining(responseBodyConfirm.events));
        expect.soft(expectedAffectedUsers).toStrictEqual(expect.arrayContaining(responseBodyConfirm.affected.users));
        expect
          .soft(expectedMetadataUsers)
          .toStrictEqual(expect.arrayContaining(responseBodyConfirm.events[2].metadata.users));
        expect
          .soft(expectedRelatedEvents)
          .toStrictEqual(expect.arrayContaining(responseBodyConfirm.events[2].metadata.related_events));
        expect(responseBodyConfirm).toStrictEqual({
          affected: {
            users: expect.arrayContaining(expectedAffectedUsers),
          },
          events: expect.arrayContaining(expectedEvents),
        });

        const createdConfirmationEventResponse = responseBodyConfirm.events[1];
        expect(Date.parse(createdConfirmationEventResponse.created_at)).not.toBeNaN();
        expect(uuidVersion(createdConfirmationEventResponse.id)).toBe(4);

        // Get second event
        const getFirewallEventRequestBuilder = new RequestBuilder('/api/v1/events/firewall');
        await getFirewallEventRequestBuilder.buildUser({ with: ['read:firewall'] });

        const { response: responseFirewall2, responseBody: responseBodyFirewall2 } =
          await getFirewallEventRequestBuilder.get(`/${firewallEvent2.id}`);

        expect.soft(responseFirewall2.status).toBe(200);

        expect(responseBodyFirewall2).toStrictEqual({
          affected: {
            users: expect.arrayContaining(expectedAffectedUsers),
          },
          events: expect.arrayContaining(expectedEvents),
        });
      });

      test('Undo two "firewall:block_contents:text_root" events', async () => {
        const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
        const user1 = await contentsRequestBuilder.buildUser();

        const { response: response1, responseBody: content1 } = await createContentViaApi(contentsRequestBuilder);
        const createContentEvent1 = await orchestrator.getLastEvent();

        const { response: response2, responseBody: content2 } = await createContentViaApi(contentsRequestBuilder);
        await orchestrator.createRate(content2, 10);

        const { response: response3 } = await createContentViaApi(contentsRequestBuilder);

        const firewallEvent1 = await orchestrator.getLastEvent();

        await orchestrator.updateEventCreatedAt(createContentEvent1.id, new Date(Date.now() - 30 * 60 * 1000));

        const { response: response4, responseBody: content4 } = await createContentViaApi(contentsRequestBuilder);
        await orchestrator.createRate(content4, 2);

        const { response: response5 } = await createContentViaApi(contentsRequestBuilder);

        const firewallEvent2 = await orchestrator.getLastEvent();

        expect.soft(response1.status).toBe(201);
        expect.soft(response2.status).toBe(201);
        expect.soft(response3.status).toBe(429);
        expect.soft(response4.status).toBe(201);
        expect.soft(response5.status).toBe(429);

        // Undo second event
        const reviewFirewallRequestBuilder = new RequestBuilder(`/api/v1/moderations/review_firewall`);
        const firewallUser = await reviewFirewallRequestBuilder.buildUser({
          with: ['read:firewall', 'review:firewall'],
        });

        const { response: responseConfirm, responseBody: responseBodyUndo } = await reviewFirewallRequestBuilder.post(
          `/${firewallEvent2.id}`,
          { action: 'undo' },
        );

        const expectedAffectedContents = [
          mapContentData({ ...content1, owner_username: user1.username }),
          mapContentData({ ...content2, tabcoins: 10, tabcoins_credit: 10 }),
          mapContentData({ ...content4, owner_username: user1.username, tabcoins: 2, tabcoins_credit: 2 }),
        ];
        const expectedAffectedUsers = [
          mapUserData({ ...user1, features: expect.arrayContaining(user1.features), tabcoins: 12 }),
        ];
        const expectedMetadataContents = [content1.id, content2.id, content4.id];
        const expectedRelatedEvents = [firewallEvent1.id, firewallEvent2.id];
        const expectedEvents = [
          mapFirewallEventData(firewallEvent1),
          mapFirewallEventData(firewallEvent2),
          {
            created_at: responseBodyUndo.events[2].created_at,
            id: responseBodyUndo.events[2].id,
            metadata: {
              related_events: expect.arrayContaining(expectedRelatedEvents),
              contents: expect.arrayContaining(expectedMetadataContents),
            },
            originator_user_id: firewallUser.id,
            type: 'moderation:unblock_contents:text_root',
          },
        ];

        expect.soft(responseConfirm.status).toBe(200);

        expect.soft(expectedEvents).toStrictEqual(expect.arrayContaining(responseBodyUndo.events));
        expect.soft(expectedAffectedContents).toStrictEqual(expect.arrayContaining(responseBodyUndo.affected.contents));
        expect
          .soft(expectedRelatedEvents)
          .toStrictEqual(expect.arrayContaining(responseBodyUndo.events[2].metadata.related_events));
        expect
          .soft(expectedMetadataContents)
          .toStrictEqual(expect.arrayContaining(responseBodyUndo.events[2].metadata.contents));
        expect(responseBodyUndo).toStrictEqual({
          affected: {
            contents: expect.arrayContaining(expectedAffectedContents),
            users: expectedAffectedUsers,
          },
          events: expect.arrayContaining(expectedEvents),
        });

        const createdUndoEventResponse = responseBodyUndo.events[1];
        expect(Date.parse(createdUndoEventResponse.created_at)).not.toBeNaN();
        expect(uuidVersion(createdUndoEventResponse.id)).toBe(4);

        // Get first event
        const getFirewallEventRequestBuilder = new RequestBuilder('/api/v1/events/firewall');
        await getFirewallEventRequestBuilder.buildUser({ with: ['read:firewall'] });

        const { response: responseFirewall1, responseBody: responseBodyFirewall1 } =
          await getFirewallEventRequestBuilder.get(`/${firewallEvent1.id}`);

        expect.soft(responseFirewall1.status).toBe(200);

        expect(responseBodyFirewall1).toStrictEqual({
          affected: {
            contents: expect.arrayContaining(expectedAffectedContents),
            users: expectedAffectedUsers,
          },
          events: expect.arrayContaining(expectedEvents),
        });
      });
    });
  });
});

function mapContentData(content) {
  return {
    body: content.body,
    children_deep_count: +content.children_deep_count || 0,
    created_at: content.created_at.toISOString?.() ?? content.created_at,
    deleted_at: content.deleted_at?.toISOString?.() ?? content.deleted_at,
    id: content.id,
    owner_id: content.owner_id,
    owner_username: content.owner_username,
    parent_id: content.parent_id,
    published_at: content.published_at.toISOString?.() ?? content.published_at,
    slug: content.slug,
    source_url: content.source_url,
    status: content.status,
    tabcoins: +content.tabcoins,
    tabcoins_credit: +content.tabcoins_credit,
    tabcoins_debit: +content.tabcoins_debit,
    title: content.title,
    type: content.type,
    updated_at: content.updated_at.toISOString?.() ?? content.updated_at,
  };
}

function mapUserData(user) {
  return {
    created_at: user.created_at.toISOString?.() ?? user.created_at,
    description: user.description,
    features: user.features,
    id: user.id,
    tabcash: user.tabcash || 0,
    tabcoins: user.tabcoins || 0,
    updated_at: user.updated_at.toISOString?.() ?? user.updated_at,
    username: user.username,
  };
}

function mapFirewallEventData(firewallEvent) {
  return {
    created_at: firewallEvent.created_at.toISOString(),
    id: firewallEvent.id,
    metadata: firewallEvent.metadata,
    originator_user_id: firewallEvent.originator_user_id,
    type: firewallEvent.type,
  };
}
</file>

<file path="tests/integration/api/v1/recovery/patch.test.js">
import { version as uuidVersion } from 'uuid';

import recovery from 'models/recovery.js';
import user from 'models/user.js';
import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
  await orchestrator.deleteAllEmails();
});

describe('PATCH /api/v1/recovery', () => {
  describe('Anonymous user', () => {
    test('With valid information', async () => {
      const defaultUser = await orchestrator.createUser();
      const recoveryToken = await orchestrator.createRecoveryToken(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: recoveryToken.id,
          password: 'newValidPassword',
        }),
      });

      const responseBody = await response.json();

      const updatedTokenInDatabase = await recovery.findOneTokenById(recoveryToken.id);
      const updatedUserInDatabase = await user.findOneById(defaultUser.id);

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        used: true,
        expires_at: updatedTokenInDatabase.expires_at.toISOString(),
        created_at: updatedTokenInDatabase.created_at.toISOString(),
        updated_at: updatedTokenInDatabase.updated_at.toISOString(),
      });

      expect(Date.parse(responseBody.expires_at)).not.toBeNaN();
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.expires_at > responseBody.created_at).toBe(true);
      expect(responseBody.updated_at > recoveryToken.updated_at.toISOString()).toBe(true);

      expect(defaultUser.password).not.toBe(updatedUserInDatabase.password);
    });

    test('With valid information and multiple active sessions', async () => {
      const defaultUser = await orchestrator.createUser();
      await orchestrator.activateUser(defaultUser);
      const session1Object = await orchestrator.createSession(defaultUser);
      const session2Object = await orchestrator.createSession(defaultUser);

      // First: test if both sessions are working
      const validSession1Response = await fetch(`${orchestrator.webserverUrl}/api/v1/user`, {
        method: 'GET',
        headers: {
          cookie: `session_id=${session1Object.token}`,
        },
      });

      const validSession2Response = await fetch(`${orchestrator.webserverUrl}/api/v1/user`, {
        method: 'GET',
        headers: {
          cookie: `session_id=${session2Object.token}`,
        },
      });

      expect.soft(validSession1Response.status).toBe(200);
      const validSession1ResponseBody = await validSession1Response.json();
      expect(validSession1ResponseBody.id).toBe(defaultUser.id);

      expect.soft(validSession2Response.status).toBe(200);
      const validSession2ResponseBody = await validSession2Response.json();
      expect(validSession2ResponseBody.id).toBe(defaultUser.id);

      // Second: define new password for user using the recovery endpoint
      const recoveryToken = await orchestrator.createRecoveryToken(defaultUser);

      const recoveryResponse = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: recoveryToken.id,
          password: 'newValidPassword',
        }),
      });

      expect.soft(recoveryResponse.status).toBe(200);

      // Third: test if both sessions are invalid
      const invalidSession1Response = await fetch(`${orchestrator.webserverUrl}/api/v1/user`, {
        method: 'GET',
        headers: {
          cookie: `session_id=${session1Object.token}`,
        },
      });

      const invalidSession2Response = await fetch(`${orchestrator.webserverUrl}/api/v1/user`, {
        method: 'GET',
        headers: {
          cookie: `session_id=${session2Object.token}`,
        },
      });

      expect.soft(invalidSession1Response.status).toBe(401);
      expect.soft(invalidSession2Response.status).toBe(401);
    });

    test('With valid information, but used token', async () => {
      const defaultUser = await orchestrator.createUser();
      const recoveryToken = await orchestrator.createRecoveryToken(defaultUser);
      await recovery.update(recoveryToken.id, {
        used: true,
      });

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: recoveryToken.id,
          password: 'newValidPassword',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'O token de recuperação de senha utilizado não foi encontrado no sistema ou expirou.',
        action: 'Solicite uma nova recuperação de senha.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:RECOVERY:FIND_ONE_VALID_TOKEN_BY_ID:NOT_FOUND',
        key: 'token_id',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With valid information, but expired token', async () => {
      const defaultUser = await orchestrator.createUser();
      const recoveryToken = await orchestrator.createRecoveryToken(defaultUser);
      await recovery.update(recoveryToken.id, {
        expires_at: new Date(Date.now() - 1000),
      });

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: recoveryToken.id,
          password: 'newValidPassword',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'O token de recuperação de senha utilizado não foi encontrado no sistema ou expirou.',
        action: 'Solicite uma nova recuperação de senha.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:RECOVERY:FIND_ONE_VALID_TOKEN_BY_ID:NOT_FOUND',
        key: 'token_id',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With valid information, but non-existent token', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: 'b04b9c47-3120-4191-8b1a-000334de95ae',
          password: 'newValidPassword',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'O token de recuperação de senha utilizado não foi encontrado no sistema ou expirou.',
        action: 'Solicite uma nova recuperação de senha.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:RECOVERY:FIND_ONE_VALID_TOKEN_BY_ID:NOT_FOUND',
        key: 'token_id',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With "token_id" missing', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          password: 'newValidPassword',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"token_id" é um campo obrigatório.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'token_id',
        type: 'any.required',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With "token_id" as a Number', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: 123456,
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"token_id" deve ser do tipo String.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'token_id',
        type: 'string.base',
      });
    });

    test('With "token_id" as a String, but not in UUID V4 format', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: 'abcd',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"token_id" deve possuir um token UUID na versão 4.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'token_id',
        type: 'string.guid',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With "password" missing', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          token_id: '6f03567c-dc1b-4e07-9775-8bc71a08c4d6',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"password" é um campo obrigatório.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'password',
        type: 'any.required',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    // -------

    test('With blank Body', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'PATCH',
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"body" enviado deve ser do tipo Object.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'object',
        type: 'object.base',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With blank Object', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({}),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"token_id" é um campo obrigatório.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'token_id',
        type: 'any.required',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });
  });
});
</file>

<file path="tests/integration/api/v1/recovery/post.test.js">
import { version as uuidVersion } from 'uuid';

import recovery from 'models/recovery.js';
import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

beforeEach(async () => {
  await orchestrator.deleteAllEmails();
});

describe('POST /api/v1/recovery', () => {
  describe('Anonymous user', () => {
    test('With "username" valid', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          username: 'userNotFound',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(403);

      expect(responseBody).toStrictEqual({
        name: 'ForbiddenError',
        message: 'Você não possui permissão para criar um token de recuperação com username.',
        action: 'Verifique se este usuário tem a feature "create:recovery_token:username".',
        status_code: 403,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'CONTROLLER:RECOVERY:POST_HANDLER:CAN_NOT_CREATE_RECOVERY_TOKEN_USERNAME',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);

      expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);
    });

    test('With "username" malformatted', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          username: 'valid@email.com',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"username" deve conter apenas caracteres alfanuméricos.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'username',
        type: 'string.alphanum',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With "email" valid and "user" found', async () => {
      const defaultUser = await orchestrator.createUser();

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          email: defaultUser.email,
        }),
      });

      const responseBody = await response.json();

      const tokenInDatabase = await recovery.findOneTokenByUserId(defaultUser.id);

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        used: false,
        expires_at: tokenInDatabase.expires_at.toISOString(),
        created_at: tokenInDatabase.created_at.toISOString(),
        updated_at: tokenInDatabase.updated_at.toISOString(),
      });

      expect(Date.parse(responseBody.expires_at)).not.toBeNaN();
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.expires_at > responseBody.created_at).toBe(true);

      const lastEmail = await orchestrator.waitForFirstEmail();
      expect(lastEmail.recipients[0].includes(defaultUser.email)).toBe(true);
      expect(lastEmail.subject).toBe('Recuperação de Senha');
      expect(lastEmail.text).toContain(defaultUser.username);
      expect(lastEmail.html).toContain(defaultUser.username);
      expect(lastEmail.text).toContain(recovery.getRecoverPageEndpoint(tokenInDatabase.id));
      expect(lastEmail.html).toContain(recovery.getRecoverPageEndpoint(tokenInDatabase.id));
    });

    test('With "email" valid, but user not found', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          email: 'email@notfound.com',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(201);
      expect(responseBody).toStrictEqual({
        used: false,
        expires_at: responseBody.expires_at,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
      });

      expect(Date.parse(responseBody.expires_at)).not.toBeNaN();
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.expires_at > responseBody.created_at).toBe(true);

      expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);
    });

    test('With "nuked" user, should simulate recovery and skip email delivery', async () => {
      const nukedUser = await orchestrator.createUser();
      await orchestrator.addFeaturesToUser(nukedUser, ['nuked']);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          email: nukedUser.email,
        }),
      });
      expect.soft(response.status).toBe(201);

      const responseBody = await response.json();

      expect(responseBody).toStrictEqual({
        used: false,
        expires_at: responseBody.expires_at,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
      });

      expect(Date.parse(responseBody.expires_at)).not.toBeNaN();
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.expires_at > responseBody.created_at).toBe(true);

      expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);
    });

    test('With 2 pre-existing valid tokens, should skip email delivery', async () => {
      const defaultUser = await orchestrator.createUser();
      await orchestrator.createRecoveryToken(defaultUser);
      await orchestrator.createRecoveryToken(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          email: defaultUser.email,
        }),
      });
      expect.soft(response.status).toBe(201);

      const responseBody = await response.json();

      expect(responseBody).toStrictEqual({
        used: false,
        expires_at: responseBody.expires_at,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
      });

      expect(Date.parse(responseBody.expires_at)).not.toBeNaN();
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.expires_at > responseBody.created_at).toBe(true);

      expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);
    });

    test('With expired tokens, should create new token and send email', async () => {
      const defaultUser = await orchestrator.createUser();

      const expiredToken = await orchestrator.createRecoveryToken(defaultUser);
      await recovery.update(expiredToken.id, {
        expires_at: new Date(Date.now() - 1000 * 60 * 3),
      });

      const usedToken = await orchestrator.createRecoveryToken(defaultUser);
      await recovery.update(usedToken.id, {
        used: true,
        expires_at: new Date(Date.now() - 1000 * 60 * 2),
      });

      await orchestrator.createRecoveryToken(defaultUser);
      await recovery.update(usedToken.id, {
        created_at: new Date(Date.now() - 1000 * 60),
      });

      // Now user has only one valid token (previous ones were expired/used),
      // so a new token can be created.

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: defaultUser.email,
        }),
      });
      expect.soft(response.status).toBe(201);

      const tokenInDatabase = await recovery.findOneTokenByUserId(defaultUser.id);
      const responseBody = await response.json();

      expect(responseBody).toStrictEqual({
        used: false,
        expires_at: tokenInDatabase.expires_at.toISOString(),
        created_at: tokenInDatabase.created_at.toISOString(),
        updated_at: tokenInDatabase.updated_at.toISOString(),
      });

      expect(Date.parse(responseBody.expires_at)).not.toBeNaN();
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.expires_at > responseBody.created_at).toBe(true);

      const lastEmail = await orchestrator.waitForFirstEmail();
      expect(lastEmail.recipients[0].includes(defaultUser.email)).toBe(true);
      expect(lastEmail.subject).toBe('Recuperação de Senha');
      expect(lastEmail.text).toContain(defaultUser.username);
      expect(lastEmail.html).toContain(defaultUser.username);
      expect(lastEmail.text).toContain(recovery.getRecoverPageEndpoint(tokenInDatabase.id));
      expect(lastEmail.html).toContain(recovery.getRecoverPageEndpoint(tokenInDatabase.id));
    });

    test('With "email" malformatted', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          email: 'validUsername',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"email" deve conter um email válido.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'email',
        type: 'string.email',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);

      expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);
    });

    test('With key other than "username" or "email"', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          password: 'validpassword',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: 'Objeto enviado deve ter no mínimo uma chave.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'object',
        type: 'object.min',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With blank Body', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'POST',
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"body" enviado deve ser do tipo Object.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'object',
        type: 'object.base',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With blank Object', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({}),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: 'Objeto enviado deve ter no mínimo uma chave.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'object',
        type: 'object.min',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });
  });

  describe('User with "create:recovery_token:username" feature', () => {
    let sessionObject;

    beforeAll(async () => {
      const userWithPermission = await orchestrator.createUser();
      await orchestrator.activateUser(userWithPermission);
      await orchestrator.addFeaturesToUser(userWithPermission, ['create:recovery_token:username']);
      sessionObject = await orchestrator.createSession(userWithPermission);
    });

    test('With "username" valid and "user" found', async () => {
      const defaultUser = await orchestrator.createUser();

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${sessionObject.token}`,
        },

        body: JSON.stringify({
          username: defaultUser.username,
        }),
      });

      const responseBody = await response.json();

      const tokenInDatabase = await recovery.findOneTokenByUserId(defaultUser.id);

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        used: false,
        expires_at: tokenInDatabase.expires_at.toISOString(),
        created_at: tokenInDatabase.created_at.toISOString(),
        updated_at: tokenInDatabase.updated_at.toISOString(),
      });

      expect(Date.parse(responseBody.expires_at)).not.toBeNaN();
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody.expires_at > responseBody.created_at).toBe(true);

      const lastEmail = await orchestrator.waitForFirstEmail();
      expect(lastEmail.recipients[0].includes(defaultUser.email)).toBe(true);
      expect(lastEmail.subject).toBe('Recuperação de Senha');
      expect(lastEmail.text).toContain(defaultUser.username);
      expect(lastEmail.html).toContain(defaultUser.username);
      expect(lastEmail.text).toContain(recovery.getRecoverPageEndpoint(tokenInDatabase.id));
      expect(lastEmail.html).toContain(recovery.getRecoverPageEndpoint(tokenInDatabase.id));
    });

    test('With "username" valid, but user not found', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${sessionObject.token}`,
        },
        body: JSON.stringify({
          username: 'userNotFound',
        }),
      });
      expect.soft(response.status).toBe(404);

      const responseBody = await response.json();

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'O "username" informado não foi encontrado no sistema.',
        action: 'Verifique se o "username" está digitado corretamente.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:USER:FIND_ONE_BY_USERNAME:NOT_FOUND',
        key: 'username',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);

      expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);
    });

    test('With "nuked" user, should respond as if username does not exist', async () => {
      const nukedUser = await orchestrator.createUser();
      await orchestrator.addFeaturesToUser(nukedUser, ['nuked']);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/recovery`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${sessionObject.token}`,
        },

        body: JSON.stringify({
          username: nukedUser.username,
        }),
      });
      expect.soft(response.status).toBe(404);

      const responseBody = await response.json();

      expect(responseBody).toStrictEqual({
        name: 'NotFoundError',
        message: 'O "username" informado não foi encontrado no sistema.',
        action: 'Verifique se o "username" está digitado corretamente.',
        status_code: 404,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:USER:FIND_ONE_BY_USERNAME:NOT_FOUND',
        key: 'username',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);

      expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);
    });
  });
});
</file>

<file path="tests/integration/api/v1/sessions/delete.test.js">
import { version as uuidVersion } from 'uuid';

import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('DELETE /api/v1/sessions', () => {
  describe('Anonymous user', () => {
    test('With no "session_id" cookie', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/sessions`, {
        method: 'DELETE',
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(403);

      expect(responseBody).toStrictEqual({
        name: 'ForbiddenError',
        message: 'Usuário não pode executar esta operação.',
        action: 'Verifique se este usuário possui a feature "read:session".',
        status_code: 403,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With malformatted "session_id" cookie', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/sessions`, {
        method: 'DELETE',
        headers: {
          cookie: `session_id=tooshort`,
        },
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"session_id" deve possuir 96 caracteres.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'session_id',
        type: 'string.length',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });
  });

  describe('Default user', () => {
    test('With valid session and necessary features', async () => {
      const defaultUser = await orchestrator.createUser();
      await orchestrator.activateUser(defaultUser);
      const sessionObject = await orchestrator.createSession(defaultUser);

      // First: test if the session is working
      const validSessionResponse = await fetch(`${orchestrator.webserverUrl}/api/v1/user`, {
        method: 'GET',
        headers: {
          cookie: `session_id=${sessionObject.token}`,
        },
      });

      expect.soft(validSessionResponse.status).toBe(200);
      const validSessionResponseBody = await validSessionResponse.json();
      expect(validSessionResponseBody.id).toBe(defaultUser.id);

      // Second: delete the session
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/sessions`, {
        method: 'DELETE',
        headers: {
          cookie: `session_id=${sessionObject.token}`,
        },
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: sessionObject.id,
        expires_at: responseBody.expires_at,
        created_at: sessionObject.created_at.toISOString(),
        updated_at: responseBody.updated_at,
      });

      expect(responseBody.created_at).toBe(sessionObject.created_at.toISOString());
      expect(responseBody.expires_at < sessionObject.expires_at.toISOString()).toBe(true);
      expect(responseBody.expires_at < sessionObject.created_at.toISOString()).toBe(true);
      expect(responseBody.updated_at > sessionObject.updated_at.toISOString()).toBe(true);

      // Third: test if the session is not working anymore
      const invalidSessionResponse = await fetch(`${orchestrator.webserverUrl}/api/v1/user`, {
        method: 'GET',
        headers: {
          cookie: `session_id=${sessionObject.token}`,
        },
      });

      expect(invalidSessionResponse.status).toBe(401);
    });
  });

  describe('User without "read:session" feature', () => {
    test('With valid session, but without necessary feature', async () => {
      const defaultUser = await orchestrator.createUser();
      await orchestrator.activateUser(defaultUser);
      const sessionObject = await orchestrator.createSession(defaultUser);
      await orchestrator.removeFeaturesFromUser(defaultUser, ['read:session']);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/sessions`, {
        method: 'DELETE',
        headers: {
          cookie: `session_id=${sessionObject.token}`,
        },
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(403);

      expect(responseBody).toStrictEqual({
        name: 'ForbiddenError',
        message: 'Você não possui permissão para executar esta ação.',
        action: 'Verifique se este usuário já ativou a sua conta e recebeu a feature "read:session".',
        status_code: 403,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:AUTHENTICATION:INJECT_AUTHENTICATED_USER:USER_CANT_READ_SESSION',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });
  });
});
</file>

<file path="tests/integration/api/v1/sessions/get.test.js">
import { version as uuidVersion } from 'uuid';

import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
});

describe('GET /api/v1/sessions', () => {
  describe('Anonymous user', () => {
    test('With invalid HTTP `method`', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/sessions`, {
        method: 'GET',
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(405);

      expect(responseBody).toStrictEqual({
        name: 'MethodNotAllowedError',
        message: 'Método "GET" não permitido para "/api/v1/sessions".',
        action: 'Utilize um método HTTP válido para este recurso.',
        status_code: 405,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });
  });
});
</file>

<file path="tests/integration/api/v1/sessions/post.test.js">
import { version as uuidVersion } from 'uuid';

import session from 'models/session';
import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('POST /api/v1/sessions', () => {
  describe('Anonymous User', () => {
    test('Using a valid email and password', async () => {
      const defaultUser = await orchestrator.createUser({
        email: 'emailToBeFoundAndAccepted@gmail.com',
        password: 'ValidPassword',
      });

      await orchestrator.activateUser(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/sessions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: 'emailToBeFoundAndAccepted@gmail.com',
          password: 'ValidPassword',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(201);
      expect(responseBody.token.length).toBe(96);
      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.expires_at)).not.toBeNaN();
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();

      const sessionObjectInDatabase = await session.findOneById(responseBody.id);
      expect(sessionObjectInDatabase.user_id).toBe(defaultUser.id);

      const parsedCookiesFromResponse = orchestrator.parseSetCookies(response);
      expect(parsedCookiesFromResponse.session_id.name).toBe('session_id');
      expect(parsedCookiesFromResponse.session_id.value).toBe(responseBody.token);
      expect(parsedCookiesFromResponse.session_id.maxAge).toBe(60 * 60 * 24 * 30);
      expect(parsedCookiesFromResponse.session_id.path).toBe('/');
      expect(parsedCookiesFromResponse.session_id.httpOnly).toBe(true);
    });

    test('Using a valid email and password, but user lost the feature "create:session"', async () => {
      const defaultUser = await orchestrator.createUser({
        email: 'emailToBeFoundAndLostFeature@gmail.com',
        password: 'ValidPassword',
      });

      await orchestrator.activateUser(defaultUser);
      await orchestrator.removeFeaturesFromUser(defaultUser, ['create:session']);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/sessions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: 'emailToBeFoundAndLostFeature@gmail.com',
          password: 'ValidPassword',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Você não possui permissão para fazer login.');
      expect(responseBody.action).toBe('Verifique se este usuário possui a feature "create:session".');
      expect.soft(responseBody.status_code).toBe(403);
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('CONTROLLER:SESSIONS:POST_HANDLER:CAN_NOT_CREATE_SESSION');
    });

    test('Using a valid email and password, but not activated user', async () => {
      await orchestrator.createUser({
        email: 'emailToBeFoundAndRejected@gmail.com',
        password: 'ValidPassword',
      });

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/sessions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: 'emailToBeFoundAndRejected@gmail.com',
          password: 'ValidPassword',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('O seu usuário ainda não está ativado.');
      expect(responseBody.action).toBe('Verifique seu email, pois acabamos de enviar um novo convite de ativação.');
      expect.soft(responseBody.status_code).toBe(403);
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('CONTROLLER:SESSIONS:POST_HANDLER:USER_NOT_ACTIVATED');
    });

    test('Using a valid email and password, but wrong password', async () => {
      const defaultUser = await orchestrator.createUser({
        email: 'wrongpassword@gmail.com',
        password: 'wrongpassword',
      });

      await orchestrator.activateUser(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/sessions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: 'wrongpassword@gmail.com',
          password: 'IFORGOTMYPASSWORD',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(401);
      expect(responseBody.name).toBe('UnauthorizedError');
      expect(responseBody.message).toBe('Dados não conferem.');
      expect(responseBody.action).toBe('Verifique se os dados enviados estão corretos.');
      expect.soft(responseBody.status_code).toBe(401);
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('CONTROLLER:SESSIONS:POST_HANDLER:DATA_MISMATCH');
    });

    test('Using a valid email and password, but wrong email', async () => {
      const defaultUser = await orchestrator.createUser({
        email: 'wrongemail@gmail.com',
        password: 'wrongemail',
      });

      await orchestrator.activateUser(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/sessions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: 'IFORGOTMYEMAIL@gmail.com',
          password: 'wrongemail',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(401);
      expect(responseBody.name).toBe('UnauthorizedError');
      expect(responseBody.message).toBe('Dados não conferem.');
      expect(responseBody.action).toBe('Verifique se os dados enviados estão corretos.');
      expect.soft(responseBody.status_code).toBe(401);
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('CONTROLLER:SESSIONS:POST_HANDLER:DATA_MISMATCH');
    });

    test('Using a valid password, but without email', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/sessions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          password: 'validPassword',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"email" é um campo obrigatório.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('email');
    });

    test('Using a valid password, but empty email', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/sessions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: '',
          password: 'validPassword',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"email" não pode estar em branco.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('email');
    });

    test('Using a valid password, but email using number type', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/sessions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: 12345,
          password: 'validPassword',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"email" deve ser do tipo String.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('email');
    });

    test('Using a valid password, but invalid email', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/sessions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: 'invalidemail',
          password: 'validPassword',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"email" deve conter um email válido.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('email');
    });

    test('Using a valid email, but without password', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/sessions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: 'ValidEmail@gmail.com',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"password" é um campo obrigatório.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('password');
    });

    test('Using a valid email, but empty password', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/sessions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: 'ValidEmail@gmail.com',
          password: '',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"password" não pode estar em branco.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('password');
    });

    test('Using a valid email, but small password', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/sessions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: 'ValidEmail@gmail.com',
          password: 'small',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"password" deve conter no mínimo 8 caracteres.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('password');
    });

    test('Using a valid email, but too long password', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/sessions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: 'ValidEmail@gmail.com',
          password: '73characterssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"password" deve conter no máximo 72 caracteres.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('password');
    });

    test('Using a valid email, but number type password', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/sessions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: 'ValidEmail@gmail.com',
          password: 12345678,
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"password" deve ser do tipo String.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('password');
    });

    test('Sending a blank body', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/sessions`, {
        method: 'POST',
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"body" enviado deve ser do tipo Object.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('object');
    });
  });
});
</file>

<file path="tests/integration/api/v1/sponsored-beta/get.test.js">
import { defaultTabCashForAdCreation } from 'tests/constants-for-tests';
import orchestrator from 'tests/orchestrator.js';
import RequestBuilder from 'tests/request-builder';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
});

describe('GET /api/v1/sponsored-beta', () => {
  describe('Anonymous user', () => {
    const adsRequestBuilder = new RequestBuilder('/api/v1/sponsored-beta');
    let owner;

    beforeEach(async () => {
      await orchestrator.dropAllTables();
      await orchestrator.runPendingMigrations();
      owner = await orchestrator.createUser();

      await orchestrator.createBalance({
        balanceType: 'user:tabcash',
        recipientId: owner.id,
        amount: 100 * defaultTabCashForAdCreation,
      });
    });

    it('should never get default content', async () => {
      await orchestrator.createContent({
        owner_id: owner.id,
        title: 'Content',
        status: 'published',
        type: 'content',
      });

      const { response, responseBody } = await adsRequestBuilder.get();

      expect.soft(response.status).toBe(200);
      expect(responseBody).toStrictEqual([]);
    });

    it('should never get unpublished ad', async () => {
      await orchestrator.createContent({
        owner_id: owner.id,
        title: 'Draft Ad',
        status: 'draft',
        type: 'ad',
      });

      const deletedAd = await orchestrator.createContent({
        owner_id: owner.id,
        title: 'Deleted Ad',
        status: 'published',
        type: 'ad',
      });

      await orchestrator.updateContent(deletedAd.id, { status: 'deleted' });

      const { response, responseBody } = await adsRequestBuilder.get();

      expect.soft(response.status).toBe(200);
      expect(responseBody).toStrictEqual([]);
    });

    it('should return ads', async () => {
      const createdAds = await createAds(4, owner);

      const { response, responseBody } = await adsRequestBuilder.get();

      expect.soft(response.status).toBe(200);

      expect(createdAds).toContainEqual(responseBody[0]);
      expect(createdAds).toContainEqual(responseBody[1]);
      expect(createdAds).toContainEqual(responseBody[2]);
      expect(createdAds).toContainEqual(responseBody[3]);
    });

    it('should limit the number of ads returned', async () => {
      const createdAds = await createAds(3, owner);

      const { response, responseBody } = await adsRequestBuilder.get('?per_page=2');

      expect.soft(response.status).toBe(200);
      expect.soft(responseBody).toHaveLength(2);

      expect(createdAds).toContainEqual(responseBody[0]);
      expect(createdAds).toContainEqual(responseBody[1]);
    });

    it('should ignore specific ad', async () => {
      const createdAds = await createAds(1, owner);

      const { response, responseBody } = await adsRequestBuilder.get(`?ignore_id=${createdAds[0].id}`);

      expect.soft(response.status).toBe(200);
      expect(responseBody).toStrictEqual([]);
    });

    it('should get from specific owner', async () => {
      const specificOwner = await orchestrator.createUser();

      await orchestrator.createBalance({
        balanceType: 'user:tabcash',
        recipientId: specificOwner.id,
        amount: defaultTabCashForAdCreation,
      });

      await createAds(10, owner);
      const specificAd = await createAds(1, specificOwner);
      await createAds(10, owner, 10);

      const { response, responseBody } = await adsRequestBuilder.get(`?owner_id=${specificOwner.id}`);

      expect.soft(response.status).toBe(200);
      expect(responseBody).toStrictEqual(specificAd);
    });

    it('should try get from another owner', async () => {
      const specificOwner = await orchestrator.createUser();

      const createdAds = await createAds(1, owner);

      const { response, responseBody } = await adsRequestBuilder.get(`?flexible=true&owner_id=${specificOwner.id}`);

      expect.soft(response.status).toBe(200);
      expect(responseBody).toStrictEqual(createdAds);
    });

    it('should try get from another owner and ignore specific ad', async () => {
      const specificOwner = await orchestrator.createUser();

      const createdAds = await createAds(2, owner);

      const { response, responseBody } = await adsRequestBuilder.get(
        `?flexible=true&owner_id=${specificOwner.id}&ignore_id=${createdAds[1].id}`,
      );

      expect.soft(response.status).toBe(200);
      expect(responseBody).toStrictEqual([createdAds[0]]);
    });
  });
});

async function createAds(count, owner, indexOffset = 0) {
  const ads = [];
  for (let i = indexOffset; i < count + indexOffset; i++) {
    const ad = await orchestrator.createContent({
      owner_id: owner.id,
      title: `Ad #${i}`,
      status: 'published',
      type: 'ad',
    });

    ads.push({
      id: ad.id,
      title: ad.title,
      slug: ad.slug,
      owner_username: owner.username,
      source_url: ad.source_url,
      type: 'markdown',
    });
  }

  return ads;
}
</file>

<file path="tests/integration/api/v1/status/votes/get.test.js">
import { randomUUID as uuidV4 } from 'node:crypto';
import { version as uuidVersion } from 'uuid';

import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('GET /api/v1/status/votes', () => {
  describe('Anonymous user', () => {
    test('Should not retrieve voting data', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/status/votes`);

      const responseBody = await response.json();

      expect.soft(response.status).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Usuário não pode executar esta operação.');
      expect(responseBody.action).toBe('Verifique se este usuário possui a feature "read:votes:others".');
      expect.soft(responseBody.status_code).toBe(403);
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND');
    });
  });

  describe('Default user', () => {
    test('Should not retrieve voting data', async () => {
      let defaultUser = await orchestrator.createUser();
      defaultUser = await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/status/votes`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Usuário não pode executar esta operação.');
      expect(responseBody.action).toBe('Verifique se este usuário possui a feature "read:votes:others".');
      expect.soft(responseBody.status_code).toBe(403);
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND');
    });
  });

  describe('User with "read:votes:others" feature', () => {
    let privilegedUser;
    let privilegedUserSession;

    beforeEach(async () => {
      privilegedUser = await orchestrator.createUser();
      privilegedUser = await orchestrator.activateUser(privilegedUser);
      privilegedUser = await orchestrator.addFeaturesToUser(privilegedUser, ['read:votes:others']);
      privilegedUserSession = await orchestrator.createSession(privilegedUser);
    });

    test('Should retrieve empty voting data', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/status/votes`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${privilegedUserSession.token}`,
        },
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);
      expect(responseBody).toStrictEqual({ updated_at: expect.any(String), votesGraph: { edges: [], nodes: [] } });
    });

    test('Should retrieve voting data', async () => {
      await orchestrator.createRate({ owner_id: privilegedUser.id, id: uuidV4() }, 1);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/status/votes`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${privilegedUserSession.token}`,
        },
      });

      const responseBody = await response.json();
      const votesData = responseBody.votesGraph;

      expect.soft(response.status).toBe(200);
      expect(votesData.edges.length).toBe(1);
      expect(votesData.edges[0].type).toBe('credit');
      expect(votesData.edges[0].value).toBe(1);
      expect(votesData.nodes.length).toBe(2);
      expect(votesData.nodes[0].group).toBe('users');
      expect(votesData.nodes[1].group).toBe('users');
      expect(votesData.nodes[0].votes).toBe(1);
      expect(votesData.nodes[1].votes).toBe(1);
      expect(votesData.edges[0].from).toBe(votesData.nodes[0].id);
      expect(votesData.edges[0].to).toBe(votesData.nodes[1].id);
      expect(votesData.edges[0].id).toBe(`credit-${votesData.nodes[0].id}-${votesData.nodes[1].id}`);
    });

    describe('Same user after losing "read:votes:others" feature', () => {
      test('Should not retrieve voting data', async () => {
        await orchestrator.removeFeaturesFromUser(privilegedUser, ['read:votes:others']);

        const responseAfter = await fetch(`${orchestrator.webserverUrl}/api/v1/status/votes`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            cookie: `session_id=${privilegedUserSession.token}`,
          },
        });

        const responseBody = await responseAfter.json();

        expect.soft(responseAfter.status).toBe(403);
        expect(responseBody.name).toBe('ForbiddenError');
        expect(responseBody.message).toBe('Usuário não pode executar esta operação.');
        expect(responseBody.action).toBe('Verifique se este usuário possui a feature "read:votes:others".');
        expect.soft(responseBody.status_code).toBe(403);
        expect(uuidVersion(responseBody.error_id)).toBe(4);
        expect(uuidVersion(responseBody.request_id)).toBe(4);
        expect(responseBody.error_location_code).toBe('MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND');
      });
    });
  });
});
</file>

<file path="tests/integration/api/v1/status/get.test.js">
import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
});

describe('GET /status', () => {
  describe('Anonymous user', () => {
    test('Retrieving current system status', async () => {
      const serverStatusResponse = await fetch(`${orchestrator.webserverUrl}/api/v1/status`);
      const serverStatusBody = await serverStatusResponse.json();

      expect.soft(serverStatusResponse.status).toBe(200);
      expect(serverStatusBody.updated_at).toBeDefined();
      expect(serverStatusBody.dependencies.database.status).toBe('healthy');
      expect(serverStatusBody.dependencies.database.opened_connections).toBeGreaterThan(0);
      expect(serverStatusBody.dependencies.database.latency.first_query).toBeGreaterThan(0);
      expect(serverStatusBody.dependencies.database.latency.second_query).toBeGreaterThan(0);
      expect(serverStatusBody.dependencies.database.latency.third_query).toBeGreaterThan(0);
      expect(typeof serverStatusBody.dependencies.database.version).toBe('string');

      expect(serverStatusBody.dependencies.webserver.status).toBe('healthy');
      expect(serverStatusBody.dependencies.webserver.provider).toBe('local');
      expect(serverStatusBody.dependencies.webserver.environment).toBe('local');
      expect(typeof serverStatusBody.dependencies.webserver.version).toBe('string');
    });
  });
});
</file>

<file path="tests/integration/api/v1/swr/get.test.js">
import orchestrator from 'tests/orchestrator.js';

describe('GET /swr', () => {
  test('Get timestamp from server', async () => {
    const startTime = Date.now();
    const serverTimeResponse = await fetch(`${orchestrator.webserverUrl}/api/v1/swr`);
    const serverTimeBody = await serverTimeResponse.json();
    const serverTime = serverTimeBody.timestamp;

    expect.soft(serverTimeResponse.status).toBe(200);
    expect(serverTime).toBeGreaterThanOrEqual(startTime);
    expect(serverTime).toBeLessThanOrEqual(Date.now());
  });
});
</file>

<file path="tests/integration/api/v1/user/get.test.js">
import { version as uuidVersion } from 'uuid';

import { defaultTabCashForAdCreation, relevantBody } from 'tests/constants-for-tests';
import orchestrator from 'tests/orchestrator.js';
import RequestBuilder from 'tests/request-builder';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('GET /api/v1/user', () => {
  describe('Anonymous user', () => {
    test('Retrieving the endpoint', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/user`);

      const responseBody = await response.json();

      expect.soft(response.status).toBe(403);
      expect.soft(responseBody.status_code).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Usuário não pode executar esta operação.');
      expect(responseBody.action).toBe('Verifique se este usuário possui a feature "read:session".');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND');

      const parsedCookiesFromGet = orchestrator.parseSetCookies(response);
      expect(parsedCookiesFromGet).toStrictEqual({});
    });

    test('Retrieving the endpoint with malformatted "session_id" (too short)', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/user`, {
        method: 'GET',
        headers: {
          cookie: `session_id=tooshort`,
        },
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"session_id" deve possuir 96 caracteres.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('session_id');

      const parsedCookiesFromGet = orchestrator.parseSetCookies(response);
      expect(parsedCookiesFromGet).toStrictEqual({});
    });

    test('Retrieving the endpoint with malformatted "session_id" (too long)', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/user`, {
        method: 'GET',
        headers: {
          cookie: `session_id=97characterslongggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggg`,
        },
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"session_id" deve possuir 96 caracteres.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('session_id');

      const parsedCookiesFromGet = orchestrator.parseSetCookies(response);
      expect(parsedCookiesFromGet).toStrictEqual({});
    });

    test('Retrieving the endpoint with correct length "session_id", but with invalid characters', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/user`, {
        method: 'GET',
        headers: {
          cookie: `session_id=%208427a9as213d2a80da05b25c76b43fa539ec09303fb7ea146ba661208c1a475ed0d91847f16123d257c858994e4aaf8`,
        },
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"session_id" deve conter apenas caracteres alfanuméricos.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('session_id');

      const parsedCookiesFromGet = orchestrator.parseSetCookies(response);
      expect(parsedCookiesFromGet).toStrictEqual({});
    });
  });

  describe('Default user', () => {
    test('With valid session and necessary features', async () => {
      const userRequestBuilder = new RequestBuilder('/api/v1/user');
      const defaultUser = await userRequestBuilder.buildUser();

      const { response, responseBody } = await userRequestBuilder.get();

      expect.soft(response.status).toBe(200);
      expect(responseBody).toStrictEqual({
        id: defaultUser.id,
        username: defaultUser.username,
        description: defaultUser.description,
        email: defaultUser.email,
        notifications: defaultUser.notifications,
        features: defaultUser.features,
        tabcoins: 0,
        tabcash: 0,
        created_at: defaultUser.created_at.toISOString(),
        updated_at: defaultUser.updated_at.toISOString(),
      });

      const parsedCookiesFromGet = orchestrator.parseSetCookies(response);
      expect(parsedCookiesFromGet).toStrictEqual({});

      const sessionObject = await orchestrator.findSessionByToken(userRequestBuilder.sessionObject.token);
      expect(sessionObject).toStrictEqual(userRequestBuilder.sessionObject);
    });

    test('With valid session, but user lost "read:session" feature', async () => {
      const userRequestBuilder = new RequestBuilder('/api/v1/user');
      await userRequestBuilder.buildUser({ without: ['read:session'] });

      const { response, responseBody } = await userRequestBuilder.get();

      expect.soft(response.status).toBe(403);
      expect.soft(responseBody.status_code).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Você não possui permissão para executar esta ação.');
      expect(responseBody.action).toBe(
        'Verifique se este usuário já ativou a sua conta e recebeu a feature "read:session".',
      );
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe(
        'MODEL:AUTHENTICATION:INJECT_AUTHENTICATED_USER:USER_CANT_READ_SESSION',
      );

      const parsedCookiesFromGet = orchestrator.parseSetCookies(response);
      expect(parsedCookiesFromGet).toStrictEqual({});
    });

    test('With expired session', async () => {
      vi.useFakeTimers({
        now: new Date(Date.now() - 1000 - 1000 * 60 * 60 * 24 * 30), // 30 days and 1 second ago
      });

      const userRequestBuilder = new RequestBuilder('/api/v1/user');
      await userRequestBuilder.buildUser();

      vi.useRealTimers();

      const { response, responseBody } = await userRequestBuilder.get();

      expect.soft(response.status).toBe(401);
      expect.soft(responseBody.status_code).toBe(401);
      expect(responseBody.name).toBe('UnauthorizedError');
      expect(responseBody.message).toBe('Usuário não possui sessão ativa.');
      expect(responseBody.action).toBe('Verifique se este usuário está logado.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);

      const parsedCookiesFromGet = orchestrator.parseSetCookies(response);
      expect(parsedCookiesFromGet.session_id.name).toBe('session_id');
      expect(parsedCookiesFromGet.session_id.value).toBe('invalid');
      expect(parsedCookiesFromGet.session_id.maxAge).toBe(-1);
      expect(parsedCookiesFromGet.session_id.path).toBe('/');
      expect(parsedCookiesFromGet.session_id.httpOnly).toBe(true);

      const sessionObject = await orchestrator.findSessionByToken(userRequestBuilder.sessionObject.token);
      expect(sessionObject).toBeUndefined();
    });

    describe('Renew Session', () => {
      test('Should be able to renew with token almost expiring', async () => {
        // 29 days, 23 hours and 59 minutes (1 minute left to expire)
        vi.useFakeTimers({
          now: new Date(Date.now() - 1000 * 60 * 60 * 24 * 30 + 1000 * 60),
        });

        const userRequestBuilder = new RequestBuilder('/api/v1/user');
        const defaultUser = await userRequestBuilder.buildUser();

        vi.useRealTimers();

        const sessionObjectBeforeRenew = await orchestrator.findSessionByToken(userRequestBuilder.sessionObject.token);

        const { response, responseBody } = await userRequestBuilder.get();

        expect.soft(response.status).toBe(200);
        expect(responseBody).toStrictEqual({
          id: defaultUser.id,
          username: defaultUser.username,
          description: defaultUser.description,
          email: defaultUser.email,
          notifications: defaultUser.notifications,
          features: defaultUser.features,
          tabcoins: 0,
          tabcash: 0,
          created_at: defaultUser.created_at.toISOString(),
          updated_at: defaultUser.updated_at.toISOString(),
        });

        const parsedCookiesFromGet = orchestrator.parseSetCookies(response);
        expect(parsedCookiesFromGet.session_id.name).toBe('session_id');
        expect(parsedCookiesFromGet.session_id.value).toBe(sessionObjectBeforeRenew.token);
        expect(parsedCookiesFromGet.session_id.maxAge).toBe(60 * 60 * 24 * 30);
        expect(parsedCookiesFromGet.session_id.path).toBe('/');
        expect(parsedCookiesFromGet.session_id.httpOnly).toBe(true);

        const sessionObjectAfterRenew = await orchestrator.findSessionByToken(userRequestBuilder.sessionObject.token);
        expect(sessionObjectBeforeRenew).toStrictEqual(userRequestBuilder.sessionObject);
        expect(sessionObjectAfterRenew.id).toBe(sessionObjectBeforeRenew.id);
        expect(sessionObjectAfterRenew.created_at).toStrictEqual(sessionObjectBeforeRenew.created_at);
        expect(sessionObjectAfterRenew.expires_at > sessionObjectBeforeRenew.expires_at).toBe(true);
        expect(sessionObjectAfterRenew.updated_at > sessionObjectBeforeRenew.updated_at).toBe(true);
      });

      test('Should be able to renew with 9 day token', async () => {
        vi.useFakeTimers({
          now: new Date(Date.now() - 1000 - 1000 * 60 * 60 * 24 * 9), // 9 days and 1 second ago
        });

        const userRequestBuilder = new RequestBuilder('/api/v1/user');
        const defaultUser = await userRequestBuilder.buildUser();

        vi.useRealTimers();

        const sessionObjectBeforeRenew = await orchestrator.findSessionByToken(userRequestBuilder.sessionObject.token);

        expect(sessionObjectBeforeRenew).toStrictEqual(userRequestBuilder.sessionObject);

        const { response, responseBody } = await userRequestBuilder.get();

        expect.soft(response.status).toBe(200);
        expect(responseBody).toStrictEqual({
          id: defaultUser.id,
          username: defaultUser.username,
          description: defaultUser.description,
          email: defaultUser.email,
          notifications: defaultUser.notifications,
          features: defaultUser.features,
          tabcoins: 0,
          tabcash: 0,
          created_at: defaultUser.created_at.toISOString(),
          updated_at: defaultUser.updated_at.toISOString(),
        });

        const parsedCookiesFromGet = orchestrator.parseSetCookies(response);
        expect(parsedCookiesFromGet.session_id.name).toBe('session_id');
        expect(parsedCookiesFromGet.session_id.value).toBe(sessionObjectBeforeRenew.token);
        expect(parsedCookiesFromGet.session_id.maxAge).toBe(60 * 60 * 24 * 30);
        expect(parsedCookiesFromGet.session_id.path).toBe('/');
        expect(parsedCookiesFromGet.session_id.httpOnly).toBe(true);

        const sessionObjectAfterRenew = await orchestrator.findSessionByToken(userRequestBuilder.sessionObject.token);
        expect(sessionObjectAfterRenew.id).toBe(sessionObjectBeforeRenew.id);
        expect(sessionObjectAfterRenew.created_at).toStrictEqual(sessionObjectBeforeRenew.created_at);
        expect(sessionObjectAfterRenew.expires_at > sessionObjectBeforeRenew.expires_at).toBe(true);
        expect(sessionObjectAfterRenew.updated_at > sessionObjectBeforeRenew.updated_at).toBe(true);
      });

      test('Should not be able to renew with less than 9 days token', async () => {
        vi.useFakeTimers({
          now: new Date(Date.now() - 1000 * 60 * 60 * 24 * 9 + 1000 * 60), // 1 minute left for 9 days
        });

        const userRequestBuilder = new RequestBuilder('/api/v1/user');
        const defaultUser = await userRequestBuilder.buildUser();

        vi.useRealTimers();

        const sessionObjectBeforeRenew = await orchestrator.findSessionByToken(userRequestBuilder.sessionObject.token);

        expect(sessionObjectBeforeRenew).toStrictEqual(userRequestBuilder.sessionObject);

        const { response, responseBody } = await userRequestBuilder.get();

        expect.soft(response.status).toBe(200);
        expect(responseBody).toStrictEqual({
          id: defaultUser.id,
          username: defaultUser.username,
          description: defaultUser.description,
          email: defaultUser.email,
          notifications: defaultUser.notifications,
          features: defaultUser.features,
          tabcoins: 0,
          tabcash: 0,
          created_at: defaultUser.created_at.toISOString(),
          updated_at: defaultUser.updated_at.toISOString(),
        });

        const parsedCookiesFromGet = orchestrator.parseSetCookies(response);
        expect(parsedCookiesFromGet).toStrictEqual({});

        const sessionObjectAfterRenew = await orchestrator.findSessionByToken(userRequestBuilder.sessionObject.token);
        expect(sessionObjectAfterRenew).toStrictEqual(sessionObjectBeforeRenew);
      });
    });

    describe('Reward', () => {
      const defaultTestRewardValue = 2;

      test('Should be able to reward the user once a day', async () => {
        const userRequestBuilder = new RequestBuilder('/api/v1/user');
        const defaultUser = await userRequestBuilder.buildUser();
        await orchestrator.createPrestige(defaultUser.id);

        const { response: preRewardUserResponse, responseBody: preRewardUser } = await userRequestBuilder.get();

        expect.soft(preRewardUserResponse.status).toBe(200);
        expect(preRewardUser.tabcoins).toBe(0);
        expect(preRewardUser.tabcash).toBe(0);
        expect(preRewardUser.updated_at).toBe(defaultUser.updated_at.toISOString());

        await orchestrator.updateRewardedAt(
          defaultUser.id,
          new Date(Date.now() - 1000 - 1000 * 60 * 60 * 24), // 1 day and 1 second ago
        );

        const { response: rewardUserResponse, responseBody: rewardUser } = await userRequestBuilder.get();

        expect.soft(rewardUserResponse.status).toBe(200);
        expect(rewardUser.tabcoins).toBe(defaultTestRewardValue);
        expect(rewardUser.tabcash).toBe(0);
        expect(rewardUser.updated_at).toBe(defaultUser.updated_at.toISOString());

        const { response: postRewardUserResponse, responseBody: postRewardUser } = await userRequestBuilder.get();

        expect.soft(postRewardUserResponse.status).toBe(200);
        expect(postRewardUser.tabcoins).toBe(defaultTestRewardValue);
        expect(postRewardUser.tabcash).toBe(0);
        expect(postRewardUser.updated_at).toBe(defaultUser.updated_at.toISOString());
      });

      test('Should deduplicate simultaneous rewards', async () => {
        const userRequestBuilder = new RequestBuilder('/api/v1/user');
        const defaultUser = await userRequestBuilder.buildUser();
        await orchestrator.createPrestige(defaultUser.id);

        const { response: preRewardUserResponse, responseBody: preRewardUser } = await userRequestBuilder.get();

        expect.soft(preRewardUserResponse.status).toBe(200);
        expect(preRewardUser.tabcoins).toBe(0);
        expect(preRewardUser.tabcash).toBe(0);
        expect(preRewardUser.updated_at).toBe(defaultUser.updated_at.toISOString());

        await orchestrator.updateRewardedAt(
          defaultUser.id,
          new Date(Date.now() - 1000 - 1000 * 60 * 60 * 24), // 1 day and 1 second ago
        );

        const simultaneousResults = await Promise.all([userRequestBuilder.get(), userRequestBuilder.get()]);

        const tabcoins = simultaneousResults.map((result) => {
          expect.soft(result.response.status).toBe(200);
          return result.responseBody.tabcoins;
        });

        expect(tabcoins).toContain(defaultTestRewardValue);

        const { response: postRewardUserResponse, responseBody: postRewardUser } = await userRequestBuilder.get();

        expect.soft(postRewardUserResponse.status).toBe(200);
        expect(postRewardUser.tabcoins).toBe(defaultTestRewardValue);
        expect(postRewardUser.tabcash).toBe(0);
        expect(postRewardUser.updated_at).toBe(defaultUser.updated_at.toISOString());
      });

      test('Should not reward if user has no prestige', async () => {
        const userRequestBuilder = new RequestBuilder('/api/v1/user');
        const defaultUser = await userRequestBuilder.buildUser();

        const { response: preRewardUserResponse, responseBody: preRewardUser } = await userRequestBuilder.get();

        expect.soft(preRewardUserResponse.status).toBe(200);
        expect(preRewardUser.tabcoins).toBe(0);
        expect(preRewardUser.tabcash).toBe(0);
        expect(preRewardUser.updated_at).toBe(defaultUser.updated_at.toISOString());

        await orchestrator.updateRewardedAt(
          defaultUser.id,
          new Date(Date.now() - 1000 * 60 * 60 * 36), // 36 hours ago
        );

        const simultaneousResults = await Promise.all([userRequestBuilder.get(), userRequestBuilder.get()]);

        simultaneousResults.forEach((result) => {
          expect.soft(result.response.status).toBe(200);
          expect(result.responseBody.tabcoins).toBe(0);
        });

        const { response: postRewardUserResponse, responseBody: postRewardUser } = await userRequestBuilder.get();

        expect.soft(postRewardUserResponse.status).toBe(200);
        expect(postRewardUser.tabcoins).toBe(0);
        expect(postRewardUser.tabcash).toBe(0);
        expect(postRewardUser.updated_at).toBe(defaultUser.updated_at.toISOString());
      });

      test('Should not reward if user has negative prestige', async () => {
        const userRequestBuilder = new RequestBuilder('/api/v1/user');
        const defaultUser = await userRequestBuilder.buildUser();
        await orchestrator.createPrestige(defaultUser.id, { rootPrestigeNumerator: -1 });

        const { response: preRewardUserResponse, responseBody: preRewardUser } = await userRequestBuilder.get();

        expect.soft(preRewardUserResponse.status).toBe(200);
        expect(preRewardUser.tabcoins).toBe(0);
        expect(preRewardUser.tabcash).toBe(0);
        expect(preRewardUser.updated_at).toBe(defaultUser.updated_at.toISOString());

        await orchestrator.updateRewardedAt(
          defaultUser.id,
          new Date(Date.now() - 1000 * 60 * 60 * 36), // 36 hours ago
        );

        const simultaneousResults = await Promise.all([userRequestBuilder.get(), userRequestBuilder.get()]);

        simultaneousResults.forEach((result) => {
          expect.soft(result.response.status).toBe(200);
          expect(result.responseBody.tabcoins).toBe(0);
        });

        const { response: postRewardUserResponse, responseBody: postRewardUser } = await userRequestBuilder.get();

        expect.soft(postRewardUserResponse.status).toBe(200);
        expect(postRewardUser.tabcoins).toBe(0);
        expect(postRewardUser.tabcash).toBe(0);
        expect(postRewardUser.updated_at).toBe(defaultUser.updated_at.toISOString());
      });

      test('Should not reward if user has too many tabcoins', async () => {
        const userRequestBuilder = new RequestBuilder('/api/v1/user');
        const defaultUser = await userRequestBuilder.buildUser();
        await orchestrator.createPrestige(defaultUser.id);

        await orchestrator.createBalance({
          balanceType: 'user:tabcoin',
          recipientId: defaultUser.id,
          amount: 1000,
        });

        const { response: preRewardUserResponse, responseBody: preRewardUser } = await userRequestBuilder.get();

        expect.soft(preRewardUserResponse.status).toBe(200);
        expect(preRewardUser.tabcoins).toBe(1000);
        expect(preRewardUser.tabcash).toBe(0);
        expect(preRewardUser.updated_at).toBe(defaultUser.updated_at.toISOString());

        await orchestrator.updateRewardedAt(
          defaultUser.id,
          new Date(Date.now() - 1000 * 60 * 60 * 36), // 36 hours ago
        );

        const simultaneousResults = await Promise.all([userRequestBuilder.get(), userRequestBuilder.get()]);

        simultaneousResults.forEach((result) => {
          expect.soft(result.response.status).toBe(200);
          expect(result.responseBody.tabcoins).toBe(1000);
        });

        const { response: postRewardUserResponse, responseBody: postRewardUser } = await userRequestBuilder.get();

        expect.soft(postRewardUserResponse.status).toBe(200);
        expect(postRewardUser.tabcoins).toBe(1000);
        expect(postRewardUser.tabcash).toBe(0);
        expect(postRewardUser.updated_at).toBe(defaultUser.updated_at.toISOString());
      });

      test('Should be able to reward even with negative ad balance', async () => {
        const userRequestBuilder = new RequestBuilder('/api/v1/user');
        const defaultUser = await userRequestBuilder.buildUser();

        vi.useFakeTimers({
          now: new Date(Date.now() - 1000 * 60 * 60 * 24 * 3), // 3 days ago
        });

        await orchestrator.createBalance({
          balanceType: 'user:tabcash',
          recipientId: defaultUser.id,
          amount: defaultTabCashForAdCreation,
        });

        const adContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: 'Ad Title',
          status: 'published',
          body: relevantBody,
          type: 'ad',
        });

        await orchestrator.createRate(adContent, -999);

        vi.useRealTimers();

        await orchestrator.createPrestige(defaultUser.id);

        const preRewardUser = await userRequestBuilder.get();

        expect.soft(preRewardUser.response.status).toBe(200);
        expect(preRewardUser.responseBody.tabcoins).toBe(-999);
        expect(preRewardUser.responseBody.tabcash).toBe(0);

        await orchestrator.updateRewardedAt(
          defaultUser.id,
          new Date(Date.now() - 1000 - 1000 * 60 * 60 * 24), // 1 day and 1 second ago
        );

        const rewardedUser = await userRequestBuilder.get();

        expect.soft(rewardedUser.response.status).toBe(200);
        expect(rewardedUser.responseBody.tabcoins).toBe(defaultTestRewardValue - 999);
        expect(rewardedUser.responseBody.tabcash).toBe(0);
      });

      test('Should not reward only by ad positive balance', async () => {
        const userRequestBuilder = new RequestBuilder('/api/v1/user');
        const defaultUser = await userRequestBuilder.buildUser();

        vi.useFakeTimers({
          now: new Date(Date.now() - 1000 * 60 * 60 * 24 * 3), // 3 days ago
        });

        await orchestrator.createBalance({
          balanceType: 'user:tabcash',
          recipientId: defaultUser.id,
          amount: defaultTabCashForAdCreation,
        });

        const adContent = await orchestrator.createContent({
          owner_id: defaultUser.id,
          title: 'Ad Title',
          status: 'published',
          body: relevantBody,
          type: 'ad',
        });

        await orchestrator.createRate(adContent, 999);

        vi.useRealTimers();

        await orchestrator.createPrestige(defaultUser.id, { rootPrestigeNumerator: -1 });

        const preRewardUser = await userRequestBuilder.get();

        expect.soft(preRewardUser.response.status).toBe(200);
        expect(preRewardUser.responseBody.tabcoins).toBe(999);
        expect(preRewardUser.responseBody.tabcash).toBe(0);

        await orchestrator.updateRewardedAt(
          defaultUser.id,
          new Date(Date.now() - 1000 * 60 * 60 * 36), // 36 hours ago
        );

        const notRewardedUser = await userRequestBuilder.get();

        expect.soft(notRewardedUser.response.status).toBe(200);
        expect(notRewardedUser.responseBody.tabcoins).toBe(999);
        expect(notRewardedUser.responseBody.tabcash).toBe(0);
      });
    });
  });
});
</file>

<file path="tests/integration/api/v1/user/post.test.js">
import { version as uuidVersion } from 'uuid';

import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('POST /api/v1/user', () => {
  describe('Anonymous user', () => {
    test('With invalid HTTP `method`', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/user`, {
        method: 'POST',
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(405);

      expect(responseBody).toStrictEqual({
        name: 'MethodNotAllowedError',
        message: 'Método "POST" não permitido para "/api/v1/user".',
        action: 'Utilize um método HTTP válido para este recurso.',
        status_code: 405,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });
  });
});
</file>

<file path="tests/integration/api/v1/users/[username]/delete.test.js">
import { version as uuidVersion } from 'uuid';

import { relevantBody } from 'tests/constants-for-tests';
import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('DELETE /api/v1/users/[username]', () => {
  describe('Anonymous user', () => {
    test('Deleting other user', async () => {
      const defaultUser = await orchestrator.createUser();

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          ban_type: 'nuke',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(403);

      expect(responseBody).toStrictEqual({
        name: 'ForbiddenError',
        message: 'Usuário não pode executar esta operação.',
        action: 'Verifique se este usuário possui a feature "ban:user".',
        status_code: 403,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });
  });

  describe('Default user', () => {
    test('Deleting other user', async () => {
      const firstUser = await orchestrator.createUser();
      await orchestrator.activateUser(firstUser);
      const firstUserSession = await orchestrator.createSession(firstUser);

      const secondUser = await orchestrator.createUser();

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${secondUser.username}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${firstUserSession.token}`,
        },

        body: JSON.stringify({
          ban_type: 'nuke',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(403);

      expect(responseBody).toStrictEqual({
        name: 'ForbiddenError',
        message: 'Usuário não pode executar esta operação.',
        action: 'Verifique se este usuário possui a feature "ban:user".',
        status_code: 403,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });
  });

  describe('User with "ban:user" feature', () => {
    test('Without "ban_type" key', async () => {
      const firstUser = await orchestrator.createUser();
      await orchestrator.activateUser(firstUser);
      const firstUserSession = await orchestrator.createSession(firstUser);
      await orchestrator.addFeaturesToUser(firstUser, ['ban:user']);

      const secondUser = await orchestrator.createUser();

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${secondUser.username}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${firstUserSession.token}`,
        },

        body: JSON.stringify({}),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"ban_type" é um campo obrigatório.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'ban_type',
        type: 'any.required',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With "ban_type" with an invalid value', async () => {
      const firstUser = await orchestrator.createUser();
      await orchestrator.activateUser(firstUser);
      const firstUserSession = await orchestrator.createSession(firstUser);
      await orchestrator.addFeaturesToUser(firstUser, ['ban:user']);

      const secondUser = await orchestrator.createUser();

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${secondUser.username}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${firstUserSession.token}`,
        },

        body: JSON.stringify({
          ban_type: 'invalid-value',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"ban_type" deve possuir um dos seguintes valores: "nuke".',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'ban_type',
        type: 'any.only',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With "ban_type" with "nuke" value', async () => {
      // 1) SETUP FIRST AND SECOND USERS
      const firstUser = await orchestrator.createUser();
      await orchestrator.activateUser(firstUser);
      const firstUserSession = await orchestrator.createSession(firstUser);
      await orchestrator.addFeaturesToUser(firstUser, ['ban:user']);
      await orchestrator.createPrestige(firstUser.id);

      const secondUser = await orchestrator.createUser();
      await orchestrator.activateUser(secondUser);
      const secondUserSession = await orchestrator.createSession(secondUser);
      await orchestrator.createPrestige(secondUser.id);

      // 2) CREATE CONTENTS FOR FIRST USER
      const firstUserRootContent = await fetch(`${orchestrator.webserverUrl}/api/v1/contents`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${firstUserSession.token}`,
        },
        body: JSON.stringify({
          title: 'firstUserRootContent',
          body: relevantBody,
          status: 'published',
        }),
      });

      const firstUserRootContentBody = await firstUserRootContent.json();

      const firstUserChildContent = await fetch(`${orchestrator.webserverUrl}/api/v1/contents`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${firstUserSession.token}`,
        },
        body: JSON.stringify({
          parent_id: firstUserRootContentBody.id,
          body: 'firstUserChildContent' + relevantBody,
          status: 'published',
        }),
      });

      const firstUserChildContentBody = await firstUserChildContent.json();

      // 3) CREATE CONTENTS FOR SECOND USER
      const secondUserRootContent = await fetch(`${orchestrator.webserverUrl}/api/v1/contents`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${secondUserSession.token}`,
        },
        body: JSON.stringify({
          title: 'secondUserRootContent',
          body: relevantBody,
          status: 'published',
        }),
      });

      const secondUserRootContentBody = await secondUserRootContent.json();

      const secondUserChildContent1 = await fetch(`${orchestrator.webserverUrl}/api/v1/contents`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${secondUserSession.token}`,
        },
        body: JSON.stringify({
          parent_id: firstUserRootContentBody.id,
          body: 'secondUserChildContent #1' + relevantBody,
          status: 'published',
        }),
      });

      const secondUserChildContent1Body = await secondUserChildContent1.json();

      const secondUserChildContent2 = await fetch(`${orchestrator.webserverUrl}/api/v1/contents`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${secondUserSession.token}`,
        },
        body: JSON.stringify({
          parent_id: firstUserRootContentBody.id,
          body: 'secondUserChildContent #2' + relevantBody,
          status: 'published',
        }),
      });

      const secondUserChildContent2Body = await secondUserChildContent2.json();

      await fetch(`${orchestrator.webserverUrl}/api/v1/contents`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${secondUserSession.token}`,
        },
        body: JSON.stringify({
          title: 'Draft Content',
          body: 'Draft Content' + relevantBody,
          status: 'draft',
        }),
      });

      const secondUserDeletedContentResponse = await fetch(`${orchestrator.webserverUrl}/api/v1/contents`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${secondUserSession.token}`,
        },
        body: JSON.stringify({
          title: 'Deleted Content',
          body: 'Deleted Content' + relevantBody,
          status: 'published',
        }),
      });

      const secondUserDeletedContentResponseBody = await secondUserDeletedContentResponse.json();

      await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${secondUser.username}/${secondUserDeletedContentResponseBody.slug}`,
        {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
            cookie: `session_id=${secondUserSession.token}`,
          },
          body: JSON.stringify({
            status: 'deleted',
          }),
        },
      );

      // 4) MOVE TABCOINS FROM SECOND USER TO THE FIRST USER ROOT CONTENT (credit)
      await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}/${firstUserRootContentBody.slug}/tabcoins`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            cookie: `session_id=${secondUserSession.token}`,
          },
          body: JSON.stringify({
            transaction_type: 'credit',
          }),
        },
      );

      // 5) MOVE TABCOINS FROM SECOND USER TO THE FIRST USER CHILD CONTENT (debit)
      await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}/${firstUserChildContentBody.slug}/tabcoins`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            cookie: `session_id=${secondUserSession.token}`,
          },
          body: JSON.stringify({
            transaction_type: 'debit',
          }),
        },
      );

      // 6) CHECK FIRST USER (PRE-BAN)
      const firstUserCheck1 = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${firstUser.username}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      // Results:
      //  +2 TabCoins from the root content
      //  +0 TabCoins from the child content replying to himself
      //  +1 TabCoin from the credit of the secondUser to the root content.
      //  -1 TabCoin from the debit of the secondUser to the child content.
      const firstUserCheck1Body = await firstUserCheck1.json();
      expect(firstUserCheck1Body.tabcoins).toBe(2);
      expect(firstUserCheck1Body.tabcash).toBe(0);
      expect(firstUserCheck1Body.features).toContain('ban:user');

      // 7) CHECK SECOND USER (PRE-BAN)
      const secondUserCheck1 = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${secondUser.username}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      // Results:
      //  +2 TabCoins from the root content
      //  +2 TabCoins from the child content #1
      //  +2 TabCoins from the child content #2
      //  -2 TabCoins / +1 TabCash from credit to the firstUser root content
      //  -2 TabCoins / +1 TabCash from debit to the firstUser child content
      const secondUserCheck1Body = await secondUserCheck1.json();
      expect(secondUserCheck1Body.tabcoins).toBe(2);
      expect(secondUserCheck1Body.tabcash).toBe(2);

      // 8) CHECK FIRST USER ROOT CONTENT (PRE-BAN)
      const firstUserRootContentCheck1 = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}/${firstUserRootContentBody.slug}`,
      );
      const firstUserRootContentCheck1Body = await firstUserRootContentCheck1.json();

      expect.soft(firstUserRootContentCheck1.status).toBe(200);
      expect(firstUserRootContentCheck1Body.status).toBe('published');
      expect(firstUserRootContentCheck1Body.tabcoins).toBe(2);
      expect(firstUserRootContentCheck1Body.children_deep_count).toBe(3);

      // 9) CHECK FIRST USER CHILD CONTENT (PRE-BAN)
      const firstUserChildCheck1 = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}/${firstUserChildContentBody.slug}`,
      );
      const firstUserChildCheck1Body = await firstUserChildCheck1.json();

      expect.soft(firstUserChildCheck1.status).toBe(200);
      expect(firstUserRootContentCheck1Body.status).toBe('published');
      expect(firstUserChildCheck1Body.tabcoins).toBe(-1);
      expect(firstUserChildCheck1Body.children_deep_count).toBe(0);

      // 10) CHECK SECOND USER CONTENTS (PRE-BAN)
      const secondUserRootContentCheck1 = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${secondUser.username}/${secondUserRootContentBody.slug}`,
      );
      const secondUserChildContent1Check1 = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${secondUser.username}/${secondUserChildContent1Body.slug}`,
      );
      const secondUserChildContent2Check1 = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${secondUser.username}/${secondUserChildContent2Body.slug}`,
      );

      const secondUserRootContentCheck1Body = await secondUserRootContentCheck1.json();
      const secondUserChildContent1Check1Body = await secondUserChildContent1Check1.json();
      const secondUserChildContent2Check1Body = await secondUserChildContent2Check1.json();

      expect.soft(secondUserRootContentCheck1.status).toBe(200);
      expect(secondUserRootContentCheck1Body.status).toBe('published');
      expect.soft(secondUserChildContent1Check1.status).toBe(200);
      expect(secondUserChildContent1Check1Body.status).toBe('published');
      expect.soft(secondUserChildContent2Check1.status).toBe(200);
      expect(secondUserChildContent2Check1Body.status).toBe('published');

      // 11) NUKE THE SECOND USER
      const nukeResponse = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${secondUser.username}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${firstUserSession.token}`,
        },

        body: JSON.stringify({
          ban_type: 'nuke',
        }),
      });

      const nukeResponseBody = await nukeResponse.json();

      expect.soft(nukeResponse.status).toBe(200);

      expect(nukeResponseBody).toStrictEqual({
        id: secondUser.id,
        username: secondUser.username,
        description: secondUser.description,
        features: ['nuked'],
        created_at: secondUser.created_at.toISOString(),
        updated_at: nukeResponseBody.updated_at,
      });

      // 12) CHECK FIRST USER (POST-BAN)
      const firstUserCheck2 = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${firstUser.username}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      const firstUserCheck2Body = await firstUserCheck2.json();
      expect(firstUserCheck2Body.tabcoins).toBe(2);
      expect(firstUserCheck2Body.tabcash).toBe(0);

      // 13) CHECK SECOND USER (POST-BAN)
      const secondUserCheck2 = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${secondUser.username}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      const secondUserCheck2Body = await secondUserCheck2.json();

      expect.soft(secondUserCheck2.status).toBe(404);
      expect(secondUserCheck2Body.name).toBe('NotFoundError');
      expect(secondUserCheck2Body.message).toBe('O "username" informado não foi encontrado no sistema.');
      expect(secondUserCheck2Body.action).toBe('Verifique se o "username" está digitado corretamente.');
      expect.soft(secondUserCheck2Body.status_code).toBe(404);
      expect(secondUserCheck2Body.error_location_code).toBe('MODEL:USER:FIND_ONE_BY_USERNAME:NOT_FOUND');
      expect(uuidVersion(secondUserCheck2Body.error_id)).toBe(4);
      expect(uuidVersion(secondUserCheck2Body.request_id)).toBe(4);
      expect(secondUserCheck2Body.key).toBe('username');

      // 14) CHECK FIRST USER ROOT CONTENT (POST-BAN)
      const firstUserRootContentCheck2 = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}/${firstUserRootContentBody.slug}`,
      );
      const firstUserRootContentCheck2Body = await firstUserRootContentCheck2.json();

      expect(firstUserRootContentCheck2.status).toBe(200);
      expect(firstUserRootContentCheck2Body.status).toBe('published');
      expect(firstUserRootContentCheck2Body.tabcoins).toBe(1);
      expect(firstUserRootContentCheck2Body.children_deep_count).toBe(1);

      // 15) CHECK FIRST USER CHILD CONTENT (POST-BAN)
      const firstUserChildCheck2 = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${firstUser.username}/${firstUserChildContentBody.slug}`,
      );
      const firstUserChildCheck2Body = await firstUserChildCheck2.json();

      expect.soft(firstUserChildCheck2.status).toBe(200);
      expect(firstUserRootContentCheck2Body.status).toBe('published');
      expect(firstUserChildCheck2Body.tabcoins).toBe(0);
      expect(firstUserChildCheck2Body.children_deep_count).toBe(0);

      // 16) CHECK SECOND USER CONTENTS (POST-BAN)
      const secondUserRootContentCheck2 = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${secondUser.username}/${secondUserRootContentBody.slug}`,
      );
      const secondUserChildContent1Check2 = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${secondUser.username}/${secondUserChildContent1Body.slug}`,
      );
      const secondUserChildContent2Check2 = await fetch(
        `${orchestrator.webserverUrl}/api/v1/contents/${secondUser.username}/${secondUserChildContent2Body.slug}`,
      );

      expect.soft(secondUserRootContentCheck2.status).toBe(404);
      expect.soft(secondUserChildContent1Check2.status).toBe(404);
      expect.soft(secondUserChildContent2Check2.status).toBe(404);

      // 17) TRY TO CREATE NEW CONTENT AS THE SECOND USER
      const secondUserRootContent2 = await fetch(`${orchestrator.webserverUrl}/api/v1/contents`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${secondUserSession.token}`,
        },
        body: JSON.stringify({
          title: 'secondUserRootContent #2',
          body: 'Body',
          status: 'published',
        }),
      });

      const secondUserRootContent2Body = await secondUserRootContent2.json();

      expect.soft(secondUserRootContent2.status).toBe(401);

      expect(secondUserRootContent2Body).toStrictEqual({
        name: 'UnauthorizedError',
        message: 'Usuário não possui sessão ativa.',
        action: 'Verifique se este usuário está logado.',
        status_code: 401,
        error_id: secondUserRootContent2Body.error_id,
        request_id: secondUserRootContent2Body.request_id,
      });
    });

    test('With "ban_type" on a non-existing user', async () => {
      const firstUser = await orchestrator.createUser();
      await orchestrator.activateUser(firstUser);
      const firstUserSession = await orchestrator.createSession(firstUser);
      await orchestrator.addFeaturesToUser(firstUser, ['ban:user']);

      const nukeResponse = await fetch(`${orchestrator.webserverUrl}/api/v1/users/donotexist`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${firstUserSession.token}`,
        },

        body: JSON.stringify({
          ban_type: 'nuke',
        }),
      });

      const nukeResponseBody = await nukeResponse.json();

      expect.soft(nukeResponse.status).toBe(404);
      expect(nukeResponseBody.name).toBe('NotFoundError');
      expect(nukeResponseBody.message).toBe('O "username" informado não foi encontrado no sistema.');
      expect(nukeResponseBody.action).toBe('Verifique se o "username" está digitado corretamente.');
      expect.soft(nukeResponseBody.status_code).toBe(404);
      expect(nukeResponseBody.error_location_code).toBe('MODEL:USER:FIND_ONE_BY_USERNAME:NOT_FOUND');
      expect(uuidVersion(nukeResponseBody.error_id)).toBe(4);
      expect(uuidVersion(nukeResponseBody.request_id)).toBe(4);
      expect(nukeResponseBody.key).toBe('username');
    });

    test('With "ban_type" on an user with "nuked" feature', async () => {
      const firstUser = await orchestrator.createUser();
      await orchestrator.activateUser(firstUser);
      const firstUserSession = await orchestrator.createSession(firstUser);
      await orchestrator.addFeaturesToUser(firstUser, ['ban:user']);

      const secondUser = await orchestrator.createUser();
      await orchestrator.activateUser(secondUser);
      await orchestrator.createSession(secondUser);

      const nuke1Response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${secondUser.username}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${firstUserSession.token}`,
        },

        body: JSON.stringify({
          ban_type: 'nuke',
        }),
      });

      const nuke1ResponseBody = await nuke1Response.json();

      expect.soft(nuke1Response.status).toBe(200);

      expect(nuke1ResponseBody).toStrictEqual({
        id: secondUser.id,
        username: secondUser.username,
        description: secondUser.description,
        features: ['nuked'],
        created_at: secondUser.created_at.toISOString(),
        updated_at: nuke1ResponseBody.updated_at,
      });

      const nuke2Response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${secondUser.username}`, {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${firstUserSession.token}`,
        },

        body: JSON.stringify({
          ban_type: 'nuke',
        }),
      });

      const nuke2ResponseBody = await nuke2Response.json();

      expect.soft(nuke2Response.status).toBe(404);
      expect(nuke2ResponseBody.name).toBe('NotFoundError');
      expect(nuke2ResponseBody.message).toBe('O "username" informado não foi encontrado no sistema.');
      expect(nuke2ResponseBody.action).toBe('Verifique se o "username" está digitado corretamente.');
      expect.soft(nuke2ResponseBody.status_code).toBe(404);
      expect(nuke2ResponseBody.error_location_code).toBe('MODEL:USER:FIND_ONE_BY_USERNAME:NOT_FOUND');
      expect(uuidVersion(nuke2ResponseBody.error_id)).toBe(4);
      expect(uuidVersion(nuke2ResponseBody.request_id)).toBe(4);
      expect(nuke2ResponseBody.key).toBe('username');
    });
  });
});
</file>

<file path="tests/integration/api/v1/users/[username]/get.test.js">
import { version as uuidVersion } from 'uuid';

import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('GET /api/v1/users/[username]', () => {
  describe('Anonymous user', () => {
    test('Retrieving non-existing user', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/donotexist`);

      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);
      expect(responseBody.name).toBe('NotFoundError');
      expect(responseBody.message).toBe('O "username" informado não foi encontrado no sistema.');
      expect(responseBody.action).toBe('Verifique se o "username" está digitado corretamente.');
      expect.soft(responseBody.status_code).toBe(404);
      expect(responseBody.error_location_code).toBe('MODEL:USER:FIND_ONE_BY_USERNAME:NOT_FOUND');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.key).toBe('username');
    });

    test('Retrieving too short user', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/ab`);

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"username" deve conter no mínimo 3 caracteres.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.key).toBe('username');
    });

    test('Retrieving too long user', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/userWith31Characterssssssssssss`);

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"username" deve conter no máximo 30 caracteres.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.key).toBe('username');
    });

    test('Retrieving user with invalid characters', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/<script>alert("xss")`);

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"username" deve conter apenas caracteres alfanuméricos.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.key).toBe('username');
    });

    test('Retrieving existing user using same capital letters', async () => {
      const userCreated = await orchestrator.createUser({
        username: 'userNameToBeFound',
      });

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/userNameToBeFound`);

      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: userCreated.id,
        username: 'userNameToBeFound',
        description: userCreated.description,
        features: userCreated.features,
        tabcoins: userCreated.tabcoins,
        tabcash: userCreated.tabcash,
        created_at: userCreated.created_at.toISOString(),
        updated_at: userCreated.updated_at.toISOString(),
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(responseBody).not.toHaveProperty('password');
      expect(responseBody).not.toHaveProperty('email');
    });

    test('Retrieving existing user using different capital letters', async () => {
      const userCreated = await orchestrator.createUser({
        username: 'userNameToBeFoundCAPS',
      });

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/usernametobefoundcaps`);

      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: userCreated.id,
        username: 'userNameToBeFoundCAPS',
        description: userCreated.description,
        features: userCreated.features,
        tabcoins: userCreated.tabcoins,
        tabcash: userCreated.tabcash,
        created_at: userCreated.created_at.toISOString(),
        updated_at: userCreated.updated_at.toISOString(),
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();
      expect(responseBody).not.toHaveProperty('password');
      expect(responseBody).not.toHaveProperty('email');
    });

    test('Retrieving nuked user', async () => {
      const userCreated = await orchestrator.createUser({ username: 'nukedUser' });

      await orchestrator.addFeaturesToUser(userCreated, ['nuked']);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/nukedUser`);

      const responseBody = await response.json();

      expect.soft(response.status).toBe(404);
      expect(responseBody.name).toBe('NotFoundError');
      expect(responseBody.message).toBe('O "username" informado não foi encontrado no sistema.');
      expect(responseBody.action).toBe('Verifique se o "username" está digitado corretamente.');
      expect.soft(responseBody.status_code).toBe(404);
      expect(responseBody.error_location_code).toBe('MODEL:USER:FIND_ONE_BY_USERNAME:NOT_FOUND');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.key).toBe('username');
    });
  });
});
</file>

<file path="tests/integration/api/v1/users/[username]/patch.test.js">
import { version as uuidVersion } from 'uuid';

import emailConfirmation from 'models/email-confirmation.js';
import password from 'models/password.js';
import user from 'models/user.js';
import orchestrator from 'tests/orchestrator.js';
import RequestBuilder from 'tests/request-builder';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('PATCH /api/v1/users/[username]', () => {
  describe('Anonymous user', () => {
    test('Patching other user', async () => {
      const defaultUser = await orchestrator.createUser();

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },

        body: JSON.stringify({
          username: 'anonymousUserPatchingOtherUser',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Usuário não pode executar esta operação.');
      expect(responseBody.action).toBe('Verifique se este usuário possui a feature "update:user".');
      expect.soft(responseBody.status_code).toBe(403);
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND');
    });
  });

  describe('Default user', () => {
    test('Patching other user', async () => {
      let defaultUser = await orchestrator.createUser();
      defaultUser = await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);
      const secondUser = await orchestrator.createUser();

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${secondUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },

        body: JSON.stringify({
          username: 'regularUserPatchingOtherUser',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(403);
      expect(responseBody.name).toBe('ForbiddenError');
      expect(responseBody.message).toBe('Você não possui permissão para atualizar outro usuário.');
      expect(responseBody.action).toBe('Verifique se você possui a feature "update:user:others".');
      expect.soft(responseBody.status_code).toBe(403);
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('CONTROLLER:USERS:USERNAME:PATCH:USER_CANT_UPDATE_OTHER_USER');
    });

    test('With expired session', async () => {
      vi.useFakeTimers({
        now: new Date(Date.now() - 1000 - 1000 * 60 * 60 * 24 * 30), // 30 days and 1 second ago
      });

      let defaultUser = await orchestrator.createUser();
      defaultUser = await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      vi.useRealTimers();

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },

        body: JSON.stringify({
          description: 'A new description',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(401);
      expect.soft(responseBody.status_code).toBe(401);
      expect(responseBody.name).toBe('UnauthorizedError');
      expect(responseBody.message).toBe('Usuário não possui sessão ativa.');
      expect(responseBody.action).toBe('Verifique se este usuário está logado.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);

      const parsedCookiesFromGet = orchestrator.parseSetCookies(response);
      expect(parsedCookiesFromGet.session_id.name).toBe('session_id');
      expect(parsedCookiesFromGet.session_id.value).toBe('invalid');
      expect(parsedCookiesFromGet.session_id.maxAge).toBe(-1);
      expect(parsedCookiesFromGet.session_id.path).toBe('/');
      expect(parsedCookiesFromGet.session_id.httpOnly).toBe(true);

      const sessionObject = await orchestrator.findSessionByToken(defaultUserSession.token);
      expect(sessionObject).toBeUndefined();
    });

    test('Patching itself with a valid and unique username', async () => {
      let defaultUser = await orchestrator.createUser();
      defaultUser = await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },

        body: JSON.stringify({
          username: 'regularUserPatchingHisUsername',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: defaultUser.id,
        username: 'regularUserPatchingHisUsername',
        description: defaultUser.description,
        email: defaultUser.email,
        features: defaultUser.features,
        notifications: defaultUser.notifications,
        tabcoins: 0,
        tabcash: 0,
        created_at: defaultUser.created_at.toISOString(),
        updated_at: responseBody.updated_at,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(responseBody.updated_at > defaultUser.created_at.toISOString()).toBe(true);

      const defaultUserInDatabase = await user.findOneById(responseBody.id);
      const passwordsMatch = await password.compare('password', defaultUserInDatabase.password);
      expect(passwordsMatch).toBe(true);
      expect(defaultUserInDatabase.email).toBe(defaultUser.email);
    });

    test('Patching itself with a valid and same username but with different case letters', async () => {
      let defaultUser = await orchestrator.createUser({
        username: 'regularUser',
      });
      defaultUser = await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },

        body: JSON.stringify({
          username: 'REGULARUser',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: defaultUser.id,
        username: 'REGULARUser',
        email: defaultUser.email,
        description: defaultUser.description,
        features: defaultUser.features,
        notifications: defaultUser.notifications,
        tabcoins: 0,
        tabcash: 0,
        created_at: defaultUser.created_at.toISOString(),
        updated_at: responseBody.updated_at,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(responseBody.updated_at > defaultUser.created_at.toISOString()).toBe(true);

      const defaultUserInDatabase = await user.findOneById(responseBody.id);
      const passwordsMatch = await password.compare('password', defaultUserInDatabase.password);
      expect(passwordsMatch).toBe(true);
      expect(defaultUserInDatabase.email).toBe(defaultUser.email);
    });

    test('Patching itself with a valid, unique but "untrimmed" username', async () => {
      let defaultUser = await orchestrator.createUser();
      defaultUser = await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },

        body: JSON.stringify({
          username: ' untrimmedUsername ',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual({
        id: defaultUser.id,
        username: 'untrimmedUsername',
        description: defaultUser.description,
        email: defaultUser.email,
        features: defaultUser.features,
        notifications: defaultUser.notifications,
        tabcoins: 0,
        tabcash: 0,
        created_at: defaultUser.created_at.toISOString(),
        updated_at: responseBody.updated_at,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(responseBody.updated_at > defaultUser.created_at.toISOString()).toBe(true);
    });

    test('Patching itself with "username" set to a null value', async () => {
      let defaultUser = await orchestrator.createUser();
      defaultUser = await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },

        body: JSON.stringify({
          username: null,
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"username" deve ser do tipo String.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.key).toBe('username');
    });

    test('Patching itself with "username" with an empty string', async () => {
      let defaultUser = await orchestrator.createUser();
      defaultUser = await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },

        body: JSON.stringify({
          username: '',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"username" não pode estar em branco.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.key).toBe('username');
    });

    test('Patching itself with "username" that\'s not a String', async () => {
      let defaultUser = await orchestrator.createUser();
      defaultUser = await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },

        body: JSON.stringify({
          username: 12345678,
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"username" deve ser do tipo String.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.key).toBe('username');
    });

    test('Patching itself with "username" containing non alphanumeric characters', async () => {
      let defaultUser = await orchestrator.createUser();
      defaultUser = await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },

        body: JSON.stringify({
          username: "<script>alert('XSS')</script>",
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"username" deve conter apenas caracteres alfanuméricos.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.key).toBe('username');
    });

    test('Patching itself with "username" too short', async () => {
      let defaultUser = await orchestrator.createUser();
      defaultUser = await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },

        body: JSON.stringify({
          username: 'ab',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"username" deve conter no mínimo 3 caracteres.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.key).toBe('username');
    });

    test('Patching itself with "username" too long', async () => {
      let defaultUser = await orchestrator.createUser();
      defaultUser = await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },

        body: JSON.stringify({
          username: 'userWith31Characterssssssssssss',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"username" deve conter no máximo 30 caracteres.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.key).toBe('username');
    });

    test('Patching itself with "username" in blocked list', async () => {
      let defaultUser = await orchestrator.createUser();
      defaultUser = await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },

        body: JSON.stringify({
          username: 'account',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('Este nome de usuário não está disponível para uso.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('username');
    });

    test('Patching itself with "body" totally blank', async () => {
      let defaultUser = await orchestrator.createUser();
      defaultUser = await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          cookie: `session_id=${defaultUserSession.token}`,
        },
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"body" enviado deve ser do tipo Object.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.key).toBe('object');
    });

    test('Patching itself with "body" containing a String', async () => {
      let defaultUser = await orchestrator.createUser();
      defaultUser = await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          cookie: `session_id=${defaultUserSession.token}`,
        },
        body: "Please don't hack us, we are the good guys!",
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"body" enviado deve ser do tipo Object.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.key).toBe('object');
    });

    test('Patching itself with "body" containing a blank Object', async () => {
      let defaultUser = await orchestrator.createUser();
      defaultUser = await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },

        body: JSON.stringify({}),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('Objeto enviado deve ter no mínimo uma chave.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.key).toBe('object');
    });

    test('Patching itself with another "email"', async () => {
      await orchestrator.deleteAllEmails();
      let defaultUser = await orchestrator.createUser({
        email: 'original@email.com',
      });
      defaultUser = await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },

        body: JSON.stringify({
          email: 'different@email.com',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);
      expect(responseBody).toStrictEqual({
        id: defaultUser.id,
        username: defaultUser.username,
        description: defaultUser.description,
        email: defaultUser.email,
        features: defaultUser.features,
        notifications: defaultUser.notifications,
        created_at: defaultUser.created_at.toISOString(),
        updated_at: defaultUser.updated_at.toISOString(),
      });

      // Attention: it should not update the email in the database
      // before the user clicks on the confirmation link sent to the new email.
      // See `/tests/integration/email-confirmation` for more details.
      const userInDatabase = await user.findOneById(defaultUser.id);
      expect(userInDatabase.email).toBe('original@email.com');

      // RECEIVING CONFIRMATION EMAIL
      const confirmationEmail = await orchestrator.waitForFirstEmail();

      const tokenObjectInDatabase = await emailConfirmation.findOneTokenByUserId(defaultUser.id);
      const emailConfirmationPageEndpoint = emailConfirmation.getEmailConfirmationPageEndpoint(
        tokenObjectInDatabase.id,
      );

      expect(confirmationEmail.sender).toBe('<contato@tabnews.com.br>');
      expect(confirmationEmail.recipients).toStrictEqual(['<different@email.com>']);
      expect(confirmationEmail.subject).toBe('Confirme seu novo email');
      expect(confirmationEmail.text).toContain(defaultUser.username);
      expect(confirmationEmail.html).toContain(defaultUser.username);
      expect(confirmationEmail.text).toContain('Uma alteração de email foi solicitada.');
      expect(confirmationEmail.html).toContain('Uma alteração de email foi solicitada.');
      expect(confirmationEmail.text).toContain(emailConfirmationPageEndpoint);
      expect(confirmationEmail.html).toContain(emailConfirmationPageEndpoint);
    });

    test('Patching itself with the same "email"', async () => {
      await orchestrator.deleteAllEmails();
      const usersRequestBuilder = new RequestBuilder('/api/v1/users');
      const defaultUser = await usersRequestBuilder.buildUser();

      const { response, responseBody } = await usersRequestBuilder.patch(`/${defaultUser.username}`, {
        email: defaultUser.email,
      });

      expect.soft(response.status).toBe(200);
      expect(responseBody).toStrictEqual({
        id: defaultUser.id,
        username: defaultUser.username,
        description: defaultUser.description,
        email: defaultUser.email,
        features: defaultUser.features,
        notifications: defaultUser.notifications,
        tabcoins: 0,
        tabcash: 0,
        created_at: defaultUser.created_at.toISOString(),
        updated_at: responseBody.updated_at,
      });

      expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);
    });

    test('Patching itself with "notifications"', async () => {
      const defaultUser = await orchestrator.createUser({
        notifications: true,
      });
      await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },

        body: JSON.stringify({
          notifications: false,
        }),
      });

      expect.soft(response.status).toBe(200);

      const userInDatabase = await user.findOneById(defaultUser.id);
      expect(userInDatabase.notifications).toBe(false);
    });

    test('Patching itself with a "description" containing a valid value', async () => {
      const defaultUser = await orchestrator.createUser();
      await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },

        body: JSON.stringify({
          description: 'my description',
        }),
      });

      const responseBody = await response.json();
      expect.soft(response.status).toBe(200);
      expect(responseBody).toStrictEqual({
        id: defaultUser.id,
        username: defaultUser.username,
        description: 'my description',
        email: defaultUser.email,
        features: [
          'create:session',
          'read:session',
          'create:content',
          'create:content:text_root',
          'create:content:text_child',
          'update:content',
          'update:user',
        ],
        notifications: defaultUser.notifications,
        tabcoins: 0,
        tabcash: 0,
        created_at: defaultUser.created_at.toISOString(),
        updated_at: responseBody.updated_at,
      });
    });

    test('Patching itself with a "description" containing more than 5.000 characters', async () => {
      const defaultUser = await orchestrator.createUser();
      await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },

        body: JSON.stringify({
          description: 'a'.repeat(5001),
        }),
      });

      const responseBody = await response.json();
      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"description" deve conter no máximo 5000 caracteres.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(responseBody.type).toBe('string.max');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Patching itself with a "description" containing 100.000 invalid characters', async () => {
      const defaultUser = await orchestrator.createUser();
      await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },

        body: JSON.stringify({
          description: '!' + '\u17b4'.repeat(100_000) + '\u17b4!',
        }),
      });

      const responseBody = await response.json();
      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"description" deve conter no máximo 5000 caracteres.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(responseBody.type).toBe('string.max');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Patching itself with a "description" containing value null', async () => {
      const defaultUser = await orchestrator.createUser();
      await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },

        body: JSON.stringify({
          description: null,
        }),
      });

      const responseBody = await response.json();
      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"description" deve ser do tipo String.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(responseBody.type).toBe('string.base');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
    });

    test('Patching itself with the user having TabCoins and TabCash', async () => {
      const usersRequestBuilder = new RequestBuilder('/api/v1/users');
      const defaultUser = await usersRequestBuilder.buildUser();

      await orchestrator.createBalance({
        balanceType: 'user:tabcoin',
        recipientId: defaultUser.id,
        amount: 200,
      });
      await orchestrator.createBalance({
        balanceType: 'user:tabcash',
        recipientId: defaultUser.id,
        amount: 55,
      });

      const { response, responseBody } = await usersRequestBuilder.patch(`/${defaultUser.username}`, {
        description: 'new description',
      });

      expect.soft(response.status).toBe(200);
      expect(responseBody).toStrictEqual({
        id: defaultUser.id,
        username: defaultUser.username,
        description: 'new description',
        email: defaultUser.email,
        features: defaultUser.features,
        notifications: defaultUser.notifications,
        tabcoins: 200,
        tabcash: 55,
        created_at: defaultUser.created_at.toISOString(),
        updated_at: responseBody.updated_at,
      });
    });

    test('Patching itself with "email", "username", "description" and "notifications"', async () => {
      await orchestrator.deleteAllEmails();

      const usersRequestBuilder = new RequestBuilder('/api/v1/users');
      const defaultUser = await usersRequestBuilder.buildUser();

      const { response, responseBody } = await usersRequestBuilder.patch(`/${defaultUser.username}`, {
        description: 'Updating all possible fields.',
        email: 'random_new_email@example.com',
        username: 'UpdatedUsername',
        notifications: false,
      });

      expect.soft(response.status).toBe(200);
      expect(responseBody).toStrictEqual({
        id: defaultUser.id,
        username: 'UpdatedUsername',
        email: defaultUser.email,
        description: 'Updating all possible fields.',
        features: defaultUser.features,
        notifications: false,
        tabcoins: 0,
        tabcash: 0,
        created_at: defaultUser.created_at.toISOString(),
        updated_at: responseBody.updated_at,
      });

      expect(responseBody.updated_at).not.toBe(defaultUser.updated_at.toISOString());
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();

      const foundUser = await user.findOneById(defaultUser.id);
      expect(foundUser.email).toBe(defaultUser.email);
      expect(foundUser.description).toBe('Updating all possible fields.');
      expect(foundUser.notifications).toBe(false);
      expect(foundUser.username).toBe('UpdatedUsername');
      expect(foundUser.updated_at.toISOString()).toBe(responseBody.updated_at);

      const confirmationEmail = await orchestrator.waitForFirstEmail();
      expect(confirmationEmail.recipients).toStrictEqual(['<random_new_email@example.com>']);
      expect(confirmationEmail.subject).toBe('Confirme seu novo email');
    });

    describe('With duplicated username and/or email', () => {
      test('Patching itself with "username" duplicated exactly (same uppercase letters)', async () => {
        await orchestrator.createUser({
          username: 'SameUPPERCASE',
        });
        let defaultUser = await orchestrator.createUser();
        defaultUser = await orchestrator.activateUser(defaultUser);
        const defaultUserSession = await orchestrator.createSession(defaultUser);

        const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
            cookie: `session_id=${defaultUserSession.token}`,
          },

          body: JSON.stringify({
            username: 'SameUPPERCASE',
          }),
        });

        const responseBody = await response.json();

        expect.soft(response.status).toBe(400);
        expect.soft(responseBody.status_code).toBe(400);
        expect(responseBody.name).toBe('ValidationError');
        expect(responseBody.message).toBe('O "username" informado já está sendo usado.');
        expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
        expect(responseBody.error_location_code).toBe('MODEL:USER:VALIDATE_UNIQUE_USERNAME:ALREADY_EXISTS');
        expect(uuidVersion(responseBody.error_id)).toBe(4);
        expect(uuidVersion(responseBody.request_id)).toBe(4);
        expect(responseBody.key).toBe('username');
      });

      test('Patching itself with "username" duplicated (different uppercase letters)', async () => {
        await orchestrator.createUser({
          username: 'DIFFERENTuppercase',
        });
        let defaultUser = await orchestrator.createUser();
        defaultUser = await orchestrator.activateUser(defaultUser);
        const defaultUserSession = await orchestrator.createSession(defaultUser);

        const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
            cookie: `session_id=${defaultUserSession.token}`,
          },

          body: JSON.stringify({
            username: 'differentUPPERCASE',
          }),
        });

        const responseBody = await response.json();

        expect.soft(response.status).toBe(400);
        expect.soft(responseBody.status_code).toBe(400);
        expect(responseBody.name).toBe('ValidationError');
        expect(responseBody.message).toBe('O "username" informado já está sendo usado.');
        expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
        expect(responseBody.error_location_code).toBe('MODEL:USER:VALIDATE_UNIQUE_USERNAME:ALREADY_EXISTS');
        expect(uuidVersion(responseBody.error_id)).toBe(4);
        expect(uuidVersion(responseBody.request_id)).toBe(4);
        expect(responseBody.key).toBe('username');
      });

      test('Patching itself with "email" duplicated exactly', async () => {
        await orchestrator.deleteAllEmails();
        await orchestrator.createUser({
          email: 'someone@example.com',
        });

        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await usersRequestBuilder.buildUser();

        const { response, responseBody } = await usersRequestBuilder.patch(`/${defaultUser.username}`, {
          email: 'someone@example.com',
        });

        expect.soft(response.status).toBe(200);
        expect(responseBody).toStrictEqual({
          id: defaultUser.id,
          username: defaultUser.username,
          email: defaultUser.email,
          description: defaultUser.description,
          features: defaultUser.features,
          notifications: defaultUser.notifications,
          created_at: defaultUser.created_at.toISOString(),
          updated_at: defaultUser.updated_at.toISOString(),
        });

        const foundUser = await user.findOneById(defaultUser.id);
        expect(foundUser.email).toBe(defaultUser.email);
        expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);
      });

      test('Patching itself with "email" duplicated exactly and other fields', async () => {
        await orchestrator.deleteAllEmails();
        await orchestrator.createUser({
          email: 'this_user_already_exists@example.com',
        });

        const usersRequestBuilder = new RequestBuilder('/api/v1/users');
        const defaultUser = await usersRequestBuilder.buildUser();

        const { response, responseBody } = await usersRequestBuilder.patch(`/${defaultUser.username}`, {
          description: 'New description',
          email: 'this_user_already_exists@example.com',
          notifications: false,
        });

        expect.soft(response.status).toBe(200);
        expect(responseBody).toStrictEqual({
          id: defaultUser.id,
          username: defaultUser.username,
          email: defaultUser.email,
          description: 'New description',
          features: defaultUser.features,
          notifications: false,
          tabcoins: 0,
          tabcash: 0,
          created_at: defaultUser.created_at.toISOString(),
          updated_at: responseBody.updated_at,
        });

        expect(responseBody.updated_at).not.toBe(defaultUser.updated_at.toISOString());
        expect(Date.parse(responseBody.updated_at)).not.toBeNaN();

        const foundUser = await user.findOneById(defaultUser.id);
        expect(foundUser.email).toBe(defaultUser.email);
        expect(foundUser.description).toBe('New description');
        expect(foundUser.notifications).toBe(false);
        expect(foundUser.updated_at.toISOString()).toBe(responseBody.updated_at);
        expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);
      });

      test('Patching itself with duplicate "email" and "username" should only return "username" error', async () => {
        await orchestrator.createUser({ username: 'usernameStoredPreviously' });
        await orchestrator.createUser({ email: 'this_email_already_exists@example.com' });
        await orchestrator.createUser({ username: 'usernameStoredLater' });

        const usersRequestBuilder = new RequestBuilder('/api/v1/users/');
        const defaultUser = await usersRequestBuilder.buildUser();
        await orchestrator.deleteAllEmails();

        const { response, responseBody } = await usersRequestBuilder.patch(defaultUser.username, {
          email: 'this_email_already_exists@example.com',
          username: 'usernameStoredPreviously',
        });
        expect.soft(response.status).toBe(400);

        expect(responseBody).toStrictEqual({
          status_code: 400,
          name: 'ValidationError',
          message: 'O "username" informado já está sendo usado.',
          action: 'Ajuste os dados enviados e tente novamente.',
          error_location_code: 'MODEL:USER:VALIDATE_UNIQUE_USERNAME:ALREADY_EXISTS',
          error_id: responseBody.error_id,
          request_id: responseBody.request_id,
          key: 'username',
        });
        expect(uuidVersion(responseBody.error_id)).toBe(4);
        expect(uuidVersion(responseBody.request_id)).toBe(4);

        const { response: response2, responseBody: responseBody2 } = await usersRequestBuilder.patch(
          defaultUser.username,
          {
            email: 'this_email_already_exists@example.com',
            username: 'usernameStoredLater',
          },
        );
        expect.soft(response2.status).toBe(400);

        expect(responseBody2).toStrictEqual({
          status_code: 400,
          name: 'ValidationError',
          message: 'O "username" informado já está sendo usado.',
          action: 'Ajuste os dados enviados e tente novamente.',
          error_location_code: 'MODEL:USER:VALIDATE_UNIQUE_USERNAME:ALREADY_EXISTS',
          error_id: responseBody2.error_id,
          request_id: responseBody2.request_id,
          key: 'username',
        });
        expect(uuidVersion(responseBody2.error_id)).toBe(4);
        expect(uuidVersion(responseBody2.request_id)).toBe(4);

        const foundUser = await user.findOneById(defaultUser.id);
        expect(foundUser.email).toBe(defaultUser.email);
        expect(foundUser.updated_at).toStrictEqual(defaultUser.updated_at);
        expect(await orchestrator.hasEmailsAfterDelay()).toBe(false);
      });

      test('Patching itself with a duplicate "username" for an inactive user with expired activation token', async () => {
        const inactiveUser = await orchestrator.createUser({ username: 'existentInactiveUser' });
        await orchestrator.updateActivateAccountTokenByUserId(inactiveUser.id, {
          expires_at: new Date(Date.now() - 1000),
        });

        const usersRequestBuilder = new RequestBuilder('/api/v1/users/');
        const defaultUser = await usersRequestBuilder.buildUser();

        const { response, responseBody } = await usersRequestBuilder.patch(defaultUser.username, {
          username: 'existentInactiveUser',
        });
        expect.soft(response.status).toBe(200);

        expect(responseBody).toStrictEqual({
          id: defaultUser.id,
          username: 'existentInactiveUser',
          email: defaultUser.email,
          description: defaultUser.description,
          features: defaultUser.features,
          notifications: true,
          tabcoins: 0,
          tabcash: 0,
          created_at: defaultUser.created_at.toISOString(),
          updated_at: responseBody.updated_at,
        });

        expect(responseBody.updated_at).not.toBe(defaultUser.updated_at.toISOString());
        expect(Date.parse(responseBody.updated_at)).not.toBeNaN();

        await expect(user.findOneById(inactiveUser.id)).rejects.toThrow(
          `O id "${inactiveUser.id}" não foi encontrado no sistema.`,
        );
      });

      test('Patching itself with a duplicate "email" for an inactive user with expired activation token', async () => {
        await orchestrator.deleteAllEmails();
        const inactiveUser = await orchestrator.createUser({ email: 'existent.inactive.user@example.com' });
        await orchestrator.updateActivateAccountTokenByUserId(inactiveUser.id, {
          expires_at: new Date(Date.now() - 1000),
        });

        const usersRequestBuilder = new RequestBuilder('/api/v1/users/');
        const defaultUser = await usersRequestBuilder.buildUser();

        const { response, responseBody } = await usersRequestBuilder.patch(defaultUser.username, {
          email: 'existent.inactive.user@example.com',
        });
        expect.soft(response.status).toBe(200);

        expect(responseBody).toStrictEqual({
          id: defaultUser.id,
          username: defaultUser.username,
          email: defaultUser.email,
          description: defaultUser.description,
          features: defaultUser.features,
          notifications: true,
          created_at: defaultUser.created_at.toISOString(),
          updated_at: responseBody.updated_at,
        });
        expect(Date.parse(responseBody.updated_at)).not.toBeNaN();

        await expect(user.findOneById(inactiveUser.id)).rejects.toThrow(
          `O id "${inactiveUser.id}" não foi encontrado no sistema.`,
        );

        const confirmationEmail = await orchestrator.waitForFirstEmail();

        expect(confirmationEmail.recipients).toStrictEqual(['<existent.inactive.user@example.com>']);
        expect(confirmationEmail.subject).toBe('Confirme seu novo email');
      });

      test('Patching itself with "username" and "email" duplicated from different users, both inactive with expired tokens', async () => {
        await orchestrator.deleteAllEmails();
        const firstInactiveUser = await orchestrator.createUser({ username: 'firstInactiveUser' });
        const secondInactiveUser = await orchestrator.createUser({ email: 'second.inactive.user@example.com' });
        await orchestrator.updateActivateAccountTokenByUserId(firstInactiveUser.id, {
          expires_at: new Date(Date.now() - 1000),
        });
        await orchestrator.updateActivateAccountTokenByUserId(secondInactiveUser.id, {
          expires_at: new Date(Date.now() - 1000),
        });

        const usersRequestBuilder = new RequestBuilder('/api/v1/users/');
        const defaultUser = await usersRequestBuilder.buildUser();

        const { response, responseBody } = await usersRequestBuilder.patch(defaultUser.username, {
          username: 'firstInactiveUser',
          email: 'second.inactive.user@example.com',
        });
        expect.soft(response.status).toBe(200);

        expect(responseBody).toStrictEqual({
          id: defaultUser.id,
          username: 'firstInactiveUser',
          email: defaultUser.email,
          description: defaultUser.description,
          features: defaultUser.features,
          notifications: true,
          tabcoins: 0,
          tabcash: 0,
          created_at: defaultUser.created_at.toISOString(),
          updated_at: responseBody.updated_at,
        });

        expect(responseBody.updated_at).not.toBe(defaultUser.updated_at.toISOString());
        expect(Date.parse(responseBody.updated_at)).not.toBeNaN();

        const confirmationEmail = await orchestrator.waitForFirstEmail();

        expect(confirmationEmail.recipients).toStrictEqual(['<second.inactive.user@example.com>']);
        expect(confirmationEmail.subject).toBe('Confirme seu novo email');

        await expect(user.findOneById(firstInactiveUser.id)).rejects.toThrow(
          `O id "${firstInactiveUser.id}" não foi encontrado no sistema.`,
        );
        await expect(user.findOneById(secondInactiveUser.id)).rejects.toThrow(
          `O id "${secondInactiveUser.id}" não foi encontrado no sistema.`,
        );
      });
    });

    describe('TEMPORARY BEHAVIOR', () => {
      test('Patching itself with another "password"', async () => {
        let defaultUser = await orchestrator.createUser({
          password: 'thisPasswordWillNotChange',
        });
        defaultUser = await orchestrator.activateUser(defaultUser);
        const defaultUserSession = await orchestrator.createSession(defaultUser);

        const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${defaultUser.username}`, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
            cookie: `session_id=${defaultUserSession.token}`,
          },

          body: JSON.stringify({
            password: 'CHANGE.MY.PASSWORD',
          }),
        });

        expect.soft(response.status).toBe(400);

        const defaultUserInDatabase = await user.findOneById(defaultUser.id);
        const passwordsMatch = await password.compare('thisPasswordWillNotChange', defaultUserInDatabase.password);
        const wrongPasswordMatch = await password.compare('CHANGE.MY.PASSWORD', defaultUserInDatabase.password);
        expect(passwordsMatch).toBe(true);
        expect(wrongPasswordMatch).toBe(false);
      });
    });
  });

  describe('User with "update:user:others" feature', () => {
    test('Patching other user only with fields that cannot be updated', async () => {
      let privilegedUser = await orchestrator.createUser();
      await orchestrator.addFeaturesToUser(privilegedUser, ['update:user:others']);
      privilegedUser = await orchestrator.activateUser(privilegedUser);
      const privilegedUserSession = await orchestrator.createSession(privilegedUser);

      let secondUser = await orchestrator.createUser();
      secondUser = await orchestrator.activateUser(secondUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${secondUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${privilegedUserSession.token}`,
        },

        body: JSON.stringify({
          username: 'newUsername',
          email: 'new-email@example.com',
          notifications: false,
          password: 'new_password',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('Objeto enviado deve ter no mínimo uma chave.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.key).toBe('object');
    });

    test('Patching other user with all fields', async () => {
      let privilegedUser = await orchestrator.createUser();
      await orchestrator.addFeaturesToUser(privilegedUser, ['update:user:others']);
      privilegedUser = await orchestrator.activateUser(privilegedUser);
      const privilegedUserSession = await orchestrator.createSession(privilegedUser);

      let secondUser = await orchestrator.createUser({
        password: 'initialPassword',
      });
      secondUser = await orchestrator.activateUser(secondUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users/${secondUser.username}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${privilegedUserSession.token}`,
        },

        body: JSON.stringify({
          description: 'New description.',
          username: 'newUsername',
          email: 'new-email@example.com',
          notifications: false,
          password: 'new_password',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);
      expect(responseBody).toStrictEqual({
        id: secondUser.id,
        username: secondUser.username,
        description: 'New description.',
        features: secondUser.features,
        tabcoins: 0,
        tabcash: 0,
        created_at: secondUser.created_at.toISOString(),
        updated_at: responseBody.updated_at,
      });

      const secondUserInDatabase = await user.findOneById(secondUser.id);
      expect(secondUserInDatabase.notifications).toBe(true);
      expect(secondUserInDatabase.email).toBe(secondUser.email);

      const passwordsMatch = await password.compare('initialPassword', secondUserInDatabase.password);
      const wrongPasswordMatch = await password.compare('new_password', secondUserInDatabase.password);
      expect(passwordsMatch).toBe(true);
      expect(wrongPasswordMatch).toBe(false);
    });
  });
});
</file>

<file path="tests/integration/api/v1/users/firewall.post.test.js">
import { version as uuidVersion } from 'uuid';

import user from 'models/user.js';
import orchestrator from 'tests/orchestrator.js';
import RequestBuilder from 'tests/request-builder';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
  await orchestrator.createFirewallTestFunctions();
  await orchestrator.deleteAllEmails();
});

describe('POST /api/v1/users [FIREWALL]', () => {
  describe('Anonymous user', () => {
    test('Spamming valid users', async () => {
      const usersRequestBuilder = new RequestBuilder('/api/v1/users');
      const { response: response1, responseBody: response1Body } = await usersRequestBuilder.post({
        username: 'request1',
        email: 'request1@gmail.com',
        password: 'validpassword',
      });

      const activatedUser1 = await orchestrator.activateUser(response1Body);

      const { response: response2, responseBody: response2Body } = await usersRequestBuilder.post({
        username: 'request2',
        email: 'request2@gmail.com',
        password: 'validpassword',
      });

      await orchestrator.waitForNthEmail(2);
      await orchestrator.deleteAllEmails();

      const { response: response3, responseBody: response3Body } = await usersRequestBuilder.post({
        username: 'request3',
        email: 'request3@gmail.com',
        password: 'validpassword',
      });

      expect.soft(response1.status).toBe(201);
      expect.soft(response2.status).toBe(201);
      expect.soft(response3.status).toBe(429);

      expect(response3Body).toStrictEqual({
        name: 'TooManyRequestsError',
        message:
          'Identificamos a criação de muitos usuários em um curto período, então usuários criados recentemente podem ter sido desativados.',
        action: 'Tente novamente mais tarde ou contate o suporte caso acredite que isso seja um erro.',
        status_code: 429,
        error_id: response3Body.error_id,
        request_id: response3Body.request_id,
      });

      const user1 = await user.findOneById(response1Body.id);
      const user2 = await user.findOneById(response2Body.id);
      await expect(user.findOneByUsername('request3')).rejects.toThrow(
        'O "username" informado não foi encontrado no sistema.',
      );

      expect(user1.features).toStrictEqual([
        'create:content',
        'create:content:text_root',
        'create:content:text_child',
        'update:content',
        'update:user',
      ]);
      expect(user1.updated_at.toISOString()).toBe(activatedUser1.updated_at.toISOString());
      expect(Date.parse(user1.updated_at)).not.toBeNaN();

      expect(user2.features).toStrictEqual([]);
      expect(user2.updated_at.toISOString()).toBe(response2Body.updated_at);
      expect(Date.parse(user2.updated_at)).not.toBeNaN();

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'firewall:block_users',
        originator_user_id: null,
        originator_ip: '127.0.0.1',
        metadata: {
          from_rule: 'create:user',
          users: [user1.id, user2.id],
        },
        created_at: lastEvent.created_at,
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();

      const allEmails = await orchestrator.getEmails(2);
      expect(allEmails).toHaveLength(2);

      const user1Email = allEmails.find((email) => email.recipients.includes(`<${user1.email}>`));
      const user2Email = allEmails.find((email) => email.recipients.includes(`<${user2.email}>`));

      expect(user1Email.recipients).toStrictEqual([`<${user1.email}>`]);
      expect(user2Email.recipients).toStrictEqual([`<${user2.email}>`]);

      expect(user1Email.subject).toBe('Sua conta foi desativada');
      expect(user2Email.subject).toBe('Sua conta foi desativada');

      expect(user1Email.text).toContain(user1.username);
      expect(user1Email.html).toContain(user1.username);
      expect(user2Email.text).toContain(user2.username);
      expect(user2Email.html).toContain(user2.username);

      const userDeletedContentText = `Identificamos a criação de muitos usuários em um curto período, então a sua conta foi desativada.`;
      expect(user1Email.text).toContain(userDeletedContentText);
      expect(user1Email.html).toContain(userDeletedContentText);
      expect(user2Email.text).toContain(userDeletedContentText);
      expect(user2Email.html).toContain(userDeletedContentText);

      expect(user1Email.text).toContain(`Identificador do evento: ${lastEvent.id}`);
      expect(user1Email.html).toContain('Identificador do evento');
      expect(user1Email.html).toContain(lastEvent.id);
      expect(user2Email.text).toContain(`Identificador do evento: ${lastEvent.id}`);
      expect(user2Email.html).toContain('Identificador do evento');
      expect(user2Email.html).toContain(lastEvent.id);
    });
  });
});
</file>

<file path="tests/integration/api/v1/users/get.test.js">
import parseLinkHeader from 'parse-link-header';
import { version as uuidVersion } from 'uuid';

import user from 'models/user';
import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('GET /api/v1/users', () => {
  describe('Anonymous user', () => {
    test('Anonymous user trying to retrieve user list', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`);
      const responseBody = await response.json();

      expect.soft(response.status).toBe(403);

      expect(responseBody).toStrictEqual({
        name: 'ForbiddenError',
        message: 'Usuário não pode executar esta operação.',
        action: 'Verifique se este usuário possui a feature "read:user:list".',
        status_code: 403,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND',
      });
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });
  });

  describe('Default user', () => {
    test('User without "read:user:list" feature', async () => {
      const defaultUser = await orchestrator.createUser();
      await orchestrator.activateUser(defaultUser);
      const defaultUserSession = await orchestrator.createSession(defaultUser);

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${defaultUserSession.token}`,
        },
      });
      const responseBody = await response.json();

      expect.soft(response.status).toBe(403);

      expect(responseBody).toStrictEqual({
        name: 'ForbiddenError',
        message: 'Usuário não pode executar esta operação.',
        action: 'Verifique se este usuário possui a feature "read:user:list".',
        status_code: 403,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:AUTHORIZATION:CAN_REQUEST:FEATURE_NOT_FOUND',
      });
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });
  });

  describe('User with "read:user:list" feature', () => {
    let firstUser;
    let secondUser;
    let privilegedUser;
    let privilegedUserSession;

    beforeEach(async () => {
      await orchestrator.dropAllTables();
      await orchestrator.runPendingMigrations();

      firstUser = await orchestrator.createUser();
      firstUser = await orchestrator.activateUser(firstUser);

      secondUser = await orchestrator.createUser();
      await orchestrator.activateUser(secondUser);
      secondUser = await orchestrator.addFeaturesToUser(secondUser, ['read:user:list']);
      privilegedUser = secondUser;
      privilegedUserSession = await orchestrator.createSession(privilegedUser);
    });

    test('With a large value for "per_page"', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users?per_page=150`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${privilegedUserSession.token}`,
        },
      });
      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"per_page" deve possuir um valor máximo de 100.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'per_page',
        type: 'number.max',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('With an invalid value for "page"', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/contents?page=first`);
      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);

      expect(responseBody).toStrictEqual({
        name: 'ValidationError',
        message: '"page" deve ser do tipo Number.',
        action: 'Ajuste os dados enviados e tente novamente.',
        status_code: 400,
        error_id: responseBody.error_id,
        request_id: responseBody.request_id,
        error_location_code: 'MODEL:VALIDATOR:FINAL_SCHEMA',
        key: 'page',
        type: 'number.base',
      });

      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
    });

    test('Retrieving user list with 2 users', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${privilegedUserSession.token}`,
        },
      });
      const responseBody = await response.json();

      const responseLinkHeader = parseLinkHeader(response.headers.get('Link'));
      const responseTotalRowsHeader = response.headers.get('X-Pagination-Total-Rows');

      expect.soft(response.status).toBe(200);
      expect(responseTotalRowsHeader).toBe('2');
      expect(responseLinkHeader).toStrictEqual({
        first: {
          page: '1',
          per_page: '30',
          rel: 'first',
          url: `${orchestrator.webserverUrl}/api/v1/users?page=1&per_page=30`,
        },
        last: {
          page: '1',
          per_page: '30',
          rel: 'last',
          url: `${orchestrator.webserverUrl}/api/v1/users?page=1&per_page=30`,
        },
      });

      expect(responseBody).toStrictEqual([
        {
          id: secondUser.id,
          username: secondUser.username,
          description: secondUser.description,
          features: secondUser.features,
          tabcoins: 0,
          tabcash: 0,
          created_at: secondUser.created_at.toISOString(),
          updated_at: secondUser.updated_at.toISOString(),
        },
        {
          id: firstUser.id,
          username: firstUser.username,
          description: firstUser.description,
          features: firstUser.features,
          tabcoins: 0,
          tabcash: 0,
          created_at: firstUser.created_at.toISOString(),
          updated_at: firstUser.updated_at.toISOString(),
        },
      ]);

      expect(uuidVersion(responseBody[0].id)).toBe(4);
      expect(Date.parse(responseBody[0].created_at)).not.toBeNaN();
      expect(Date.parse(responseBody[0].updated_at)).not.toBeNaN();

      expect(uuidVersion(responseBody[1].id)).toBe(4);
      expect(Date.parse(responseBody[1].created_at)).not.toBeNaN();
      expect(Date.parse(responseBody[1].updated_at)).not.toBeNaN();
    });

    test('Retrieving user list removing markdown from description and limiting it to 255 characters', async () => {
      const description = `# This description will contain some **markdown** to test if the _API_ is returning only the content, without markdown.
      
      [www.google.com](https://www.google.com), ![example image](http://example.com/example.jpg)

      We will also need to fill it with a lot of characters to make sure the API won't return more than 255 characters. The end.`;

      const cleanDescription =
        (
          'This description will contain some markdown to test if the API is returning only the content, without markdown.' +
          ' www.google.com, example image' +
          " We will also need to fill it with a lot of characters to make sure the API won't return more than 255 characters. The end."
        ).substring(0, 252) + '...';

      firstUser = await user.update(firstUser, { description });

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${privilegedUserSession.token}`,
        },
      });
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);
      expect(responseBody).toStrictEqual([
        {
          id: firstUser.id,
          username: firstUser.username,
          description: cleanDescription,
          features: firstUser.features,
          tabcoins: 0,
          tabcash: 0,
          created_at: firstUser.created_at.toISOString(),
          updated_at: firstUser.updated_at.toISOString(),
        },
        {
          id: secondUser.id,
          username: secondUser.username,
          description: secondUser.description,
          features: secondUser.features,
          tabcoins: 0,
          tabcash: 0,
          created_at: secondUser.created_at.toISOString(),
          updated_at: secondUser.updated_at.toISOString(),
        },
      ]);

      expect(uuidVersion(responseBody[0].id)).toBe(4);
      expect(Date.parse(responseBody[0].created_at)).not.toBeNaN();
      expect(Date.parse(responseBody[0].updated_at)).not.toBeNaN();

      expect(uuidVersion(responseBody[1].id)).toBe(4);
      expect(Date.parse(responseBody[1].created_at)).not.toBeNaN();
      expect(Date.parse(responseBody[1].updated_at)).not.toBeNaN();
    });

    test('Retrieving user list with TabCoins and TabCash', async () => {
      await orchestrator.createBalance({
        balanceType: 'user:tabcoin',
        recipientId: firstUser.id,
        amount: 8,
      });
      await orchestrator.createBalance({
        balanceType: 'user:tabcash',
        recipientId: firstUser.id,
        amount: 3,
      });

      await orchestrator.createBalance({
        balanceType: 'user:tabcoin',
        recipientId: secondUser.id,
        amount: -2,
      });
      await orchestrator.createBalance({
        balanceType: 'user:tabcash',
        recipientId: secondUser.id,
        amount: 200,
      });

      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${privilegedUserSession.token}`,
        },
      });
      const responseBody = await response.json();

      expect.soft(response.status).toBe(200);

      expect(responseBody).toStrictEqual([
        {
          id: secondUser.id,
          username: secondUser.username,
          description: secondUser.description,
          features: secondUser.features,
          tabcoins: -2,
          tabcash: 200,
          created_at: secondUser.created_at.toISOString(),
          updated_at: secondUser.updated_at.toISOString(),
        },
        {
          id: firstUser.id,
          username: firstUser.username,
          description: firstUser.description,
          features: firstUser.features,
          tabcoins: 8,
          tabcash: 3,
          created_at: firstUser.created_at.toISOString(),
          updated_at: firstUser.updated_at.toISOString(),
        },
      ]);

      expect(uuidVersion(responseBody[0].id)).toBe(4);
      expect(Date.parse(responseBody[0].created_at)).not.toBeNaN();
      expect(Date.parse(responseBody[0].updated_at)).not.toBeNaN();

      expect(uuidVersion(responseBody[1].id)).toBe(4);
      expect(Date.parse(responseBody[1].created_at)).not.toBeNaN();
      expect(Date.parse(responseBody[1].updated_at)).not.toBeNaN();
    });

    test('With a "page" out of bounds', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users?page=5`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          cookie: `session_id=${privilegedUserSession.token}`,
        },
      });
      const responseBody = await response.json();

      const responseLinkHeader = parseLinkHeader(response.headers.get('Link'));
      const responseTotalRowsHeader = response.headers.get('X-Pagination-Total-Rows');

      expect.soft(response.status).toBe(200);
      expect(responseTotalRowsHeader).toBe('2');
      expect(responseLinkHeader).toStrictEqual({
        first: {
          page: '1',
          per_page: '30',
          rel: 'first',
          url: `${orchestrator.webserverUrl}/api/v1/users?page=1&per_page=30`,
        },
        prev: {
          page: '1',
          per_page: '30',
          rel: 'prev',
          url: `${orchestrator.webserverUrl}/api/v1/users?page=1&per_page=30`,
        },
        last: {
          page: '1',
          per_page: '30',
          rel: 'last',
          url: `${orchestrator.webserverUrl}/api/v1/users?page=1&per_page=30`,
        },
      });

      expect(responseBody).toStrictEqual([]);
    });
  });

  describe('User with "read:user:list" feature (dropAllTables beforeAll)', () => {
    describe('With 60 users', () => {
      const sortedByRecentlyUpdated = [];

      let privilegedUserSession;

      beforeAll(async () => {
        await orchestrator.dropAllTables();
        await orchestrator.runPendingMigrations();

        const numberOfUsers = 60;
        const sortedByNew = [];

        for (let index = 0; index < numberOfUsers; index++) {
          const user = await orchestrator.createUser({
            username: `user${index + 1}`,
          });
          sortedByNew.unshift({
            id: user.id,
            username: user.username,
            description: user.description,
            features: user.features,
            tabcoins: 0,
            tabcash: 0,
            created_at: user.created_at.toISOString(),
            updated_at: user.updated_at.toISOString(),
          });
        }

        // Oldest user will have 'read:user:list' feature
        await orchestrator.activateUser(sortedByNew.at(-1));
        let privilegedUser = await orchestrator.addFeaturesToUser(sortedByNew.at(-1), ['read:user:list']);
        privilegedUserSession = await orchestrator.createSession(privilegedUser);
        privilegedUser = {
          id: privilegedUser.id,
          username: privilegedUser.username,
          description: privilegedUser.description,
          features: privilegedUser.features,
          tabcoins: 0,
          tabcash: 0,
          created_at: privilegedUser.created_at.toISOString(),
          updated_at: privilegedUser.updated_at.toISOString(),
        };

        sortedByNew.pop();
        sortedByNew.push(privilegedUser);

        let updatedUser50 = await orchestrator.activateUser(sortedByNew.at(-49));
        updatedUser50 = {
          ...sortedByNew.at(-49),
          features: updatedUser50.features,
          updated_at: updatedUser50.updated_at.toISOString(),
        };

        sortedByRecentlyUpdated.push(...sortedByNew);

        const indexOfUpdatedUser1 = sortedByRecentlyUpdated.findIndex((user) => user.id === privilegedUser.id);
        const indexOfUpdatedUser50 = sortedByRecentlyUpdated.findIndex((user) => user.id === updatedUser50.id);

        sortedByRecentlyUpdated.splice(indexOfUpdatedUser1, 1);
        sortedByRecentlyUpdated.splice(indexOfUpdatedUser50, 1);

        sortedByRecentlyUpdated.unshift(privilegedUser);
        sortedByRecentlyUpdated.unshift(updatedUser50);
      });

      test('Navigating to next page', async () => {
        const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            cookie: `session_id=${privilegedUserSession.token}`,
          },
        });
        const responseBody = await response.json();

        const responseLinkHeader = parseLinkHeader(response.headers.get('Link'));
        const responseTotalRowsHeader = response.headers.get('X-Pagination-Total-Rows');

        expect.soft(response.status).toBe(200);
        expect(responseTotalRowsHeader).toBe('60');
        expect(responseLinkHeader).toStrictEqual({
          first: {
            page: '1',
            per_page: '30',
            rel: 'first',
            url: `${orchestrator.webserverUrl}/api/v1/users?page=1&per_page=30`,
          },
          next: {
            page: '2',
            per_page: '30',
            rel: 'next',
            url: `${orchestrator.webserverUrl}/api/v1/users?page=2&per_page=30`,
          },
          last: {
            page: '2',
            per_page: '30',
            rel: 'last',
            url: `${orchestrator.webserverUrl}/api/v1/users?page=2&per_page=30`,
          },
        });

        expect(responseBody).toStrictEqual(sortedByRecentlyUpdated.slice(0, 30));

        const page2Response = await fetch(responseLinkHeader.next.url, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            cookie: `session_id=${privilegedUserSession.token}`,
          },
        });
        const page2ResponseBody = await page2Response.json();

        const page2ResponseLinkHeader = parseLinkHeader(page2Response.headers.get('Link'));
        const page2ResponseTotalRowsHeader = page2Response.headers.get('X-Pagination-Total-Rows');

        expect.soft(page2Response.status).toBe(200);
        expect(page2ResponseTotalRowsHeader).toBe('60');
        expect(page2ResponseLinkHeader).toStrictEqual({
          first: {
            page: '1',
            per_page: '30',
            rel: 'first',
            url: `${orchestrator.webserverUrl}/api/v1/users?page=1&per_page=30`,
          },
          prev: {
            page: '1',
            per_page: '30',
            rel: 'prev',
            url: `${orchestrator.webserverUrl}/api/v1/users?page=1&per_page=30`,
          },
          last: {
            page: '2',
            per_page: '30',
            rel: 'last',
            url: `${orchestrator.webserverUrl}/api/v1/users?page=2&per_page=30`,
          },
        });

        expect(page2ResponseBody).toStrictEqual(sortedByRecentlyUpdated.slice(30));
      });

      test.each([
        {
          content: 'most recently updated users first',
          params: [],
          getExpected: () => sortedByRecentlyUpdated.slice(0, 30),
        },
        {
          content: 'first 15 users',
          params: ['per_page=15'],
          getExpected: () => sortedByRecentlyUpdated.slice(0, 15),
        },
        {
          content: 'second page with 10 users',
          params: ['per_page=10', 'page=2'],
          getExpected: () => sortedByRecentlyUpdated.slice(10, 20),
        },
      ])('Retrieving $content with params: $params', async ({ params, getExpected }) => {
        const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users?${params.join('&')}`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            cookie: `session_id=${privilegedUserSession.token}`,
          },
        });

        const responseBody = await response.json();

        expect.soft(response.status).toBe(200);
        expect(responseBody).toStrictEqual(getExpected());
      });
    });
  });
});
</file>

<file path="tests/integration/api/v1/users/post.test.js">
import { version as uuidVersion } from 'uuid';

import password from 'models/password.js';
import user from 'models/user.js';
import orchestrator from 'tests/orchestrator.js';
import RequestBuilder from 'tests/request-builder';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('POST /api/v1/users', () => {
  const usersRequestBuilder = new RequestBuilder('/api/v1/users');

  describe('Anonymous user', () => {
    test('With unique and valid data', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username: 'uniqueUserName',
          email: 'validemailCAPS@gmail.com',
          password: 'validpassword',
        }),
      });
      const responseBody = await response.json();

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        username: 'uniqueUserName',
        description: '',
        features: ['read:activation_token'],
        tabcoins: 0,
        tabcash: 0,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();

      const userInDatabase = await user.findOneByUsername('uniqueUserName');
      const passwordsMatch = await password.compare('validpassword', userInDatabase.password);
      const wrongPasswordMatch = await password.compare('wrongpassword', userInDatabase.password);

      expect(passwordsMatch).toBe(true);
      expect(wrongPasswordMatch).toBe(false);
      expect(userInDatabase.email).toBe('validemailcaps@gmail.com');
    });

    test('With unique and valid data, and an unknown key', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username: 'postWithUnknownKey',
          email: 'postWithUnknownKey@gmail.com',
          password: 'validpassword',
          unknownKey: 'unknownValue',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        username: 'postWithUnknownKey',
        description: '',
        features: ['read:activation_token'],
        tabcoins: 0,
        tabcash: 0,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();

      const userInDatabase = await user.findOneById(responseBody.id);
      expect(userInDatabase.email).toBe('postwithunknownkey@gmail.com');
    });

    test('With unique and valid data, but with "untrimmed" values', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username: 'extraSpaceInTheEnd ',
          email: ' space.in.the.beggining@gmail.com',
          password: 'validpassword ',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(201);

      expect(responseBody).toStrictEqual({
        id: responseBody.id,
        username: 'extraSpaceInTheEnd',
        description: '',
        features: ['read:activation_token'],
        tabcoins: 0,
        tabcash: 0,
        created_at: responseBody.created_at,
        updated_at: responseBody.updated_at,
      });

      expect(uuidVersion(responseBody.id)).toBe(4);
      expect(Date.parse(responseBody.created_at)).not.toBeNaN();
      expect(Date.parse(responseBody.updated_at)).not.toBeNaN();

      const userInDatabase = await user.findOneByUsername('extraSpaceInTheEnd');
      const passwordsMatch = await password.compare('validpassword', userInDatabase.password);
      const wrongPasswordMatch = await password.compare('validpassword ', userInDatabase.password);

      expect(passwordsMatch).toBe(true);
      expect(wrongPasswordMatch).toBe(false);
      expect(userInDatabase.email).toBe('space.in.the.beggining@gmail.com');
    });

    test('With "username" missing', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email: 'valid@email.com',
          password: 'validpassword123',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"username" é um campo obrigatório.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('username');
    });

    test('With "username" with a null value', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username: null,
          email: 'valid@email.com',
          password: 'validpassword123',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"username" deve ser do tipo String.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('username');
    });

    test('With "username" with an empty string', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username: '',
          email: 'valid@email.com',
          password: 'validpassword123',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"username" não pode estar em branco.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('username');
    });

    test('With "username" that\'s not a String', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username: 12345,
          email: 'valid@email.com',
          password: 'validpassword123',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"username" deve ser do tipo String.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('username');
    });

    test('With "username" containing non alphanumeric characters', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username: 'invalid!user_name',
          email: 'valid@email.com',
          password: 'validpassword123',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"username" deve conter apenas caracteres alfanuméricos.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('username');
    });

    test('With "username" too long', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username: 'userWith31Characterssssssssssss',
          email: 'valid@email.com',
          password: 'validpassword123',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"username" deve conter no máximo 30 caracteres.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('username');
    });

    test('With "username" in blocked list', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username: 'administrator',
          email: 'admin@email.com',
          password: 'validpassword123',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('Este nome de usuário não está disponível para uso.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('username');
    });

    test('With "email" missing', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username: 'notUsedUserName',
          password: 'validpassword123',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"email" é um campo obrigatório.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('email');
    });

    test('With "email" with an empty string', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username: 'notUsedUserName',
          email: '',
          password: 'validpassword123',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"email" não pode estar em branco.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('email');
    });

    test('With "email" that\'s not a String', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username: 'notUsedUserName',
          email: 12345,
          password: 'validpassword123',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"email" deve ser do tipo String.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('email');
    });

    test('With "email" with invalid format', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username: 'notUsedUserName',
          email: 'not.used.email@gmail.com@what',
          password: 'validpassword123',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"email" deve conter um email válido.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('email');
    });

    test('With "password" missing', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username: 'notUsedUserName',
          email: 'notusedemail@gmail.com',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"password" é um campo obrigatório.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('password');
    });

    test('With "password" with an empty string', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username: 'notUsedUserName',
          email: 'notusedemail@gmail.com',
          password: '',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"password" não pode estar em branco.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('password');
    });

    test('With "password" that\'s not a String', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username: 'notUsedUserName',
          email: 'notusedemail@gmail.com',
          password: 123456,
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"password" deve ser do tipo String.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('password');
    });

    test('With "password" too short', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username: 'notUsedUserName',
          email: 'notusedemail@gmail.com',
          password: '<8chars',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"password" deve conter no mínimo 8 caracteres.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('password');
    });

    test('With "password" too long', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          username: 'notUsedUserName',
          email: 'notusedemail@gmail.com',
          password: '73characterssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss',
        }),
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"password" deve conter no máximo 72 caracteres.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('password');
    });

    test('With "body" totally blank', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'POST',
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"body" enviado deve ser do tipo Object.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('object');
    });

    test('With "body" containing a String', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
        method: 'POST',
        body: "Please don't hack us, we are the good guys!",
      });

      const responseBody = await response.json();

      expect.soft(response.status).toBe(400);
      expect.soft(responseBody.status_code).toBe(400);
      expect(responseBody.name).toBe('ValidationError');
      expect(responseBody.message).toBe('"body" enviado deve ser do tipo Object.');
      expect(responseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
      expect(uuidVersion(responseBody.error_id)).toBe(4);
      expect(uuidVersion(responseBody.request_id)).toBe(4);
      expect(responseBody.error_location_code).toBe('MODEL:VALIDATOR:FINAL_SCHEMA');
      expect(responseBody.key).toBe('object');
    });

    describe('With duplicated "username" and/or "email"', () => {
      test('With "username" duplicated exactly (same uppercase letters)', async () => {
        // firstResponse
        await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            username: 'SaMeUPPERCASE',
            email: 'email01@gmail.com',
            password: 'validpassword',
          }),
        });

        const secondResponse = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            username: 'SaMeUPPERCASE',
            email: 'email02@gmail.com',
            password: 'validpassword',
          }),
        });

        const secondResponseBody = await secondResponse.json();

        expect.soft(secondResponse.status).toBe(400);
        expect.soft(secondResponseBody.status_code).toBe(400);
        expect(secondResponseBody.name).toBe('ValidationError');
        expect(secondResponseBody.message).toBe('O "username" informado já está sendo usado.');
        expect(secondResponseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
        expect(uuidVersion(secondResponseBody.error_id)).toBe(4);
        expect(uuidVersion(secondResponseBody.request_id)).toBe(4);
        expect(secondResponseBody.error_location_code).toBe('MODEL:USER:VALIDATE_UNIQUE_USERNAME:ALREADY_EXISTS');
        expect(secondResponseBody.key).toBe('username');
      });

      test('With "username" duplicated (different uppercase letters)', async () => {
        // firstResponse
        await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            username: 'DIFFERENTuppercase',
            email: 'email03@gmail.com',
            password: 'validpassword',
          }),
        });

        const secondResponse = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            username: 'differentUPPERCASE',
            email: 'email04@gmail.com',
            password: 'validpassword',
          }),
        });

        const secondResponseBody = await secondResponse.json();

        expect.soft(secondResponse.status).toBe(400);
        expect.soft(secondResponseBody.status_code).toBe(400);
        expect(secondResponseBody.name).toBe('ValidationError');
        expect(secondResponseBody.message).toBe('O "username" informado já está sendo usado.');
        expect(secondResponseBody.action).toBe('Ajuste os dados enviados e tente novamente.');
        expect(uuidVersion(secondResponseBody.error_id)).toBe(4);
        expect(uuidVersion(secondResponseBody.request_id)).toBe(4);
        expect(secondResponseBody.error_location_code).toBe('MODEL:USER:VALIDATE_UNIQUE_USERNAME:ALREADY_EXISTS');
        expect(secondResponseBody.key).toBe('username');
      });

      test('With "email" duplicated (same uppercase letters)', async () => {
        const firstResponse = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            username: 'anotherUserName111',
            email: 'email.will.be.duplicated@gmail.com',
            password: 'validpassword',
          }),
        });

        const firstResponseBody = await firstResponse.json();

        const secondResponse = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            username: 'anotherUserName222',
            email: 'email.will.be.duplicated@gmail.com',
            password: 'validpassword',
          }),
        });

        const secondResponseBody = await secondResponse.json();

        expect.soft(secondResponse.status).toBe(201);

        expect(secondResponseBody).toStrictEqual({
          id: secondResponseBody.id,
          username: 'anotherUserName222',
          description: '',
          features: ['read:activation_token'],
          tabcoins: 0,
          tabcash: 0,
          created_at: secondResponseBody.created_at,
          updated_at: secondResponseBody.updated_at,
        });
        expect(uuidVersion(secondResponseBody.id)).toBe(4);
        expect(Date.parse(secondResponseBody.created_at)).not.toBeNaN();
        expect(Date.parse(secondResponseBody.updated_at)).not.toBeNaN();

        await expect(user.findOneById(firstResponseBody.id)).resolves.not.toThrow();

        await expect(user.findOneById(secondResponseBody.id)).rejects.toThrow(
          `O id "${secondResponseBody.id}" não foi encontrado no sistema.`,
        );
      });

      test('With "email" duplicated (different uppercase letters)', async () => {
        const firstResponse = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            username: 'willTryToReuseEmail111',
            email: 'CAPS@gmail.com',
            password: 'validpassword',
          }),
        });

        const firstResponseBody = await firstResponse.json();

        const secondResponse = await fetch(`${orchestrator.webserverUrl}/api/v1/users`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            username: 'willTryToReuseEmail222',
            email: 'caps@gmail.com',
            password: 'validpassword',
          }),
        });

        const secondResponseBody = await secondResponse.json();

        expect.soft(secondResponse.status).toBe(201);

        expect(secondResponseBody).toStrictEqual({
          id: secondResponseBody.id,
          username: 'willTryToReuseEmail222',
          description: '',
          features: ['read:activation_token'],
          tabcoins: 0,
          tabcash: 0,
          created_at: secondResponseBody.created_at,
          updated_at: secondResponseBody.updated_at,
        });
        expect(uuidVersion(secondResponseBody.id)).toBe(4);
        expect(Date.parse(secondResponseBody.created_at)).not.toBeNaN();
        expect(Date.parse(secondResponseBody.updated_at)).not.toBeNaN();

        await expect(user.findOneById(firstResponseBody.id)).resolves.not.toThrow();

        await expect(user.findOneById(secondResponseBody.id)).rejects.toThrow(
          `O id "${secondResponseBody.id}" não foi encontrado no sistema.`,
        );
      });

      test('With a duplicate "username" for an active user with two activation tokens (one used, one expired)', async () => {
        const { response: firstResponse, responseBody: firstResponseBody } = await usersRequestBuilder.post({
          username: 'UsernameWith2Tokens',
          email: 'username.with.two.tokens@example.com',
          password: 'validpassword',
        });

        expect.soft(firstResponse.status).toBe(201);

        await orchestrator.updateActivateAccountTokenByUserId(firstResponseBody.id, {
          expires_at: new Date(Date.now() - 1000),
        });

        await orchestrator.createActivateAccountToken(firstResponseBody);
        await orchestrator.activateUser(firstResponseBody);

        const { response: secondResponse, responseBody: secondResponseBody } = await usersRequestBuilder.post({
          username: 'UsernameWith2Tokens',
          email: 'new.user.same.username@example.com',
          password: 'new-password',
        });

        expect.soft(secondResponse.status).toBe(400);
        expect(secondResponseBody).toStrictEqual({
          status_code: 400,
          name: 'ValidationError',
          message: 'O "username" informado já está sendo usado.',
          action: 'Ajuste os dados enviados e tente novamente.',
          error_location_code: 'MODEL:USER:VALIDATE_UNIQUE_USERNAME:ALREADY_EXISTS',
          key: 'username',
          error_id: secondResponseBody.error_id,
          request_id: secondResponseBody.request_id,
        });
        expect(uuidVersion(secondResponseBody.error_id)).toBe(4);
        expect(uuidVersion(secondResponseBody.request_id)).toBe(4);

        await expect(user.findOneById(firstResponseBody.id)).resolves.not.toThrow();
      });

      test('With a duplicate "email" for an active user with two activation tokens (one used, one expired)', async () => {
        const { response: firstResponse, responseBody: firstResponseBody } = await usersRequestBuilder.post({
          username: 'EmailWith2Tokens',
          email: 'email.with.two.tokens@example.com',
          password: 'validpassword',
        });

        expect.soft(firstResponse.status).toBe(201);

        await orchestrator.updateActivateAccountTokenByUserId(firstResponseBody.id, {
          expires_at: new Date(Date.now() - 1000),
        });

        await orchestrator.createActivateAccountToken(firstResponseBody);
        await orchestrator.activateUser(firstResponseBody);

        const { response: secondResponse, responseBody: secondResponseBody } = await usersRequestBuilder.post({
          username: 'AttemptReuseEmail',
          email: 'email.with.two.tokens@example.com',
          password: 'new-password',
        });

        expect.soft(secondResponse.status).toBe(201);
        expect(secondResponseBody).toStrictEqual({
          id: secondResponseBody.id,
          username: 'AttemptReuseEmail',
          description: '',
          features: ['read:activation_token'],
          tabcoins: 0,
          tabcash: 0,
          created_at: secondResponseBody.created_at,
          updated_at: secondResponseBody.updated_at,
        });
        expect(uuidVersion(secondResponseBody.id)).toBe(4);
        expect(Date.parse(secondResponseBody.created_at)).not.toBeNaN();
        expect(Date.parse(secondResponseBody.updated_at)).not.toBeNaN();

        await expect(user.findOneById(firstResponseBody.id)).resolves.not.toThrow();

        await expect(user.findOneById(secondResponseBody.id)).rejects.toThrow(
          `O id "${secondResponseBody.id}" não foi encontrado no sistema.`,
        );
      });

      test('With a duplicate "username" for an inactive user with expired activation token', async () => {
        const { response: firstResponse, responseBody: firstResponseBody } = await usersRequestBuilder.post({
          username: 'ARepeatedUsername',
          email: 'a-repeated-username-1@gmail.com',
          password: 'validpassword',
        });

        expect.soft(firstResponse.status).toBe(201);

        await orchestrator.updateActivateAccountTokenByUserId(firstResponseBody.id, {
          expires_at: new Date(Date.now() - 1000),
        });

        const { response: secondResponse, responseBody: secondResponseBody } = await usersRequestBuilder.post({
          username: 'ARepeatedUSERNAME',
          email: 'a-repeated-username-2@example.com',
          password: 'new-password',
        });

        expect.soft(secondResponse.status).toBe(201);
        expect(secondResponseBody).toStrictEqual({
          id: secondResponseBody.id,
          username: 'ARepeatedUSERNAME',
          description: '',
          features: ['read:activation_token'],
          tabcoins: 0,
          tabcash: 0,
          created_at: secondResponseBody.created_at,
          updated_at: secondResponseBody.updated_at,
        });
        expect(secondResponseBody.id).not.toBe(firstResponseBody.id);

        expect(new Date(secondResponseBody.created_at).getTime()).toBeGreaterThan(
          new Date(firstResponseBody.created_at).getTime(),
        );
        expect(new Date(secondResponseBody.updated_at).getTime()).toBeGreaterThan(
          new Date(firstResponseBody.updated_at).getTime(),
        );

        const userInDatabase = await user.findOneById(secondResponseBody.id);

        const passwordsMatch = await password.compare('new-password', userInDatabase.password);
        expect(passwordsMatch).toBe(true);
        expect(userInDatabase.username).toBe('ARepeatedUSERNAME');
        expect(userInDatabase.email).toBe('a-repeated-username-2@example.com');

        await expect(user.findOneById(firstResponseBody.id)).rejects.toThrow(
          `O id "${firstResponseBody.id}" não foi encontrado no sistema.`,
        );
      });

      test('With a duplicate "email" for an inactive user with expired activation token', async () => {
        const { response: firstResponse, responseBody: firstResponseBody } = await usersRequestBuilder.post({
          username: 'ARepeatedEmail',
          email: 'a-repeated-email@gmail.com',
          password: 'validpassword',
        });

        expect.soft(firstResponse.status).toBe(201);

        await orchestrator.updateActivateAccountTokenByUserId(firstResponseBody.id, {
          expires_at: new Date(Date.now() - 1000),
        });

        const { response: secondResponse, responseBody: secondResponseBody } = await usersRequestBuilder.post({
          username: 'ARepeatedEmail2',
          email: 'A-Repeated-Email@gmail.com',
          password: 'new-password',
        });

        expect.soft(secondResponse.status).toBe(201);
        expect(secondResponseBody).toStrictEqual({
          id: secondResponseBody.id,
          username: 'ARepeatedEmail2',
          description: '',
          features: ['read:activation_token'],
          tabcoins: 0,
          tabcash: 0,
          created_at: secondResponseBody.created_at,
          updated_at: secondResponseBody.updated_at,
        });
        expect(secondResponseBody.id).not.toBe(firstResponseBody.id);

        expect(new Date(secondResponseBody.created_at).getTime()).toBeGreaterThan(
          new Date(firstResponseBody.created_at).getTime(),
        );
        expect(new Date(secondResponseBody.updated_at).getTime()).toBeGreaterThan(
          new Date(firstResponseBody.updated_at).getTime(),
        );

        const userInDatabase = await user.findOneById(secondResponseBody.id);
        const passwordsMatch = await password.compare('new-password', userInDatabase.password);

        expect(passwordsMatch).toBe(true);
        expect(userInDatabase.username).toBe('ARepeatedEmail2');
        expect(userInDatabase.email).toBe('a-repeated-email@gmail.com');

        await expect(user.findOneById(firstResponseBody.id)).rejects.toThrow(
          `O id "${firstResponseBody.id}" não foi encontrado no sistema.`,
        );
      });

      test('With "username" and "email" duplicated of an inactive nuked user with expired activation token', async () => {
        const { response: firstResponse, responseBody: firstResponseBody } = await usersRequestBuilder.post({
          username: 'SaMeUsErNaMeNuked',
          email: 'SaMeEmAiL+nuked@example.com',
          password: 'validpassword',
        });

        expect.soft(firstResponse.status).toBe(201);

        await orchestrator.nukeUser(firstResponseBody);

        await orchestrator.updateActivateAccountTokenByUserId(firstResponseBody.id, {
          expires_at: new Date(Date.now() - 1000),
        });

        const { response: secondResponse, responseBody: secondResponseBody } = await usersRequestBuilder.post({
          username: 'sameUsernameNuked',
          email: 'sameEmail+nuked@example.com',
          password: 'new-password',
        });

        expect.soft(secondResponse.status).toBe(400);
        expect(secondResponseBody).toStrictEqual({
          status_code: 400,
          name: 'ValidationError',
          message: 'O "username" informado já está sendo usado.',
          action: 'Ajuste os dados enviados e tente novamente.',
          error_location_code: 'MODEL:USER:VALIDATE_UNIQUE_USERNAME:ALREADY_EXISTS',
          key: 'username',
          error_id: secondResponseBody.error_id,
          request_id: secondResponseBody.request_id,
        });
        expect(uuidVersion(secondResponseBody.error_id)).toBe(4);
        expect(uuidVersion(secondResponseBody.request_id)).toBe(4);

        await expect(user.findOneById(firstResponseBody.id)).resolves.not.toThrow();
      });

      test('With a duplicate "username" for an active user with expired activation token', async () => {
        const { response: firstResponse, responseBody: firstResponseBody } = await usersRequestBuilder.post({
          username: 'SameActiveUsername',
          email: 'same-active-username-1@gmail.com',
          password: 'validpassword',
        });

        expect.soft(firstResponse.status).toBe(201);

        await orchestrator.activateUser(firstResponseBody);

        await orchestrator.updateActivateAccountTokenByUserId(firstResponseBody.id, {
          expires_at: new Date(Date.now() - 1000),
        });

        const { response: secondResponse, responseBody: secondResponseBody } = await usersRequestBuilder.post({
          username: 'SameActiveUsername',
          email: 'same-active-username-2@example.com',
          password: 'new-password',
        });

        expect.soft(secondResponse.status).toBe(400);
        expect(secondResponseBody).toStrictEqual({
          status_code: 400,
          name: 'ValidationError',
          message: 'O "username" informado já está sendo usado.',
          action: 'Ajuste os dados enviados e tente novamente.',
          error_location_code: 'MODEL:USER:VALIDATE_UNIQUE_USERNAME:ALREADY_EXISTS',
          key: 'username',
          error_id: secondResponseBody.error_id,
          request_id: secondResponseBody.request_id,
        });
        expect(uuidVersion(secondResponseBody.error_id)).toBe(4);
        expect(uuidVersion(secondResponseBody.request_id)).toBe(4);

        const userInDatabase = await user.findOneById(firstResponseBody.id);
        expect(userInDatabase.email).toBe('same-active-username-1@gmail.com');
      });

      test('With a duplicate "email" for an active nuked user with expired activation token', async () => {
        const { response: firstResponse, responseBody: firstResponseBody } = await usersRequestBuilder.post({
          username: 'ActiveNukedUser',
          email: 'active-nuked-user@example.com',
          password: 'validpassword',
        });

        expect.soft(firstResponse.status).toBe(201);

        await orchestrator.activateUser(firstResponseBody);

        await orchestrator.updateActivateAccountTokenByUserId(firstResponseBody.id, {
          expires_at: new Date(Date.now() - 1000),
        });

        await orchestrator.nukeUser(firstResponseBody);

        const { response: secondResponse, responseBody: secondResponseBody } = await usersRequestBuilder.post({
          username: 'NewRandomUser',
          email: 'active-nuked-user@example.com',
          password: 'new-password',
        });

        expect.soft(secondResponse.status).toBe(201);
        expect(secondResponseBody).toStrictEqual({
          id: secondResponseBody.id,
          username: 'NewRandomUser',
          description: '',
          features: ['read:activation_token'],
          tabcoins: 0,
          tabcash: 0,
          created_at: secondResponseBody.created_at,
          updated_at: secondResponseBody.updated_at,
        });

        const userInDatabase = await user.findOneById(firstResponseBody.id);
        expect(userInDatabase.username).toBe('ActiveNukedUser');
        expect(userInDatabase.email).toBe('active-nuked-user@example.com');

        await expect(user.findOneById(secondResponseBody.id)).rejects.toThrow(
          `O id "${secondResponseBody.id}" não foi encontrado no sistema.`,
        );
      });

      test('With "username" and "email" duplicated from different users, both inactive with expired tokens', async () => {
        const { response: firstResponse, responseBody: firstResponseBody } = await usersRequestBuilder.post({
          username: 'firstUserExpiredToken',
          email: 'first-user@example.com',
          password: 'validpassword',
        });

        expect.soft(firstResponse.status).toBe(201);

        await orchestrator.updateActivateAccountTokenByUserId(firstResponseBody.id, {
          expires_at: new Date(Date.now() - 1000),
        });

        const { response: secondResponse, responseBody: secondResponseBody } = await usersRequestBuilder.post({
          username: 'secondUserExpiredToken',
          email: 'second-user@example.com',
          password: 'validpassword',
        });

        expect.soft(secondResponse.status).toBe(201);

        await orchestrator.updateActivateAccountTokenByUserId(secondResponseBody.id, {
          expires_at: new Date(Date.now() - 1000),
        });

        const { response: thirdResponse, responseBody: thirdResponseBody } = await usersRequestBuilder.post({
          username: 'firstUserExpiredToken',
          email: 'second-user@example.com',
          password: 'new-password',
        });

        expect.soft(thirdResponse.status).toBe(201);
        expect(thirdResponseBody).toStrictEqual({
          id: thirdResponseBody.id,
          username: 'firstUserExpiredToken',
          description: '',
          features: ['read:activation_token'],
          tabcoins: 0,
          tabcash: 0,
          created_at: thirdResponseBody.created_at,
          updated_at: thirdResponseBody.updated_at,
        });
        expect(thirdResponseBody.id).not.toBe(firstResponseBody.id);
        expect(thirdResponseBody.id).not.toBe(secondResponseBody.id);

        expect(new Date(thirdResponseBody.created_at).getTime()).toBeGreaterThan(
          new Date(secondResponseBody.created_at).getTime(),
        );
        expect(new Date(thirdResponseBody.updated_at).getTime()).toBeGreaterThan(
          new Date(secondResponseBody.updated_at).getTime(),
        );

        const userInDatabase = await user.findOneById(thirdResponseBody.id);
        const passwordsMatch = await password.compare('new-password', userInDatabase.password);

        expect(passwordsMatch).toBe(true);
        expect(userInDatabase.username).toBe('firstUserExpiredToken');
        expect(userInDatabase.email).toBe('second-user@example.com');

        await expect(user.findOneById(firstResponseBody.id)).rejects.toThrow(
          `O id "${firstResponseBody.id}" não foi encontrado no sistema.`,
        );
        await expect(user.findOneById(secondResponseBody.id)).rejects.toThrow(
          `O id "${secondResponseBody.id}" não foi encontrado no sistema.`,
        );
      });

      test('With "username" and "email" duplicated from different users, one inactive and the other active, both with expired tokens', async () => {
        const { response: firstResponse, responseBody: firstResponseBody } = await usersRequestBuilder.post({
          username: 'firstInactiveUser',
          email: 'first-inactive-user@example.com',
          password: 'validpassword',
        });

        expect.soft(firstResponse.status).toBe(201);

        await orchestrator.updateActivateAccountTokenByUserId(firstResponseBody.id, {
          expires_at: new Date(Date.now() - 1000),
        });

        const { response: secondResponse, responseBody: secondResponseBody } = await usersRequestBuilder.post({
          username: 'secondActiveUser',
          email: 'second-active-user@example.com',
          password: 'validpassword',
        });

        expect.soft(secondResponse.status).toBe(201);

        await orchestrator.activateUser(secondResponseBody);

        await orchestrator.updateActivateAccountTokenByUserId(secondResponseBody.id, {
          expires_at: new Date(Date.now() - 1000),
        });

        const { response: thirdResponse, responseBody: thirdResponseBody } = await usersRequestBuilder.post({
          username: 'secondActiveUser',
          email: 'first-inactive-user@example.com',
          password: 'new-password',
        });

        expect.soft(thirdResponse.status).toBe(400);
        expect(thirdResponseBody).toStrictEqual({
          status_code: 400,
          name: 'ValidationError',
          message: 'O "username" informado já está sendo usado.',
          action: 'Ajuste os dados enviados e tente novamente.',
          error_location_code: 'MODEL:USER:VALIDATE_UNIQUE_USERNAME:ALREADY_EXISTS',
          key: 'username',
          error_id: thirdResponseBody.error_id,
          request_id: thirdResponseBody.request_id,
        });
        expect(uuidVersion(thirdResponseBody.error_id)).toBe(4);
        expect(uuidVersion(thirdResponseBody.request_id)).toBe(4);

        const firstUserInDatabase = await user.findOneById(firstResponseBody.id);
        expect(firstUserInDatabase.username).toBe('firstInactiveUser');
        expect(firstUserInDatabase.email).toBe('first-inactive-user@example.com');

        const secondUserInDatabase = await user.findOneById(secondResponseBody.id);
        expect(secondUserInDatabase.username).toBe('secondActiveUser');
        expect(secondUserInDatabase.email).toBe('second-active-user@example.com');
      });

      test('With a duplicate "username" for an active user and duplicate "email" for inactive user with expired token', async () => {
        const { response: firstResponse, responseBody: firstResponseBody } = await usersRequestBuilder.post({
          username: 'ActiveUsername',
          email: 'active.username@example.com',
          password: 'validpassword',
        });

        expect.soft(firstResponse.status).toBe(201);

        await orchestrator.activateUser(firstResponseBody);

        const { response: secondResponse, responseBody: secondResponseBody } = await usersRequestBuilder.post({
          username: 'InactiveEmail',
          email: 'inactive.email@example.com',
          password: 'validpassword',
        });

        expect.soft(secondResponse.status).toBe(201);

        await orchestrator.updateActivateAccountTokenByUserId(secondResponseBody.id, {
          expires_at: new Date(Date.now() - 1000),
        });

        const { response: thirdResponse, responseBody: thirdResponseBody } = await usersRequestBuilder.post({
          username: 'ActiveUsername',
          email: 'inactive.email@example.com',
          password: 'validpassword',
        });

        expect.soft(thirdResponse.status).toBe(400);
        expect(thirdResponseBody).toStrictEqual({
          status_code: 400,
          name: 'ValidationError',
          message: 'O "username" informado já está sendo usado.',
          action: 'Ajuste os dados enviados e tente novamente.',
          error_location_code: 'MODEL:USER:VALIDATE_UNIQUE_USERNAME:ALREADY_EXISTS',
          key: 'username',
          error_id: thirdResponseBody.error_id,
          request_id: thirdResponseBody.request_id,
        });
        expect(uuidVersion(thirdResponseBody.error_id)).toBe(4);
        expect(uuidVersion(thirdResponseBody.request_id)).toBe(4);

        await expect(user.findOneById(firstResponseBody.id)).resolves.not.toThrow();
        await expect(user.findOneById(secondResponseBody.id)).resolves.not.toThrow();
      });
    });
  });
});
</file>

<file path="tests/integration/infra/under-maintenance.test.js">
import orchestrator from 'tests/orchestrator.js';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('Under maintenance route', () => {
  describe('Anonymous user', () => {
    test('Trying to access "method" and "path" under maintenance', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/under-maintenance-test`, {
        method: 'POST',
      });
      const responseBody = await response.json();

      expect.soft(response.status).toBe(503);
      expect(responseBody.message).toBe('Funcionalidade em manutenção.');
      expect(responseBody.action).toBe('Tente novamente mais tarde.');
      expect(responseBody.error_location_code).toBe('INFRA:UNDER_MAINTENANCE:CHECK:IS_UNDER_MAINTENANCE');
    });

    test('Trying to access "method" under maintenance, but distinct "path"', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/inexistent-route`, {
        method: 'POST',
      });

      expect.soft(response.status).toBe(404);
      expect(response.statusText).toBe('Not Found');
      expect(response.ok).toBe(false);
    });

    test('Trying to access "path" under maintenance, but distinct "method"', async () => {
      const response = await fetch(`${orchestrator.webserverUrl}/api/v1/under-maintenance-test`, {
        method: 'GET',
      });

      expect.soft(response.status).toBe(404);
      expect(response.statusText).toBe('Not Found');
      expect(response.ok).toBe(false);
    });
  });
});
</file>

<file path="tests/integration/models/event.test.js">
import { version as uuidVersion } from 'uuid';

import orchestrator from 'tests/orchestrator';
import RequestBuilder from 'tests/request-builder';

beforeAll(async () => {
  await orchestrator.waitForAllServices();
  await orchestrator.dropAllTables();
  await orchestrator.runPendingMigrations();
});

describe('models/event', () => {
  describe('Anonymous user', () => {
    test('Create "create:user" event', async () => {
      const usersRequestBuilder = new RequestBuilder('/api/v1/users');
      const { responseBody: createUserResponseBody } = await usersRequestBuilder.post({
        username: 'validusername',
        email: 'valid@email.com',
        password: 'validpassword',
      });

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'create:user',
        originator_user_id: createUserResponseBody.id,
        originator_ip: '127.0.0.1',
        created_at: lastEvent.created_at,
        metadata: {
          id: createUserResponseBody.id,
        },
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
    });
  });

  test('Create "update:user" event for password update', async () => {
    const defaultUser = await orchestrator.createUser();
    const recoveryToken = await orchestrator.createRecoveryToken(defaultUser);

    const recoveryRequestBuilder = new RequestBuilder('/api/v1/recovery');
    await recoveryRequestBuilder.patch({
      token_id: recoveryToken.id,
      password: 'newPassword',
    });

    const lastEvent = await orchestrator.getLastEvent();

    expect(lastEvent).toStrictEqual({
      id: lastEvent.id,
      type: 'update:user',
      originator_user_id: null,
      originator_ip: '127.0.0.1',
      created_at: lastEvent.created_at,
      metadata: {
        id: defaultUser.id,
        updatedFields: ['password'],
      },
    });

    expect(uuidVersion(lastEvent.id)).toBe(4);
    expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
  });

  describe('Default user', () => {
    test('Create "update:user" event', async () => {
      const usersRequestBuilder = new RequestBuilder('/api/v1/users');
      const defaultUser = await usersRequestBuilder.buildUser();

      const { responseBody } = await usersRequestBuilder.patch(`/${defaultUser.username}`, {
        username: 'newusername',
        description: 'new description',
        email: 'new@email.com',
        notifications: false,
      });

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'update:user',
        originator_user_id: defaultUser.id,
        originator_ip: '127.0.0.1',
        created_at: lastEvent.created_at,
        metadata: {
          id: defaultUser.id,
          updatedFields: ['description', 'notifications', 'username'],
          username: {
            old: defaultUser.username,
            new: responseBody.username,
          },
        },
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
    });

    test('Create "create:content:text_root" event', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { responseBody: createContentRootResponseBody } = await contentsRequestBuilder.post({
        title: 'Root',
        body: 'Root',
        status: 'published',
      });

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'create:content:text_root',
        originator_user_id: defaultUser.id,
        originator_ip: '127.0.0.1',
        created_at: lastEvent.created_at,
        metadata: {
          id: createContentRootResponseBody.id,
        },
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
    });

    test('Create "create:content:text_child" event', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { responseBody: createContentRootResponseBody } = await contentsRequestBuilder.post({
        title: 'Root',
        body: 'Root',
        status: 'published',
      });

      const { responseBody: createContentChildResponseBody } = await contentsRequestBuilder.post({
        title: 'Child',
        body: 'Child',
        status: 'published',
        parent_id: createContentRootResponseBody.id,
      });

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'create:content:text_child',
        originator_user_id: defaultUser.id,
        originator_ip: '127.0.0.1',
        created_at: lastEvent.created_at,
        metadata: {
          id: createContentChildResponseBody.id,
        },
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
    });

    test('Create "update:content:text_root" event', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { responseBody: createContentRootResponseBody } = await contentsRequestBuilder.post({
        title: 'Root',
        body: 'Root',
        status: 'published',
      });

      await contentsRequestBuilder.patch(`/${defaultUser.username}/${createContentRootResponseBody.slug}`, {
        title: 'Root Updated',
        body: 'Root Updated',
        status: 'deleted',
      });

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'update:content:text_root',
        originator_user_id: defaultUser.id,
        originator_ip: '127.0.0.1',
        created_at: lastEvent.created_at,
        metadata: {
          id: createContentRootResponseBody.id,
        },
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
    });

    test('Create "update:content:text_child" event', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { responseBody: createContentRootResponseBody } = await contentsRequestBuilder.post({
        title: 'Root',
        body: 'Root',
        status: 'published',
      });

      const { responseBody: createContentChildResponseBody } = await contentsRequestBuilder.post({
        body: 'Child',
        status: 'published',
        parent_id: createContentRootResponseBody.id,
      });

      await contentsRequestBuilder.patch(`/${defaultUser.username}/${createContentChildResponseBody.slug}`, {
        body: 'Child Updated',
        status: 'deleted',
      });

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'update:content:text_child',
        originator_user_id: defaultUser.id,
        originator_ip: '127.0.0.1',
        created_at: lastEvent.created_at,
        metadata: {
          id: createContentChildResponseBody.id,
        },
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
    });

    test('Create "update:content:tabcoins" with "transaction_type" set to "credit"', async () => {
      const firstUser = await orchestrator.createUser();
      const firstUserContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root',
        body: 'Body',
        status: 'published',
      });

      const tabcoinsRequestBuilder = new RequestBuilder(
        `/api/v1/contents/${firstUser.username}/${firstUserContent.slug}/tabcoins`,
      );
      const secondUser = await tabcoinsRequestBuilder.buildUser();

      await orchestrator.createBalance({
        balanceType: 'user:tabcoin',
        recipientId: secondUser.id,
        amount: 2,
      });

      await tabcoinsRequestBuilder.post({
        transaction_type: 'credit',
      });

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'update:content:tabcoins',
        originator_user_id: secondUser.id,
        originator_ip: '127.0.0.1',
        created_at: lastEvent.created_at,
        metadata: {
          amount: 2,
          content_id: firstUserContent.id,
          from_user_id: secondUser.id,
          content_owner_id: firstUser.id,
          transaction_type: 'credit',
        },
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
    });

    test('Create "update:content:tabcoins" with "transaction_type" set to "debit"', async () => {
      const firstUser = await orchestrator.createUser();
      const firstUserContent = await orchestrator.createContent({
        owner_id: firstUser.id,
        title: 'Root',
        body: 'Body',
        status: 'published',
      });

      const tabcoinsRequestBuilder = new RequestBuilder(
        `/api/v1/contents/${firstUser.username}/${firstUserContent.slug}/tabcoins`,
      );
      const secondUser = await tabcoinsRequestBuilder.buildUser();

      await orchestrator.createBalance({
        balanceType: 'user:tabcoin',
        recipientId: secondUser.id,
        amount: 2,
      });

      await tabcoinsRequestBuilder.post({
        transaction_type: 'debit',
      });

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'update:content:tabcoins',
        originator_user_id: secondUser.id,
        originator_ip: '127.0.0.1',
        created_at: lastEvent.created_at,
        metadata: {
          amount: 2,
          content_id: firstUserContent.id,
          from_user_id: secondUser.id,
          content_owner_id: firstUser.id,
          transaction_type: 'debit',
        },
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
    });

    test('Create "reward:user:tabcoins" event', async () => {
      const userRequestBuilder = new RequestBuilder('/api/v1/user');
      const defaultUser = await userRequestBuilder.buildUser();
      await orchestrator.createPrestige(defaultUser.id);

      await orchestrator.updateRewardedAt(
        defaultUser.id,
        new Date(Date.now() - 1000 - 1000 * 60 * 60 * 24), // 1 day and 1 second ago
      );

      await userRequestBuilder.get();

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'reward:user:tabcoins',
        originator_user_id: defaultUser.id,
        originator_ip: '127.0.0.1',
        created_at: lastEvent.created_at,
        metadata: {
          amount: 2,
          reward_type: 'daily',
        },
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
      expect(Date.parse(lastEvent.created_at)).toBeGreaterThan(Date.now() - 1000);
    });
  });

  describe('Privileged user', () => {
    test('Create "update:user" event', async () => {
      const usersRequestBuilder = new RequestBuilder('/api/v1/users');
      const userToBeUpdated = await usersRequestBuilder.buildUser();
      const privilegedUser = await usersRequestBuilder.buildUser({ with: ['update:user:others'] });

      await usersRequestBuilder.patch(`/${userToBeUpdated.username}`, {
        username: 'newusername',
        description: 'new description',
        email: 'new@email.com',
        notifications: false,
      });

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'update:user',
        originator_user_id: privilegedUser.id,
        originator_ip: '127.0.0.1',
        created_at: lastEvent.created_at,
        metadata: {
          id: userToBeUpdated.id,
          updatedFields: ['description'],
        },
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
    });

    test('Create "ban:user" event', async () => {
      const usersRequestBuilder = new RequestBuilder('/api/v1/users');
      const userToBan = await usersRequestBuilder.buildUser();
      const privilegedUser = await usersRequestBuilder.buildUser({ with: ['ban:user'] });

      await usersRequestBuilder.delete(`/${userToBan.username}`, {
        ban_type: 'nuke',
      });

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'ban:user',
        originator_user_id: privilegedUser.id,
        originator_ip: '127.0.0.1',
        created_at: lastEvent.created_at,
        metadata: {
          ban_type: 'nuke',
          user_id: userToBan.id,
        },
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
    });

    test('Create "update:content:text_root" event', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { responseBody: createContentRootResponseBody } = await contentsRequestBuilder.post({
        title: 'Root',
        body: 'Root',
        status: 'published',
      });

      const privilegedUser = await contentsRequestBuilder.buildUser({ with: ['update:content:others'] });

      await contentsRequestBuilder.patch(`/${defaultUser.username}/${createContentRootResponseBody.slug}`, {
        title: 'Root Updated',
        body: 'Root Updated',
        status: 'deleted',
      });

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'update:content:text_root',
        originator_user_id: privilegedUser.id,
        originator_ip: '127.0.0.1',
        created_at: lastEvent.created_at,
        metadata: {
          id: createContentRootResponseBody.id,
        },
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
    });

    test('Create "update:content:text_child" event', async () => {
      const contentsRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentsRequestBuilder.buildUser();

      const { responseBody: createContentRootResponseBody } = await contentsRequestBuilder.post({
        title: 'Root',
        body: 'Root',
        status: 'published',
      });

      const { responseBody: createContentChildResponseBody } = await contentsRequestBuilder.post({
        body: 'Child',
        status: 'published',
        parent_id: createContentRootResponseBody.id,
      });

      const privilegedUser = await contentsRequestBuilder.buildUser({ with: ['update:content:others'] });

      await contentsRequestBuilder.patch(`/${defaultUser.username}/${createContentChildResponseBody.slug}`, {
        body: 'Child Updated',
        status: 'deleted',
      });

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'update:content:text_child',
        originator_user_id: privilegedUser.id,
        originator_ip: '127.0.0.1',
        created_at: lastEvent.created_at,
        metadata: {
          id: createContentChildResponseBody.id,
        },
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
    });
  });

  describe('Firewall', () => {
    beforeEach(async () => {
      await orchestrator.dropAllTables();
      await orchestrator.runPendingMigrations();
      await orchestrator.createFirewallTestFunctions();
    });

    test('Create "firewall:block_users" event', async () => {
      const usersRequestBuilder = new RequestBuilder('/api/v1/users');

      const { responseBody: user1 } = await usersRequestBuilder.post({
        username: 'request1',
        email: 'request1@gmail.com',
        password: 'validpassword',
      });

      const { responseBody: user2 } = await usersRequestBuilder.post({
        username: 'request2',
        email: 'request2@gmail.com',
        password: 'validpassword',
      });

      await usersRequestBuilder.post({
        username: 'request3',
        email: 'request3@gmail.com',
        password: 'validpassword',
      });

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'firewall:block_users',
        originator_user_id: null,
        originator_ip: '127.0.0.1',
        metadata: {
          from_rule: 'create:user',
          users: [user1.id, user2.id],
        },
        created_at: lastEvent.created_at,
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
    });

    test('Create "firewall:block_contents:text_root" event', async () => {
      const contentRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentRequestBuilder.buildUser();

      const { responseBody: content1 } = await contentRequestBuilder.post({
        title: 'Título 1',
        body: 'Corpo',
        status: 'published',
      });

      const { responseBody: content2 } = await contentRequestBuilder.post({
        title: 'Título 2',
        body: 'Corpo',
        status: 'published',
      });

      await contentRequestBuilder.post({
        title: 'Título 3',
        body: 'Corpo',
        status: 'published',
      });

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'firewall:block_contents:text_root',
        originator_user_id: defaultUser.id,
        originator_ip: '127.0.0.1',
        metadata: {
          from_rule: 'create:content:text_root',
          contents: [content1.id, content2.id],
        },
        created_at: lastEvent.created_at,
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
    });

    test('Create "firewall:block_contents:text_child" event', async () => {
      const contentRequestBuilder = new RequestBuilder('/api/v1/contents');
      const defaultUser = await contentRequestBuilder.buildUser();

      const { responseBody: rootContentBody } = await contentRequestBuilder.post({
        title: 'Root Content',
        body: 'Corpo',
      });

      const { responseBody: content1 } = await contentRequestBuilder.post({
        body: 'Corpo',
        parent_id: rootContentBody.id,
        status: 'published',
      });

      const { responseBody: content2 } = await contentRequestBuilder.post({
        body: 'Corpo',
        parent_id: rootContentBody.id,
        status: 'published',
      });

      await contentRequestBuilder.post({
        body: 'Corpo',
        parent_id: rootContentBody.id,
        status: 'published',
      });

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'firewall:block_contents:text_child',
        originator_user_id: defaultUser.id,
        originator_ip: '127.0.0.1',
        metadata: {
          from_rule: 'create:content:text_child',
          contents: [content1.id, content2.id],
        },
        created_at: lastEvent.created_at,
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
    });
  });

  describe('Moderation', () => {
    beforeEach(async () => {
      await orchestrator.dropAllTables();
      await orchestrator.runPendingMigrations();
      await orchestrator.createFirewallTestFunctions();
    });

    test('Create "moderation:block_users" event', async () => {
      const usersRequestBuilder = new RequestBuilder('/api/v1/users');

      const { responseBody: user1 } = await usersRequestBuilder.post({
        username: 'request1',
        email: 'request1@gmail.com',
        password: 'validpassword',
      });

      const { responseBody: user2 } = await usersRequestBuilder.post({
        username: 'request2',
        email: 'request2@gmail.com',
        password: 'validpassword',
      });

      await usersRequestBuilder.post({
        username: 'request3',
        email: 'request3@gmail.com',
        password: 'validpassword',
      });

      const firewallEvent = await orchestrator.getLastEvent();

      const reviewFirewallRequestBuilder = new RequestBuilder(
        `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
      );
      const reviewerUser = await reviewFirewallRequestBuilder.buildUser({ with: ['read:firewall', 'review:firewall'] });

      await reviewFirewallRequestBuilder.post({ action: 'confirm' });

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'moderation:block_users',
        originator_user_id: reviewerUser.id,
        originator_ip: '127.0.0.1',
        metadata: {
          related_events: [firewallEvent.id],
          users: [user1.id, user2.id],
        },
        created_at: lastEvent.created_at,
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
    });

    test('Create "moderation:unblock_users" event', async () => {
      const usersRequestBuilder = new RequestBuilder('/api/v1/users');

      const { responseBody: user1 } = await usersRequestBuilder.post({
        username: 'request1',
        email: 'request1@gmail.com',
        password: 'validpassword',
      });

      const { responseBody: user2 } = await usersRequestBuilder.post({
        username: 'request2',
        email: 'request2@gmail.com',
        password: 'validpassword',
      });

      await usersRequestBuilder.post({
        username: 'request3',
        email: 'request3@gmail.com',
        password: 'validpassword',
      });

      const firewallEvent = await orchestrator.getLastEvent();

      const reviewFirewallRequestBuilder = new RequestBuilder(
        `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
      );
      const reviewerUser = await reviewFirewallRequestBuilder.buildUser({ with: ['read:firewall', 'review:firewall'] });

      await reviewFirewallRequestBuilder.post({ action: 'undo' });

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'moderation:unblock_users',
        originator_user_id: reviewerUser.id,
        originator_ip: '127.0.0.1',
        metadata: {
          related_events: [firewallEvent.id],
          users: [user1.id, user2.id],
        },
        created_at: lastEvent.created_at,
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
    });

    test('Create "moderation:block_contents:text_root" event', async () => {
      const contentRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentRequestBuilder.buildUser();

      const { responseBody: content1 } = await contentRequestBuilder.post({
        title: 'Título 1',
        body: 'Corpo',
        status: 'published',
      });

      const { responseBody: content2 } = await contentRequestBuilder.post({
        title: 'Título 2',
        body: 'Corpo',
        status: 'published',
      });

      await contentRequestBuilder.post({
        title: 'Título 3',
        body: 'Corpo',
        status: 'published',
      });

      const firewallEvent = await orchestrator.getLastEvent();

      const reviewFirewallRequestBuilder = new RequestBuilder(
        `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
      );
      const reviewerUser = await reviewFirewallRequestBuilder.buildUser({ with: ['read:firewall', 'review:firewall'] });

      await reviewFirewallRequestBuilder.post({ action: 'confirm' });

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'moderation:block_contents:text_root',
        originator_user_id: reviewerUser.id,
        originator_ip: '127.0.0.1',
        metadata: {
          related_events: [firewallEvent.id],
          contents: [content1.id, content2.id],
        },
        created_at: lastEvent.created_at,
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
    });

    test('Create "moderation:unblock_contents:text_root" event', async () => {
      const contentRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentRequestBuilder.buildUser();

      const { responseBody: content1 } = await contentRequestBuilder.post({
        title: 'Título 1',
        body: 'Corpo',
        status: 'published',
      });

      const { responseBody: content2 } = await contentRequestBuilder.post({
        title: 'Título 2',
        body: 'Corpo',
        status: 'published',
      });

      await contentRequestBuilder.post({
        title: 'Título 3',
        body: 'Corpo',
        status: 'published',
      });

      const firewallEvent = await orchestrator.getLastEvent();

      const reviewFirewallRequestBuilder = new RequestBuilder(
        `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
      );
      const reviewerUser = await reviewFirewallRequestBuilder.buildUser({ with: ['read:firewall', 'review:firewall'] });

      await reviewFirewallRequestBuilder.post({ action: 'undo' });

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'moderation:unblock_contents:text_root',
        originator_user_id: reviewerUser.id,
        originator_ip: '127.0.0.1',
        metadata: {
          related_events: [firewallEvent.id],
          contents: [content1.id, content2.id],
        },
        created_at: lastEvent.created_at,
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
    });

    test('Create "moderation:block_contents:text_child" event', async () => {
      const contentRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentRequestBuilder.buildUser();

      const { responseBody: rootContentBody } = await contentRequestBuilder.post({
        title: 'Root Content',
        body: 'Corpo',
      });

      const { responseBody: content1 } = await contentRequestBuilder.post({
        body: 'Corpo',
        parent_id: rootContentBody.id,
        status: 'published',
      });

      const { responseBody: content2 } = await contentRequestBuilder.post({
        body: 'Corpo',
        parent_id: rootContentBody.id,
        status: 'published',
      });

      await contentRequestBuilder.post({
        body: 'Corpo',
        parent_id: rootContentBody.id,
        status: 'published',
      });

      const firewallEvent = await orchestrator.getLastEvent();

      const reviewFirewallRequestBuilder = new RequestBuilder(
        `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
      );
      const reviewerUser = await reviewFirewallRequestBuilder.buildUser({ with: ['read:firewall', 'review:firewall'] });

      await reviewFirewallRequestBuilder.post({ action: 'confirm' });

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'moderation:block_contents:text_child',
        originator_user_id: reviewerUser.id,
        originator_ip: '127.0.0.1',
        metadata: {
          related_events: [firewallEvent.id],
          contents: [content1.id, content2.id],
        },
        created_at: lastEvent.created_at,
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
    });

    test('Create "moderation:unblock_contents:text_child" event', async () => {
      const contentRequestBuilder = new RequestBuilder('/api/v1/contents');
      await contentRequestBuilder.buildUser();

      const { responseBody: rootContentBody } = await contentRequestBuilder.post({
        title: 'Root Content',
        body: 'Corpo',
      });

      const { responseBody: content1 } = await contentRequestBuilder.post({
        body: 'Corpo',
        parent_id: rootContentBody.id,
        status: 'published',
      });

      const { responseBody: content2 } = await contentRequestBuilder.post({
        body: 'Corpo',
        parent_id: rootContentBody.id,
        status: 'published',
      });

      await contentRequestBuilder.post({
        body: 'Corpo',
        parent_id: rootContentBody.id,
        status: 'published',
      });

      const firewallEvent = await orchestrator.getLastEvent();

      const reviewFirewallRequestBuilder = new RequestBuilder(
        `/api/v1/moderations/review_firewall/${firewallEvent.id}`,
      );
      const reviewerUser = await reviewFirewallRequestBuilder.buildUser({ with: ['read:firewall', 'review:firewall'] });

      await reviewFirewallRequestBuilder.post({ action: 'undo' });

      const lastEvent = await orchestrator.getLastEvent();

      expect(lastEvent).toStrictEqual({
        id: lastEvent.id,
        type: 'moderation:unblock_contents:text_child',
        originator_user_id: reviewerUser.id,
        originator_ip: '127.0.0.1',
        metadata: {
          related_events: [firewallEvent.id],
          contents: [content1.id, content2.id],
        },
        created_at: lastEvent.created_at,
      });

      expect(uuidVersion(lastEvent.id)).toBe(4);
      expect(Date.parse(lastEvent.created_at)).not.toBeNaN();
    });
  });
});
</file>

<file path="tests/unit/infra/email.test.js">
import nodemailer from 'nodemailer';

import logger from 'infra/logger';
import webserver from 'infra/webserver';

const mocks = vi.hoisted(() => ({
  resendSendMail: vi.fn(),
}));

vi.mock('resend', () => ({
  Resend: vi.fn().mockImplementation(() => ({
    emails: {
      send: mocks.resendSendMail,
    },
  })),
}));

vi.mock('nodemailer', () => ({
  default: {
    createTransport: vi.fn(),
  },
}));

vi.mock('infra/logger', () => ({
  default: {
    error: vi.fn(),
  },
}));

vi.mock('infra/webserver', () => ({
  default: {
    isServerlessRuntime: false,
  },
}));

describe('infra/email > send', () => {
  let send;
  let originalEnv;
  const sendMail = vi.fn();

  const defaultTestEnv = {
    EMAIL_SMTP_HOST: 'host.test',
    EMAIL_SMTP_PORT: 1025,
    EMAIL_USER: 'email_user_test',
    EMAIL_PASSWORD: 'email_password_test',
    RETRIES_PER_EMAIL_SERVICE: '1',
    EMAIL_ATTEMPT_TIMEOUT_IN_SECONDS: '40',
  };

  const defaultMailOptions = {
    auth: {
      user: defaultTestEnv.EMAIL_USER,
      pass: defaultTestEnv.EMAIL_PASSWORD,
    },
    secure: false,
    host: defaultTestEnv.EMAIL_SMTP_HOST,
    port: defaultTestEnv.EMAIL_SMTP_PORT,
  };

  const defaultEmailData = {
    from: 'test@example.com',
    to: 'recipient@example.com',
    subject: 'Test Email',
    html: '<p>Test HTML</p>',
    text: 'Test Text',
  };

  beforeAll(() => {
    originalEnv = process.env;
  });

  beforeEach(() => {
    vi.resetModules();
    vi.clearAllMocks();
    sendMail.mockResolvedValue();
    nodemailer.createTransport.mockReturnValue({ sendMail });
  });

  afterAll(() => {
    process.env = originalEnv;
  });

  describe('With single email service', () => {
    beforeEach(async () => {
      process.env = {
        ...originalEnv,
        ...defaultTestEnv,
      };

      send = await import('infra/email').then((module) => module.default.send);
    });

    it('should send an email with the provided options', async () => {
      await expect(send(defaultEmailData)).resolves.not.toThrow();

      expect(nodemailer.createTransport).toHaveBeenCalledTimes(1);
      expect(nodemailer.createTransport).toHaveBeenCalledWith(defaultMailOptions);
      expect(sendMail).toHaveBeenCalledWith(defaultEmailData);
    });

    it('should throw an error if sending the email fails all attempts', async () => {
      sendMail.mockRejectedValue(new Error('Failed to send email'));

      await expect(send(defaultEmailData)).rejects.toThrow('Failed to send email');

      expect(sendMail).toHaveBeenCalledTimes(2);
      expect(logger.error).toHaveBeenCalledTimes(2);
      expect(logger.error).toHaveBeenCalledWith(getExpectedError());
    });

    it('should retry if sending the email fails once', async () => {
      sendMail.mockRejectedValueOnce(new Error('Failed to send email'));

      await expect(send(defaultEmailData)).resolves.not.toThrow();

      expect(sendMail).toHaveBeenCalledTimes(2);
      expect(logger.error).toHaveBeenCalledTimes(1);
      expect(logger.error).toHaveBeenCalledWith(getExpectedError());
    });
  });

  describe('With two email services', () => {
    const secondEmailServiceEnv = {
      EMAIL_SMTP_HOST2: 'host.test2',
      EMAIL_SMTP_PORT2: 1026,
      EMAIL_USER2: 'email_user_test2',
      EMAIL_PASSWORD2: 'email_password_test2',
    };

    const secondMailOptions = {
      auth: {
        user: secondEmailServiceEnv.EMAIL_USER2,
        pass: secondEmailServiceEnv.EMAIL_PASSWORD2,
      },
      secure: true,
      host: secondEmailServiceEnv.EMAIL_SMTP_HOST2,
      port: secondEmailServiceEnv.EMAIL_SMTP_PORT2,
    };

    beforeAll(() => {
      webserver.isServerlessRuntime = true;
    });

    beforeEach(async () => {
      process.env = {
        ...originalEnv,
        ...defaultTestEnv,
        ...secondEmailServiceEnv,
      };

      send = await import('infra/email').then((module) => module.default.send);
    });

    afterAll(() => {
      webserver.isServerlessRuntime = false;
    });

    it('should send an email with the provided options', async () => {
      await expect(send(defaultEmailData)).resolves.not.toThrow();

      expect(nodemailer.createTransport).toHaveBeenCalledTimes(2);
      expect(nodemailer.createTransport).toHaveBeenCalledWith({ ...defaultMailOptions, secure: true });
      expect(nodemailer.createTransport).toHaveBeenCalledWith(secondMailOptions);
      expect(sendMail).toHaveBeenCalledWith(defaultEmailData);
    });

    it('should throw an error if sending the email fails all attempts', async () => {
      sendMail.mockRejectedValue(new Error('Failed to send email'));

      await expect(send(defaultEmailData)).rejects.toThrow('Failed to send email');
      expect(sendMail).toHaveBeenCalledTimes(4);
      expect(logger.error).toHaveBeenCalledTimes(4);
      expect(logger.error).toHaveBeenCalledWith(getExpectedError());
    });

    it('should retry with alternative email service', async () => {
      sendMail.mockRejectedValueOnce(new Error('Failed to send email'));
      await expect(send(defaultEmailData)).resolves.not.toThrow();

      expect(nodemailer.createTransport).toHaveBeenCalledTimes(2);
      expect(nodemailer.createTransport).toHaveBeenCalledWith({ ...defaultMailOptions, secure: true });
      expect(nodemailer.createTransport).toHaveBeenCalledWith(secondMailOptions);

      expect(sendMail).toHaveBeenCalledTimes(2);
      expect(logger.error).toHaveBeenCalledTimes(1);
      expect(logger.error).toHaveBeenCalledWith(getExpectedError());
    });
  });

  describe('With "Resend" service', () => {
    beforeEach(() => {
      mocks.resendSendMail.mockResolvedValue({
        data: 'Email sent',
        error: null,
      });
    });

    describe('Only "Resend" service', () => {
      const resendTestEnv = {
        EMAIL_USER: 'resend',
        EMAIL_PASSWORD: 're_password_test',
      };

      beforeEach(async () => {
        process.env = {
          ...originalEnv,
          ...defaultTestEnv,
          ...resendTestEnv,
        };

        send = await import('infra/email').then((module) => module.default.send);
      });

      it('should not initialize as a transporter', () => {
        expect(nodemailer.createTransport).not.toHaveBeenCalled();
      });

      it('should send an email with the provided options', async () => {
        await expect(send(defaultEmailData)).resolves.not.toThrow();

        expect(mocks.resendSendMail).toHaveBeenCalledWith(defaultEmailData);
      });

      it('should throw an error if sending the email fails all attempts', async () => {
        mocks.resendSendMail.mockRejectedValue(new Error('Failed to send email'));

        await expect(send(defaultEmailData)).rejects.toThrow('Failed to send email');

        expect(mocks.resendSendMail).toHaveBeenCalledTimes(2);
        expect(logger.error).toHaveBeenCalledTimes(2);
        expect(logger.error).toHaveBeenCalledWith(getExpectedError());
      });

      it('should retry if sending the email fails once', async () => {
        mocks.resendSendMail.mockRejectedValueOnce(new Error('Failed to send email'));

        await expect(send(defaultEmailData)).resolves.not.toThrow();

        expect(mocks.resendSendMail).toHaveBeenCalledTimes(2);
        expect(logger.error).toHaveBeenCalledTimes(1);
        expect(logger.error).toHaveBeenCalledWith(getExpectedError());
      });
    });

    describe('With "Resend" and two other services', () => {
      const resendTestEnv = {
        EMAIL_USER2: 'resend',
        EMAIL_PASSWORD2: 're_password_test',
      };

      const thirdEmailServiceEnv = {
        EMAIL_SMTP_HOST3: 'host.test3',
        EMAIL_SMTP_PORT3: 1026,
        EMAIL_USER3: 'email_user_test3',
        EMAIL_PASSWORD3: 'email_password_test3',
      };

      const thirdMailOptions = {
        auth: {
          user: thirdEmailServiceEnv.EMAIL_USER3,
          pass: thirdEmailServiceEnv.EMAIL_PASSWORD3,
        },
        secure: false,
        host: thirdEmailServiceEnv.EMAIL_SMTP_HOST3,
        port: thirdEmailServiceEnv.EMAIL_SMTP_PORT3,
      };

      beforeEach(async () => {
        process.env = {
          ...originalEnv,
          ...defaultTestEnv,
          ...resendTestEnv,
          ...thirdEmailServiceEnv,
        };

        send = await import('infra/email').then((module) => module.default.send);
      });

      it('should initialize the transporters', () => {
        // Resend service is not initialized as a transporter
        expect(nodemailer.createTransport).toHaveBeenCalledTimes(2);
        expect(nodemailer.createTransport).toHaveBeenCalledWith(defaultMailOptions);
        expect(nodemailer.createTransport).toHaveBeenCalledWith(thirdMailOptions);
      });

      it('should send an email with the provided options', async () => {
        await expect(send(defaultEmailData)).resolves.not.toThrow();

        expect(sendMail).toHaveBeenCalledWith(defaultEmailData);
        expect(mocks.resendSendMail).not.toHaveBeenCalled();
      });

      it('should throw an error if sending the email fails all attempts', async () => {
        sendMail.mockRejectedValue(new Error('Failed to send email'));
        mocks.resendSendMail.mockRejectedValue(new Error('Failed to send email'));

        await expect(send(defaultEmailData)).rejects.toThrow('Failed to send email');

        expect(sendMail).toHaveBeenCalledTimes(4);
        expect(mocks.resendSendMail).toHaveBeenCalledTimes(2);
        expect(logger.error).toHaveBeenCalledTimes(6);
        expect(logger.error).toHaveBeenCalledWith(getExpectedError());
      });

      it('should retry with "Resend" service', async () => {
        sendMail.mockRejectedValueOnce(new Error('Failed to send email'));

        await expect(send(defaultEmailData)).resolves.not.toThrow();

        expect(sendMail).toHaveBeenCalledOnce();
        expect(mocks.resendSendMail).toHaveBeenCalledOnce();
        expect(logger.error).toHaveBeenCalledTimes(1);
        expect(logger.error).toHaveBeenCalledWith(getExpectedError());
      });

      it('should retry after "Resend" attempt', async () => {
        sendMail.mockRejectedValueOnce(new Error('Failed to send email'));
        mocks.resendSendMail.mockRejectedValueOnce(new Error('Failed to send email'));

        await expect(send(defaultEmailData)).resolves.not.toThrow();

        expect(sendMail).toHaveBeenCalledTimes(2);
        expect(mocks.resendSendMail).toHaveBeenCalledOnce();
        expect(logger.error).toHaveBeenCalledTimes(2);
        expect(logger.error).toHaveBeenCalledWith(getExpectedError());
      });
    });
  });

  describe('Custom retry options', () => {
    beforeEach(async () => {
      process.env = {
        ...originalEnv,
        ...defaultTestEnv,
        EMAIL_ATTEMPT_TIMEOUT_IN_SECONDS: '1',
        RETRIES_PER_EMAIL_SERVICE: '2',
      };

      send = await import('infra/email').then((module) => module.default.send);
    });

    it('should retry with custom `RETRIES_PER_EMAIL_SERVICE`', async () => {
      sendMail.mockRejectedValue(new Error('Failed to send email'));

      await expect(send(defaultEmailData)).rejects.toThrow('Failed to send email');

      expect(sendMail).toHaveBeenCalledTimes(3);
      expect(logger.error).toHaveBeenCalledTimes(3);
      expect(logger.error).toHaveBeenCalledWith(getExpectedError());
    });

    it('should retry after timeout (`EMAIL_ATTEMPT_TIMEOUT_IN_SECONDS`)', async () => {
      sendMail.mockImplementationOnce(
        () => new Promise((resolve) => setTimeout(() => resolve(new Error('Failed to send email')), 1100)),
      );

      await expect(send(defaultEmailData)).resolves.not.toThrow();

      expect(sendMail).toHaveBeenCalledTimes(2);
      expect(logger.error).toHaveBeenCalledTimes(1);
      expect(logger.error).toHaveBeenCalledWith(
        getExpectedError({ message: 'Timeout: Email sending took longer than 1 second(s)' }),
      );
    });
  });
});

function getExpectedError(props) {
  return expect.objectContaining({
    name: 'ServiceError',
    message: 'Failed to send email',
    ...props,
  });
}
</file>

<file path="tests/unit/infra/under-maintenance.test.js">
const defaultMessage = 'Funcionalidade em manutenção.';
const defaultAction = 'Tente novamente mais tarde.';
const defaultStatusCode = 503;
const errorLocationCode = 'INFRA:UNDER_MAINTENANCE:CHECK:IS_UNDER_MAINTENANCE';

let originalUnderMaintenanceProcessEnv;

beforeAll(() => {
  originalUnderMaintenanceProcessEnv = process.env.UNDER_MAINTENANCE;
});

beforeEach(() => {
  vi.resetModules();
});

afterAll(() => {
  process.env.UNDER_MAINTENANCE = originalUnderMaintenanceProcessEnv;
});

describe('infra/under-maintenance', () => {
  describe('check', () => {
    let check;

    beforeEach(async () => {
      check = await import('infra/under-maintenance').then((module) => module.default.check);
    });

    describe('when "process.env.UNDER_MAINTENANCE" is falsy', () => {
      beforeAll(() => {
        process.env.UNDER_MAINTENANCE = '';
      });

      it('should return undefined', () => {
        const request = { method: 'GET', nextUrl: { pathname: '/home' } };

        const result = check(request);

        expect(result).toBeUndefined();
      });
    });

    describe('when "process.env.UNDER_MAINTENANCE" is invalid', () => {
      beforeAll(() => {
        process.env.UNDER_MAINTENANCE = 'Invalid JSON';
      });

      it('should return undefined', () => {
        const request = { method: 'GET', nextUrl: { pathname: '/home' } };

        const result = check(request);

        expect(result).toBeUndefined();
      });
    });

    describe('when "methodsAndPaths" is []', () => {
      beforeAll(() => {
        process.env.UNDER_MAINTENANCE = '{"methodsAndPaths":[]}';
      });

      it('should return undefined', () => {
        const request = { method: 'POST', nextUrl: { pathname: '/admin' } };

        const result = check(request);

        expect(result).toBeUndefined();
      });
    });

    describe('when methodsAndPaths is defined', () => {
      beforeAll(() => {
        process.env.UNDER_MAINTENANCE = '{"methodsAndPaths":["POST /admin"]}';
      });

      it('should return the response when the request matches the maintenance conditions', () => {
        const request = { method: 'POST', nextUrl: { pathname: '/admin/home' } };

        const result = check(request);

        expect(result).toStrictEqual({
          status: defaultStatusCode,
          body: JSON.stringify({
            message: defaultMessage,
            action: defaultAction,
            error_location_code: errorLocationCode,
          }),
        });
      });

      it('should return undefined if the "path" does not match the maintenance conditions', () => {
        const request = { method: 'POST', nextUrl: { pathname: '/home' } };

        const result = check(request);

        expect(result).toBeUndefined();
      });

      it('should return undefined if the "method" does not match the maintenance conditions', () => {
        const request = { method: 'GET', nextUrl: { pathname: '/admin' } };

        const result = check(request);

        expect(result).toBeUndefined();
      });

      describe('when "message" is defined', () => {
        beforeAll(() => {
          process.env.UNDER_MAINTENANCE = '{"methodsAndPaths":["GET /home$"],"message":"Custom message"}';
        });

        it('should return the custom message', () => {
          const request = { method: 'GET', nextUrl: { pathname: '/home' } };

          const result = check(request);

          expect(result).toStrictEqual({
            status: defaultStatusCode,
            body: JSON.stringify({
              message: 'Custom message',
              action: defaultAction,
              error_location_code: errorLocationCode,
            }),
          });
        });
      });

      describe('when "action" is defined', () => {
        beforeAll(() => {
          process.env.UNDER_MAINTENANCE = '{"methodsAndPaths":["GET /home.*"],"action":"Custom action"}';
        });

        it('should return the custom action', () => {
          const request = { method: 'GET', nextUrl: { pathname: '/home' } };

          const result = check(request);

          expect(result).toStrictEqual({
            status: defaultStatusCode,
            body: JSON.stringify({
              message: defaultMessage,
              action: 'Custom action',
              error_location_code: errorLocationCode,
            }),
          });
        });
      });

      describe('when "statusCode" is defined', () => {
        beforeAll(() => {
          process.env.UNDER_MAINTENANCE = '{"methodsAndPaths":["GET /h.m.$"],"statusCode":200}';
        });

        it('should return the custom status code', () => {
          const request = { method: 'GET', nextUrl: { pathname: '/home' } };

          const result = check(request);

          expect(result).toStrictEqual({
            status: 200,
            body: JSON.stringify({
              message: defaultMessage,
              action: defaultAction,
              error_location_code: errorLocationCode,
            }),
          });
        });
      });
    });
  });
});
</file>

<file path="tests/unit/interface/components/Pagination/index.test.js">
import { render } from '@testing-library/react';

import Pagination from 'pages/interface/components/Pagination';

describe('Pagination', () => {
  it('should not render links if there is no previous or next page', () => {
    const { getByText } = render(<Pagination basePath="/pagina" />);
    expect(getByText('Anterior')).not.toHaveProperty('href');
    expect(getByText('Próximo')).not.toHaveProperty('href');
  });

  it('should not render a link to previous page if there is no previous page', () => {
    const { getByText } = render(<Pagination basePath="/pagina" nextPage="2" />);
    expect(getByText('Anterior')).not.toHaveProperty('href');
    expect(getByText('Próximo')).toHaveProperty('href', 'http://localhost:3000/pagina/2');
  });

  it('should not render a link to next page if there is no next page', () => {
    const { getByText } = render(<Pagination basePath="/conteudos" previousPage="7" />);
    expect(getByText('Anterior')).toHaveProperty('href', 'http://localhost:3000/conteudos/7');
    expect(getByText('Próximo')).not.toHaveProperty('href');
  });

  it('should render a link to previous and next pages', () => {
    const { getByText } = render(<Pagination basePath="/recentes/comentarios" previousPage="1" nextPage="3" />);
    expect(getByText('Anterior')).toHaveProperty('href', 'http://localhost:3000/recentes/comentarios/1');
    expect(getByText('Próximo')).toHaveProperty('href', 'http://localhost:3000/recentes/comentarios/3');
  });
});
</file>

<file path="tests/unit/interface/utils/error-message.test.js">
import { createErrorMessage } from 'pages/interface';

describe('createErrorMessage', () => {
  it('should return default error message when responseBody is null', () => {
    const responseBody = null;
    const errorMessage = createErrorMessage(responseBody);
    expect(errorMessage).toBe('Erro desconhecido. Tente novamente mais tarde.');
  });

  it('should return default error message when responseBody is undefined', () => {
    const responseBody = undefined;
    const errorMessage = createErrorMessage(responseBody);
    expect(errorMessage).toBe('Erro desconhecido. Tente novamente mais tarde.');
  });

  it('should return error message', () => {
    const responseBody = {
      message: 'Entrada inválida.',
    };
    const errorMessage = createErrorMessage(responseBody);
    expect(errorMessage).toBe('Entrada inválida.');
  });

  it('should return error message with action', () => {
    const responseBody = {
      action: 'Tente novamente.',
    };
    const errorMessage = createErrorMessage(responseBody);
    expect(errorMessage).toBe('Tente novamente.');
  });

  it('should return error message with error_id', () => {
    const responseBody = {
      error_id: '123456789',
    };
    const errorMessage = createErrorMessage(responseBody);
    expect(errorMessage).toBe('Informe ao suporte o valor (123456789)');
  });

  it('should return error message with message and action', () => {
    const responseBody = {
      message: 'Entrada inválida.',
      action: 'Tente novamente.',
    };
    const errorMessage = createErrorMessage(responseBody);
    expect(errorMessage).toBe('Entrada inválida. Tente novamente.');
  });

  it('should return error message without error_id when omitErrorId is true', () => {
    const responseBody = {
      message: 'Entrada inválida.',
      action: 'Tente novamente.',
      error_id: '123456789',
    };
    const errorMessage = createErrorMessage(responseBody, { omitErrorId: true });
    expect(errorMessage).toBe('Entrada inválida. Tente novamente.');
  });

  it('should return error message with message, action, and error_id', () => {
    const responseBody = {
      message: 'Entrada inválida.',
      action: 'Tente novamente.',
      error_id: '123456789',
    };
    const errorMessage = createErrorMessage(responseBody);
    expect(errorMessage).toBe('Entrada inválida. Tente novamente. Informe ao suporte o valor (123456789)');
  });

  it('should return error message without action when action is a specific string', () => {
    const responseBody = {
      message: 'Um erro interno não esperado aconteceu.',
      action: "Informe ao suporte o valor encontrado no campo 'error_id'.",
      error_id: '123456789',
    };
    const errorMessage = createErrorMessage(responseBody);
    expect(errorMessage).toBe('Um erro interno não esperado aconteceu. Informe ao suporte o valor (123456789)');
  });
});
</file>

<file path="tests/unit/models/transactional/__snapshots__/index.test.js.snap">
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Transactional model > Email layouts > Activation 1`] = `"<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html dir="ltr" lang="en"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><meta name="x-apple-disable-message-reformatting"/></head><div style="display:none;overflow:hidden;line-height:1px;opacity:0;max-height:0;max-width:0">Ative seu cadastro no TabNews<div> ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿</div></div><body style="background-color:#ffffff;font-family:-apple-system, BlinkMacSystemFont, &#x27;Segoe UI&#x27;, &#x27;Roboto&#x27;, &#x27;Oxygen&#x27;, &#x27;Ubuntu&#x27;, &#x27;Cantarell&#x27;, &#x27;Fira Sans&#x27;, &#x27;Droid Sans&#x27;, &#x27;Helvetica Neue&#x27;, sans-serif"><table align="center" width="100%" border="0" cellPadding="0" cellSpacing="0" role="presentation" style="max-width:37.5em;padding-left:12px;padding-right:12px;margin:0 auto"><tbody><tr style="width:100%"><td><h1 style="color:#333;font-size:24px;font-weight:bold;margin:40px 0;padding:0">Olá, User Test!</h1><a href="https://tabnews.com.br/cadastro/ativar/TOKEN_ID" style="color:#2754C5;text-decoration:underline;font-size:14px;display:block" target="_blank">Clique aqui para ativar seu cadastro no TabNews.</a><div><p style="font-size:14px;line-height:24px;margin:24px 0;color:#333">Se você não conseguir clicar no link, copie e cole o endereço abaixo no seu navegador:</p><code style="background-color:#f3f3f3;color:#333;display:block;font-size:14px;padding:12px;border-radius:8px;word-break:break-all">https://tabnews.com.br/cadastro/ativar/TOKEN_ID</code></div><p style="font-size:14px;line-height:24px;margin:24px 0;color:#333">Caso você não tenha feito esta requisição, ignore esse email.</p><p style="font-size:12px;line-height:22px;margin:16px 0;color:#898989;margin-top:24px;margin-bottom:4px">Atenciosamente, <br/>Equipe TabNews <br/>Rua Antônio da Veiga, 495, Blumenau, SC, 89012-500</p><img alt="TabNews" height="32" src="https://www.tabnews.com.br/favicon.png" style="display:block;outline:none;border:none;text-decoration:none" width="32"/></td></tr></tbody></table></body></html>"`;

exports[`Transactional model > Email layouts > Activation 2`] = `
"Olá, User Test!

Clique no link abaixo para ativar seu cadastro no TabNews:

https://tabnews.com.br/cadastro/ativar/TOKEN_ID

Caso você não tenha feito esta requisição, ignore esse email.

Atenciosamente, 
Equipe TabNews 
Rua Antônio da Veiga, 495, Blumenau, SC, 89012-500"
`;

exports[`Transactional model > Email layouts > Confirmation 1`] = `"<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html dir="ltr" lang="en"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><meta name="x-apple-disable-message-reformatting"/></head><div style="display:none;overflow:hidden;line-height:1px;opacity:0;max-height:0;max-width:0">Alteração de email no TabNews<div> ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿</div></div><body style="background-color:#ffffff;font-family:-apple-system, BlinkMacSystemFont, &#x27;Segoe UI&#x27;, &#x27;Roboto&#x27;, &#x27;Oxygen&#x27;, &#x27;Ubuntu&#x27;, &#x27;Cantarell&#x27;, &#x27;Fira Sans&#x27;, &#x27;Droid Sans&#x27;, &#x27;Helvetica Neue&#x27;, sans-serif"><table align="center" width="100%" border="0" cellPadding="0" cellSpacing="0" role="presentation" style="max-width:37.5em;padding-left:12px;padding-right:12px;margin:0 auto"><tbody><tr style="width:100%"><td><h1 style="color:#333;font-size:24px;font-weight:bold;margin:40px 0;padding:0">Olá, User Test!</h1><p style="font-size:14px;line-height:24px;margin:24px 0;color:#333">Uma alteração de email foi solicitada.</p><a href="https://tabnews.com.br/perfil/confirmar-email/TOKEN_ID" style="color:#2754C5;text-decoration:underline;font-size:14px;display:block" target="_blank">Clique aqui para confirmar esta alteração.</a><div><p style="font-size:14px;line-height:24px;margin:24px 0;color:#333">Se você não conseguir clicar no link, copie e cole o endereço abaixo no seu navegador:</p><code style="background-color:#f3f3f3;color:#333;display:block;font-size:14px;padding:12px;border-radius:8px;word-break:break-all">https://tabnews.com.br/perfil/confirmar-email/TOKEN_ID</code></div><p style="font-size:14px;line-height:24px;margin:24px 0;color:#333">Caso você não tenha feito esta requisição, ignore esse email.</p><p style="font-size:12px;line-height:22px;margin:16px 0;color:#898989;margin-top:24px;margin-bottom:4px">Atenciosamente, <br/>Equipe TabNews <br/>Rua Antônio da Veiga, 495, Blumenau, SC, 89012-500</p><img alt="TabNews" height="32" src="https://www.tabnews.com.br/favicon.png" style="display:block;outline:none;border:none;text-decoration:none" width="32"/></td></tr></tbody></table></body></html>"`;

exports[`Transactional model > Email layouts > Confirmation 2`] = `
"Olá, User Test!

Uma alteração de email foi solicitada.

Clique no link abaixo para confirmar esta alteração:

https://tabnews.com.br/perfil/confirmar-email/TOKEN_ID
  
Caso você não tenha feito esta requisição, ignore esse email.

Atenciosamente, 
Equipe TabNews 
Rua Antônio da Veiga, 495, Blumenau, SC, 89012-500"
`;

exports[`Transactional model > Email layouts > Firewall 1`] = `"<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html dir="ltr" lang="en"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><meta name="x-apple-disable-message-reformatting"/></head><div style="display:none;overflow:hidden;line-height:1px;opacity:0;max-height:0;max-width:0">Atividade suspeita detectada no TabNews<div> ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿</div></div><body style="background-color:#ffffff;font-family:-apple-system, BlinkMacSystemFont, &#x27;Segoe UI&#x27;, &#x27;Roboto&#x27;, &#x27;Oxygen&#x27;, &#x27;Ubuntu&#x27;, &#x27;Cantarell&#x27;, &#x27;Fira Sans&#x27;, &#x27;Droid Sans&#x27;, &#x27;Helvetica Neue&#x27;, sans-serif"><table align="center" width="100%" border="0" cellPadding="0" cellSpacing="0" role="presentation" style="max-width:37.5em;padding-left:12px;padding-right:12px;margin:0 auto"><tbody><tr style="width:100%"><td><h1 style="color:#333;font-size:24px;font-weight:bold;margin:40px 0;padding:0">Olá, User!</h1><p style="font-size:14px;line-height:24px;margin:24px 0;color:#333">Identificamos a criação de muitas publicações em um curto período, então a sua publicação &quot;Título da publicação&quot; foi removida.</p><p style="font-size:14px;line-height:24px;margin:24px 0;color:#333">Caso acredite que isso seja um erro, responda este e-mail para que possamos avaliar a situação.</p><p style="font-size:14px;line-height:24px;margin:16px 0;color:#333">Identificador do evento:</p><code style="background-color:#f3f3f3;color:#333;display:block;font-size:14px;padding:12px;border-radius:8px;word-break:break-all">c7854f84-f7b4-468c-9805-a96d7ac4853a</code><p style="font-size:12px;line-height:22px;margin:16px 0;color:#898989;margin-top:24px;margin-bottom:4px">Atenciosamente, <br/>Equipe TabNews <br/>Rua Antônio da Veiga, 495, Blumenau, SC, 89012-500</p><img alt="TabNews" height="32" src="https://www.tabnews.com.br/favicon.png" style="display:block;outline:none;border:none;text-decoration:none" width="32"/></td></tr></tbody></table></body></html>"`;

exports[`Transactional model > Email layouts > Firewall 2`] = `
"Olá, User!

Identificamos a criação de muitas publicações em um curto período, então a sua publicação "Título da publicação" foi removida. Caso acredite que isso seja um erro, responda este e-mail para que possamos avaliar a situação.

Identificador do evento: c7854f84-f7b4-468c-9805-a96d7ac4853a

Atenciosamente, 
Equipe TabNews 
Rua Antônio da Veiga, 495, Blumenau, SC, 89012-500"
`;

exports[`Transactional model > Email layouts > Notification 1`] = `"<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html dir="ltr" lang="en"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><meta name="x-apple-disable-message-reformatting"/></head><div style="display:none;overflow:hidden;line-height:1px;opacity:0;max-height:0;max-width:0">Nova resposta no TabNews<div> ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿</div></div><body style="background-color:#ffffff;font-family:-apple-system, BlinkMacSystemFont, &#x27;Segoe UI&#x27;, &#x27;Roboto&#x27;, &#x27;Oxygen&#x27;, &#x27;Ubuntu&#x27;, &#x27;Cantarell&#x27;, &#x27;Fira Sans&#x27;, &#x27;Droid Sans&#x27;, &#x27;Helvetica Neue&#x27;, sans-serif"><table align="center" width="100%" border="0" cellPadding="0" cellSpacing="0" role="presentation" style="max-width:37.5em;padding-left:12px;padding-right:12px;margin:0 auto"><tbody><tr style="width:100%"><td><h1 style="color:#333;font-size:24px;font-weight:bold;margin:40px 0;padding:0">Olá, User Test!</h1><p style="font-size:14px;line-height:24px;margin:24px 0;color:#333">&quot;User2&quot; respondeu à sua publicação &quot;Título publicação&quot;.</p><a href="https://tabnews.com.br/user2/titulo-publicacao" style="color:#2754C5;text-decoration:underline;font-size:14px;display:block" target="_blank">Clique aqui para ler a resposta.</a><div><p style="font-size:14px;line-height:24px;margin:24px 0;color:#333">Se você não conseguir clicar no link, copie e cole o endereço abaixo no seu navegador:</p><code style="background-color:#f3f3f3;color:#333;display:block;font-size:14px;padding:12px;border-radius:8px;word-break:break-all">https://tabnews.com.br/user2/titulo-publicacao</code></div><p style="font-size:12px;line-height:22px;margin:16px 0;color:#898989;margin-top:24px;margin-bottom:4px">Atenciosamente, <br/>Equipe TabNews <br/>Rua Antônio da Veiga, 495, Blumenau, SC, 89012-500</p><img alt="TabNews" height="32" src="https://www.tabnews.com.br/favicon.png" style="display:block;outline:none;border:none;text-decoration:none" width="32"/></td></tr></tbody></table></body></html>"`;

exports[`Transactional model > Email layouts > Notification 2`] = `
"Olá, User Test!

"User2" respondeu à sua publicação "Título publicação". Para ler a resposta, utilize o link abaixo:

https://tabnews.com.br/user2/titulo-publicacao

Atenciosamente, 
Equipe TabNews 
Rua Antônio da Veiga, 495, Blumenau, SC, 89012-500"
`;

exports[`Transactional model > Email layouts > Recovery 1`] = `"<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html dir="ltr" lang="en"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><meta name="x-apple-disable-message-reformatting"/></head><div style="display:none;overflow:hidden;line-height:1px;opacity:0;max-height:0;max-width:0">Recuperação de senha no TabNews<div> ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿ ‌​‍‎‏﻿</div></div><body style="background-color:#ffffff;font-family:-apple-system, BlinkMacSystemFont, &#x27;Segoe UI&#x27;, &#x27;Roboto&#x27;, &#x27;Oxygen&#x27;, &#x27;Ubuntu&#x27;, &#x27;Cantarell&#x27;, &#x27;Fira Sans&#x27;, &#x27;Droid Sans&#x27;, &#x27;Helvetica Neue&#x27;, sans-serif"><table align="center" width="100%" border="0" cellPadding="0" cellSpacing="0" role="presentation" style="max-width:37.5em;padding-left:12px;padding-right:12px;margin:0 auto"><tbody><tr style="width:100%"><td><h1 style="color:#333;font-size:24px;font-weight:bold;margin:40px 0;padding:0">Olá, User Test!</h1><p style="font-size:14px;line-height:24px;margin:24px 0;color:#333">Uma recuperação de senha foi solicitada.</p><a href="https://tabnews.com.br/perfil/confirmar-email/TOKEN_ID" style="color:#2754C5;text-decoration:underline;font-size:14px;display:block" target="_blank">Clique aqui para definir uma nova senha.</a><div><p style="font-size:14px;line-height:24px;margin:24px 0;color:#333">Se você não conseguir clicar no link, copie e cole o endereço abaixo no seu navegador:</p><code style="background-color:#f3f3f3;color:#333;display:block;font-size:14px;padding:12px;border-radius:8px;word-break:break-all">https://tabnews.com.br/perfil/confirmar-email/TOKEN_ID</code></div><p style="font-size:14px;line-height:24px;margin:24px 0;color:#333">Caso você não tenha feito esta requisição, ignore esse email.</p><p style="font-size:12px;line-height:22px;margin:16px 0;color:#898989;margin-top:24px;margin-bottom:4px">Atenciosamente, <br/>Equipe TabNews <br/>Rua Antônio da Veiga, 495, Blumenau, SC, 89012-500</p><img alt="TabNews" height="32" src="https://www.tabnews.com.br/favicon.png" style="display:block;outline:none;border:none;text-decoration:none" width="32"/></td></tr></tbody></table></body></html>"`;

exports[`Transactional model > Email layouts > Recovery 2`] = `
"Olá, User Test!

Uma recuperação de senha foi solicitada. Caso você não tenha feito a solicitação, ignore esse email.

Caso você tenha feito essa solicitação, clique no link abaixo para definir uma nova senha:

https://tabnews.com.br/perfil/confirmar-email/TOKEN_ID

Atenciosamente, 
Equipe TabNews 
Rua Antônio da Veiga, 495, Blumenau, SC, 89012-500"
`;
</file>

<file path="tests/unit/models/transactional/index.test.js">
import {
  ActivationEmail,
  ConfirmationEmail,
  FirewallEmail,
  NotificationEmail,
  RecoveryEmail,
} from 'models/transactional';

describe('Transactional model', () => {
  describe('Email layouts', () => {
    it('Activation', () => {
      const username = 'User Test';
      const activationLink = 'https://tabnews.com.br/cadastro/ativar/TOKEN_ID';

      const { html, text } = ActivationEmail({ username, activationLink });

      expect(html).toMatchSnapshot();
      expect(text).toMatchSnapshot();
    });

    it('Confirmation', () => {
      const username = 'User Test';
      const confirmationLink = 'https://tabnews.com.br/perfil/confirmar-email/TOKEN_ID';

      const { html, text } = ConfirmationEmail({ username, confirmationLink });

      expect(html).toMatchSnapshot();
      expect(text).toMatchSnapshot();
    });

    it('Firewall', () => {
      const { html, text } = FirewallEmail({
        username: 'User',
        sideEffectLine:
          'Identificamos a criação de muitas publicações em um curto período, então a sua publicação "Título da publicação" foi removida.',
        eventId: 'c7854f84-f7b4-468c-9805-a96d7ac4853a',
      });

      expect(html).toMatchSnapshot();
      expect(text).toMatchSnapshot();
    });

    it('Notification', () => {
      const username = 'User Test';
      const bodyReplyLine = '"User2" respondeu à sua publicação "Título publicação".';
      const contentLink = 'https://tabnews.com.br/user2/titulo-publicacao';

      const { html, text } = NotificationEmail({ username, bodyReplyLine, contentLink });

      expect(html).toMatchSnapshot();
      expect(text).toMatchSnapshot();
    });

    it('Recovery', () => {
      const username = 'User Test';
      const recoveryLink = 'https://tabnews.com.br/perfil/confirmar-email/TOKEN_ID';

      const { html, text } = RecoveryEmail({ username, recoveryLink });

      expect(html).toMatchSnapshot();
      expect(text).toMatchSnapshot();
    });
  });
});
</file>

<file path="tests/unit/models/controller.test.js">
import logger from 'infra/logger.js';
import controller from 'models/controller.js';

const { logRequest } = controller;

vi.mock('infra/logger.js');

describe('Controller', () => {
  describe('logRequest', () => {
    const next = vi.fn();
    const response = {
      on: vi.fn(),
    };

    beforeEach(() => {
      logger.info.mockClear();
      next.mockClear();
    });

    it('should log request information', () => {
      const request = {
        headers: {
          'x-forwarded-for': 'test',
          'user-agent': 'test',
        },
        body: {
          body: 'test',
        },
        context: {
          test: 'test',
        },
      };

      logRequest(request, response, next);

      expect(logger.info).toHaveBeenCalledWith({
        headers: [request.headers],
        body: [request.body],
        context: request.context,
      });
      expect(next).toHaveBeenCalled();
    });

    it('should call logger.info only with headers and body in array format', () => {
      logRequest({}, response, next);

      expect(logger.info).toHaveBeenCalledWith({
        headers: [{}],
        body: [{}],
        context: {},
      });
      expect(next).toHaveBeenCalled();
    });

    it('should not log extra request params', () => {
      const request = {
        other: {
          'x-forwarded-for': 'test',
          'user-agent': 'test',
        },
      };

      logRequest(request, response, next);

      expect(logger.info).toHaveBeenCalledWith({
        headers: [{}],
        body: [{}],
        context: {},
      });
      expect(next).toHaveBeenCalled();
    });

    it('should truncate long "requestBody.body"', () => {
      const request = {
        headers: {
          'x-forwarded-for': 'test',
          'user-agent': 'test',
        },
        body: {
          body: 'test'.repeat(1000),
        },
        context: {
          test: 'test',
        },
      };

      logRequest(request, response, next);

      expect(logger.info).toHaveBeenCalledWith({
        headers: [request.headers],
        body: [{ body: 'test'.repeat(74) + 't...' }],
        context: request.context,
      });
      expect(next).toHaveBeenCalled();
    });

    it('should redact sensitive data', () => {
      const request = {
        headers: {
          authorization: 'sensitive',
          cookie: 'sensitive',
          'access-control-allow-headers': 'omit',
          forwarded: 'omit',
          'x-vercel-proxy-signature': 'omit',
          'x-vercel-sc-headers': 'omit',
          'other-header': 'test',
        },
        body: {
          body: 'test',
          email: 'test@email.com',
          password: 'password',
        },
        context: {
          test: 'test',
        },
      };

      logRequest(request, response, next);

      expect(logger.info).toHaveBeenCalledWith({
        headers: [
          {
            authorization: '**',
            cookie: '**',
            'other-header': 'test',
          },
        ],
        body: [{ body: 'test', email: '**', password: '**' }],
        context: request.context,
      });
      expect(next).toHaveBeenCalled();
    });

    it('should redact sensitive data with long "body"', () => {
      const request = {
        headers: {
          authorization: 'sensitive',
          cookie: 'sensitive',
          'other-header': 'test',
        },
        body: {
          body: 'test'.repeat(1000),
          email: 'test',
          password: 'test',
        },
        context: {
          test: 'test',
        },
      };

      logRequest(request, response, next);

      expect(logger.info).toHaveBeenCalledWith({
        headers: [
          {
            authorization: '**',
            cookie: '**',
            'other-header': 'test',
          },
        ],
        body: [{ body: 'test'.repeat(74) + 't...', email: '**', password: '**' }],
        context: request.context,
      });
      expect(next).toHaveBeenCalled();
    });

    it('should log only "id" and "username" among the user data', () => {
      const request = {
        context: {
          user: {
            id: 'test_id',
            username: 'username',
            description: 'description',
          },
        },
      };

      logRequest(request, response, next);

      expect(logger.info).toHaveBeenCalledWith({
        headers: [{}],
        body: [{}],
        context: {
          user: {
            id: request.context.user.id,
            username: request.context.user.username,
          },
        },
      });
      expect(next).toHaveBeenCalled();
    });

    it('should log non string "requestBody.body"', () => {
      const request = {
        headers: {
          'x-forwarded-for': 'test',
          'user-agent': 'test',
        },
        body: {
          body: { test: 'test' },
        },
        context: {
          test: 'test',
        },
      };

      logRequest(request, response, next);

      expect(logger.info).toHaveBeenCalledWith({
        headers: [request.headers],
        body: [request.body],
        context: request.context,
      });
      expect(next).toHaveBeenCalled();
    });
  });
});
</file>

<file path="tests/unit/models/prestige.test.js">
import { randomUUID as uuidV4 } from 'node:crypto';

import prestige from 'models/prestige';

describe('prestige model', () => {
  describe('getByContentId', () => {
    it('should call database.query', async () => {
      const contentId = 'content_id';
      const transaction = null;
      const database = {
        query: vi.fn().mockResolvedValue({ rows: [] }),
      };

      await prestige.getByContentId(contentId, { transaction, database });

      expect(database.query).toHaveBeenCalledWith(
        {
          text: expect.any(String),
          values: [contentId],
        },
        { transaction },
      );
    });

    it('should return 0 and 0 for a content ID not found', async () => {
      const database = {
        query: vi.fn().mockResolvedValue({ rows: [] }),
      };

      const result = await prestige.getByContentId('content_id', { database });

      expect(result.initialTabcoins).toBe(0);
      expect(result.totalTabcoins).toBe(0);
    });

    it('should return the initial and total tabcoins for a "root" content', async () => {
      const database = {
        query: vi.fn().mockResolvedValue({
          rows: [
            { type: 'create:content:text_root', amount: 2 },
            { type: 'other_type', amount: 1 },
            { type: 'other_type', amount: 1 },
            { type: 'other_type', amount: -1 },
          ],
        }),
      };

      const result = await prestige.getByContentId('content_id', { database });

      expect(result.initialTabcoins).toBe(2);
      expect(result.totalTabcoins).toBe(3);
    });

    it('should return the initial and total tabcoins for a "child" content', async () => {
      const database = {
        query: vi.fn().mockResolvedValue({
          rows: [
            { type: 'create:content:text_child', amount: 3 },
            { type: 'other_type', amount: -1 },
            { type: 'other_type', amount: 1 },
            { type: 'other_type', amount: 1 },
            { type: 'other_type', amount: 1 },
          ],
        }),
      };

      const result = await prestige.getByContentId('content_id', { database });

      expect(result.initialTabcoins).toBe(3);
      expect(result.totalTabcoins).toBe(5);
    });

    it('should return initial equal to 0 if there is no initial tabcoin', async () => {
      const database = {
        query: vi.fn().mockResolvedValue({
          rows: [
            { type: 'other_type', amount: 1 },
            { type: 'other_type', amount: -1 },
            { type: 'other_type', amount: 1 },
          ],
        }),
      };

      const result = await prestige.getByContentId('content_id', { database });

      expect(result.initialTabcoins).toBe(0);
      expect(result.totalTabcoins).toBe(1);
    });
  });

  describe('getByUserId', () => {
    it('should call database.query', async () => {
      const userId = uuidV4();
      const timeOffset = new Date(Date.now() - 1000 * 60 * 60 * 24 * 2);
      const isRoot = true;
      const limit = 10;
      const offset = 3;
      const transaction = null;
      const database = {
        query: vi.fn().mockResolvedValue({ rows: [] }),
      };

      await prestige.getByUserId(userId, { timeOffset, isRoot, limit, transaction, database });

      expect(database.query).toHaveBeenCalledWith(
        {
          text: expect.any(String),
          values: [userId, timeOffset, isRoot, limit, offset],
        },
        { transaction },
      );
    });

    it('should return 0 when there are no rows', async () => {
      const userId = uuidV4();
      const timeOffset = new Date(Date.now() - 1000 * 60 * 60 * 24 * 2);
      const isRoot = true;
      const limit = 10;
      const transaction = null;
      const database = {
        query: vi.fn().mockResolvedValue({ rows: [] }),
      };

      const result = await prestige.getByUserId(userId, { timeOffset, isRoot, limit, transaction, database });

      expect(result).toBe(0);
    });

    it('should return the correct prestige level for root contents', async () => {
      const userId = 1;
      const timeOffset = new Date(Date.now() - 1000 * 60 * 60 * 24 * 2);
      const isRoot = true;
      const limit = 10;
      const transaction = null;
      const database = {
        query: vi.fn().mockResolvedValue({
          rows: [
            { tabcoins: 1 },
            { tabcoins: 2 },
            { tabcoins: 3 },
            { tabcoins: 4 },
            { tabcoins: 5 },
            { tabcoins: 6 },
            { tabcoins: 7 },
            { tabcoins: 8 },
            { tabcoins: 9 },
            { tabcoins: 10 },
          ],
        }),
      };

      const result = await prestige.getByUserId(userId, { timeOffset, isRoot, limit, transaction, database });

      expect(result).toBe(11);
    });

    it('should return the correct prestige level for child contents', async () => {
      const userId = 1;
      const timeOffset = new Date(Date.now() - 1000 * 60 * 60 * 24 * 2);
      const isRoot = false;
      const limit = 10;
      const transaction = null;
      const database = {
        query: vi.fn().mockResolvedValue({
          rows: [
            { tabcoins: 8 },
            { tabcoins: 7 },
            { tabcoins: 6 },
            { tabcoins: 5 },
            { tabcoins: 4 },
            { tabcoins: 3 },
            { tabcoins: 2 },
            { tabcoins: 1 },
          ],
        }),
      };

      const result = await prestige.getByUserId(userId, { timeOffset, isRoot, limit, transaction, database });

      expect(result).toBe(10);
    });
  });

  describe('calcTabcoinsAverage', () => {
    const cases = [
      // [tabcoins[], average]
      [[], 1], // default value
      [[1], 1],
      [[0], 0],
      [[0, 0], 0],
      [[1, 2, 3, 4], 2.5],
      [[-1, 5], 2],
      [[-2, -7, -4], -13 / 3],
    ];

    test.each(cases)('given %p values, returns mean %d', (array, expected) => {
      const tabcoinsObjectArray = array.map((tabcoins) => ({ tabcoins }));

      expect(prestige.calcTabcoinsAverage(tabcoinsObjectArray)).toBe(expected);
    });
  });

  describe('calcPrestigeLevel', () => {
    const cases = [
      // isRoot, tabcoinsMean, prestigeLevel
      [true, -1, -1],
      [true, 0.5, -1],
      [true, 0.51, 0],
      [true, 1.1, 0],
      [true, 1.11, 1],
      [true, 1.2, 1],
      [true, 1.21, 2],
      [true, 1.3, 2],
      [true, 1.31, 3],
      [true, 1.4, 3],
      [true, 1.41, 4],
      [true, 1.6, 4],
      [true, 1.61, 5],
      [true, 1.8, 5],
      [true, 1.81, 6],
      [true, 2.1, 6],
      [true, 2.11, 7],
      [true, 2.4, 7],
      [true, 2.41, 8],
      [true, 3, 8],
      [true, 3.1, 9],
      [true, 4, 9],
      [true, 4.1, 10],

      [false, -1, -1],
      [false, 0.4, -1],
      [false, 0.41, 0],
      [false, 1.0, 0],
      [false, 1.01, 1],
      [false, 1.1, 1],
      [false, 1.11, 2],
      [false, 1.2, 2],
      [false, 1.21, 3],
      [false, 1.25, 3],
      [false, 1.26, 4],
      [false, 1.3, 4],
      [false, 1.31, 5],
      [false, 1.5, 5],
      [false, 1.51, 6],
      [false, 1.7, 6],
      [false, 1.71, 7],
      [false, 2.0, 7],
      [false, 2.01, 8],
      [false, 3, 8],
      [false, 3.1, 9],
      [false, 4, 9],
      [false, 4.1, 10],
    ];

    test.each(cases)('given isRoot %p and mean equal to %d, returns prestige %d', (isRoot, tabcoins, expected) => {
      expect(prestige.calcPrestigeLevel(tabcoins, isRoot)).toBe(expected);
    });
  });
});
</file>

<file path="tests/unit/models/remove-markdown.test.js">
import logger from 'infra/logger';
import removeMarkdown from 'models/remove-markdown';

describe('remove-markdown model', () => {
  vi.mock('infra/logger', () => ({
    default: {
      error: vi.fn(),
    },
  }));

  describe('customRemoveMarkdown', () => {
    it('should remove markdown and return a single line by default', () => {
      const input = '# Heading\n\nThis is **bold** text.';
      const result = removeMarkdown(input);
      expect(result).toBe('Heading This is bold text.');
    });

    it('should preserve line breaks if oneLine is false', () => {
      const input = '# Heading\n\nThis is **bold** text.';
      const result = removeMarkdown(input, { oneLine: false });
      expect(result).toBe('Heading\n\nThis is bold text.');
    });

    it('should trim the output by default', () => {
      const input = '   Heading   ';
      const result = removeMarkdown(input);
      expect(result).toBe('Heading');
    });

    it('should not trim the output if trim option is false', () => {
      const input = '   Heading   ';
      const result = removeMarkdown(input, { trim: false });
      expect(result).toBe(' Heading ');
    });

    it('should truncate the output if maxLength is provided', () => {
      const input = 'This is a very long text that should be truncated.';
      const result = removeMarkdown(input, { maxLength: 20 });
      expect(result).toBe('This is a very lo...');
    });

    it('should handle emojis correctly when truncating', () => {
      const input = '😀 This is a very long text that should be truncated.';
      const result = removeMarkdown(input, { maxLength: 20 });
      expect(result).toBe('😀 This is a very...');
    });

    it('should handle emojis at the truncation point', () => {
      const emoji = '👩‍❤️‍💋‍👨';
      expect(emoji).toHaveLength(11);
      const input = `Truncate this ${emoji} string.`;

      expect(removeMarkdown(input, { maxLength: 16 })).toBe('Truncate this...');
      expect(removeMarkdown(input, { maxLength: 17 })).toBe('Truncate this...');
      expect(removeMarkdown(input, { maxLength: 18 })).toBe('Truncate this 👩‍❤️‍💋‍👨...');
      expect(removeMarkdown(input, { maxLength: 19 })).toBe('Truncate this 👩‍❤️‍💋‍👨...');
      expect(removeMarkdown(input, { maxLength: 20 })).toBe('Truncate this 👩‍❤️‍💋‍👨 s...');
    });

    it('should handle errors gracefully and return the original input', () => {
      const input = {
        content: 'This is a test',
      };

      expect(removeMarkdown(input)).toStrictEqual(input);
      expect(logger.error).toHaveBeenCalledOnce();
      expect(() => removeMarkdown(input)).not.toThrow();
    });
  });
});
</file>

<file path="tests/unit/models/reward.test.js">
import { randomUUID as uuidV4 } from 'node:crypto';

import database from 'infra/database';
import balance from 'models/balance';
import content from 'models/content';
import event from 'models/event';
import prestige from 'models/prestige';
import reward from 'models/reward';
import user from 'models/user';

const tabcoinsBase = 20;
const contentAgeBase = 1000 * 60 * 60 * 24 * 7; // one week in milliseconds

const mocks = vi.hoisted(() => {
  return {
    query: vi.fn(),
    release: vi.fn(),
  };
});

vi.mock('infra/database', () => {
  return {
    default: {
      transaction: vi.fn().mockResolvedValue({
        query: mocks.query,
        release: mocks.release,
      }),
      errorCodes: {
        SERIALIZATION_FAILURE: '40001',
      },
    },
  };
});

vi.mock('models/balance');

vi.mock('models/content', () => ({
  default: {
    findWithStrategy: vi.fn().mockResolvedValue({
      rows: [
        {
          created_at: new Date(),
        },
      ],
    }),
  },
}));

vi.mock('models/event', () => ({
  default: {
    create: vi.fn().mockResolvedValue({ id: uuidV4() }),
  },
}));

vi.mock('models/prestige', () => ({
  default: {
    getByUserId: vi.fn().mockResolvedValue(2),
  },
}));

vi.mock('models/user', () => ({
  default: {
    findOneById: vi.fn().mockResolvedValue({
      rewarded_at: new Date('2021-01-01'),
    }),
    updateRewardedAt: vi.fn(),
  },
}));

function createRequestObj(props = {}) {
  return {
    context: {
      user: {
        id: props.id ?? uuidV4(),
        username: props.username ?? 'testuser',
        tabcoins: props.tabcoins ?? 0,
        rewarded_at: props.rewarded_at ?? new Date('2021-01-01'),
      },
      clientIp: props.clientIp ?? '127.0.0.1',
    },
  };
}

describe('reward model', () => {
  it('Should not reward if "request" is undefined', async () => {
    let request;

    const result = await reward(request);

    expect(result).toBe(0);
    expect(balance.create).not.toHaveBeenCalled();
    expect(user.updateRewardedAt).not.toHaveBeenCalled();
  });

  it('Should not reward if "context" is undefined', async () => {
    const request = {};

    const result = await reward(request);

    expect(result).toBe(0);
    expect(balance.create).not.toHaveBeenCalled();
    expect(user.updateRewardedAt).not.toHaveBeenCalled();
  });

  it('Should not reward if "user" is undefined', async () => {
    const request = createRequestObj();
    request.context.user = undefined;

    const result = await reward(request);

    expect(result).toBe(0);
    expect(balance.create).not.toHaveBeenCalled();
    expect(user.updateRewardedAt).not.toHaveBeenCalled();
  });

  it('Should not reward if "tabcoins" is undefined', async () => {
    const request = createRequestObj();
    request.context.user.tabcoins = undefined;

    const result = await reward(request);

    expect(result).toBe(0);
    expect(balance.create).not.toHaveBeenCalled();
    expect(user.updateRewardedAt).not.toHaveBeenCalled();
  });

  it('Should not reward if "userId" is undefined', async () => {
    const request = createRequestObj();
    request.context.user.id = undefined;

    const result = await reward(request);

    expect(result).toBe(0);
    expect(balance.create).not.toHaveBeenCalled();
    expect(user.updateRewardedAt).not.toHaveBeenCalled();
  });

  it('Should not reward if "username" is undefined', async () => {
    const request = createRequestObj();
    request.context.user.username = undefined;

    const result = await reward(request);

    expect(result).toBe(0);
    expect(balance.create).not.toHaveBeenCalled();
    expect(user.updateRewardedAt).not.toHaveBeenCalled();
  });

  it('Should not reward if "rewarded_at" is undefined', async () => {
    const request = createRequestObj();
    request.context.user.rewarded_at = undefined;

    const result = await reward(request);

    expect(result).toBe(0);
    expect(balance.create).not.toHaveBeenCalled();
    expect(user.updateRewardedAt).not.toHaveBeenCalled();
  });

  it('Should not reward if user has already been rewarded today', async () => {
    const request = createRequestObj({
      rewarded_at: new Date().setUTCHours(0, 0, 0, 0),
    });

    const result = await reward(request);

    expect(result).toBe(0);
    expect(balance.create).not.toHaveBeenCalled();
    expect(user.updateRewardedAt).not.toHaveBeenCalled();
  });

  it('Should not reward if user has already been rewarded now', async () => {
    const request = createRequestObj({
      rewarded_at: new Date(),
    });

    const result = await reward(request);

    expect(result).toBe(0);
    expect(balance.create).not.toHaveBeenCalled();
    expect(user.updateRewardedAt).not.toHaveBeenCalled();
  });

  it('Should not simultaneously reward', async () => {
    // First "rewarded_at" is in the past (2021-01-01).
    const request = createRequestObj();
    // Then "rewarded_at" is set to "now" to simulate a concurrent reward.
    user.findOneById.mockResolvedValueOnce({ rewarded_at: new Date() });

    const result = await reward(request);

    expect(mocks.query).toHaveBeenCalledWith('ROLLBACK');
    expect(mocks.release).toHaveBeenCalled();
    expect(result).toBe(0);
  });

  it('Should not reward if tabcoinsFactor is greater than prestigeFactor', async () => {
    const request = createRequestObj({
      tabcoins: tabcoinsBase + 1,
    });
    prestige.getByUserId.mockResolvedValueOnce(1);

    const result = await reward(request);

    expect(result).toBe(0);
    expect(balance.create).not.toHaveBeenCalled();
    expect(user.updateRewardedAt).toHaveBeenCalledWith(request.context.user.id, { transaction: expect.any(Object) });
  });

  it('Should not reward if tabcoinsFactor is equal to prestigeFactor', async () => {
    const request = createRequestObj({
      tabcoins: tabcoinsBase,
    });
    prestige.getByUserId.mockResolvedValueOnce(1);

    const result = await reward(request);

    expect(result).toBe(0);
    expect(balance.create).not.toHaveBeenCalled();
    expect(user.updateRewardedAt).toHaveBeenCalledWith(request.context.user.id, { transaction: expect.any(Object) });
  });

  it('Should reward if tabcoinsFactor is less than prestigeFactor', async () => {
    const request = createRequestObj({
      tabcoins: tabcoinsBase - 1,
    });
    prestige.getByUserId.mockResolvedValueOnce(1);

    const result = await reward(request);

    expect(result).toBeGreaterThan(0);

    expect(database.transaction).toHaveBeenCalled();
    expect(mocks.query).toHaveBeenCalledWith('BEGIN');
    expect(mocks.query).toHaveBeenCalledWith('COMMIT');
    expect(mocks.release).toHaveBeenCalled();
    expect(user.updateRewardedAt).toHaveBeenCalledWith(request.context.user.id, { transaction: expect.any(Object) });

    expect(balance.create).toHaveBeenCalledWith(
      {
        amount: result,
        balanceType: 'user:tabcoin',
        originatorId: expect.any(String),
        originatorType: 'event',
        recipientId: request.context.user.id,
      },
      { transaction: expect.any(Object) },
    );
    expect(event.create).toHaveBeenCalledWith(
      {
        metadata: {
          amount: result,
          reward_type: 'daily',
        },
        originator_ip: request.context.clientIp,
        originator_user_id: request.context.user.id,
        type: 'reward:user:tabcoins',
      },
      { transaction: expect.any(Object) },
    );
  });

  describe('Reward correct values', () => {
    const cases = [
      // [ contentAge, tabcoins, prestige, reward ]
      [0, 0, 0, 0],
      [0, 0, 1, 1],
      [0, 0, 2, 2],
      [0, 0, 3, 3],
      [0, 0, tabcoinsBase, tabcoinsBase],
      [0, 0, tabcoinsBase * 2, tabcoinsBase * 2],
      [0, tabcoinsBase - 1, 0, 0],
      [0, tabcoinsBase - 1, 1, 1],
      [0, tabcoinsBase - 1, 2, 2],
      [0, tabcoinsBase, 1, 0],
      [0, tabcoinsBase, 2, 1],
      [0, tabcoinsBase, 3, 2],
      [0, tabcoinsBase * 2 - 1, 3, 0],
      [0, tabcoinsBase * 2 - 1, 4, 1],
      [0, tabcoinsBase * 2, 4, 0],
      [0, tabcoinsBase * 2, 5, 1],
      [0, tabcoinsBase * 3, 9, 0],
      [0, tabcoinsBase * 3, 10, 1],

      [1, 0, 0, 0],
      [1, 0, 1, 1],
      [1, 0, 2, 1],
      [1, 0, 3, 2],
      [1, 0, 4, 2],
      [1, 0, 5, 3],

      [1, tabcoinsBase - 1, 0, 0],
      [1, tabcoinsBase - 1, 1, 1],
      [1, tabcoinsBase - 1, 2, 1],
      [1, tabcoinsBase - 1, 3, 2],
      [1, tabcoinsBase, 1, 0],
      [1, tabcoinsBase, 2, 1],
      [1, tabcoinsBase, 3, 1],
      [1, tabcoinsBase, 4, 2],

      [2, 0, 0, 0],
      [2, 0, 1, 1],
      [2, 0, 3, 1],
      [2, 0, 4, 2],
      [2, 0, 6, 2],
      [2, 0, 7, 3],

      [365, 0, 1, 1],
      [365, tabcoinsBase, 2, 1],
    ];

    test.each(cases)(
      'With content age %d, user tabcoins %d and prestige %d, should return %d',
      async (contentAge, tabcoins, userPrestige, expected) => {
        const request = createRequestObj({ tabcoins });
        prestige.getByUserId.mockResolvedValueOnce(userPrestige);
        content.findWithStrategy.mockResolvedValueOnce({
          rows: [{ created_at: new Date(new Date().getTime() - contentAge * contentAgeBase - 1) }],
        });

        const result = await reward(request);

        expect(result).toBe(expected);
      },
    );
  });
});
</file>

<file path="tests/constants-for-tests.js">
export const defaultTabCashForAdCreation = 100;
export const maxSlugLength = 160;
export const maxTitleLength = 255;
export const relevantBody = 'Body with relevant text needs to contain a good amount of words.';
</file>

<file path="tests/orchestrator.js">
/* eslint-disable no-console */
import { faker } from '@faker-js/faker';
import retry from 'async-retry';
import { randomUUID } from 'node:crypto';
import fs from 'node:fs';
import setCookieParser from 'set-cookie-parser';

import database from 'infra/database.js';
import migrator from 'infra/migrator.js';
import webserver from 'infra/webserver.js';
import activation from 'models/activation.js';
import balance from 'models/balance.js';
import ban from 'models/ban';
import content from 'models/content.js';
import event from 'models/event.js';
import recovery from 'models/recovery.js';
import session from 'models/session.js';
import user from 'models/user.js';

if (process.env.NODE_ENV !== 'test') {
  throw new Error({
    message: 'Orchestrator should only be used in tests',
  });
}

const webserverUrl = webserver.host;
const emailServiceUrl = `http://${process.env.EMAIL_HTTP_HOST}:${process.env.EMAIL_HTTP_PORT}`;

async function waitForAllServices() {
  await waitForWebServer();
  await waitForDatabase();
  await waitForEmailService();

  async function waitForWebServer() {
    return await retry(
      async (bail, tries) => {
        if (tries >= 25) {
          console.log(`> Trying to connect to Webserver #${tries}. Are you running the server with "npm run dev"?`);
        }
        await fetch(`${webserverUrl}/api/v1/status`);
      },
      {
        retries: 50,
        minTimeout: 10,
        maxTimeout: 1000,
        factor: 1.1,
      },
    );
  }

  async function waitForDatabase() {
    return await retry(
      async (bail, tries) => {
        if (tries >= 25) {
          console.log(`> Trying to connect to Database #${tries}. Are you running the Postgres container?`);
        }
        const connection = await database.getNewClient();
        await connection.end();
      },
      {
        retries: 50,
        minTimeout: 10,
        maxTimeout: 1000,
        factor: 1.1,
      },
    );
  }

  async function waitForEmailService() {
    return await retry(
      async (bail, tries) => {
        if (tries >= 25) {
          console.log(`> Trying to connect to Email Service #${tries}, Are you running the MailCatcher container?`);
        }
        await fetch(emailServiceUrl);
      },
      {
        retries: 50,
        minTimeout: 10,
        maxTimeout: 1000,
        factor: 1.1,
      },
    );
  }
}

async function dropAllTables() {
  const databaseClient = await database.getNewClient();
  await databaseClient.query('drop schema public cascade; create schema public;');

  await databaseClient.end();
}

async function runPendingMigrations() {
  await migrator.runPendingMigrations();
}

async function deleteAllEmails() {
  await fetch(`${emailServiceUrl}/messages`, {
    method: 'DELETE',
  });
}

function waitForFirstEmail(options) {
  return waitForNthEmail(1, options);
}

async function waitForNthEmail(n, { intervalMs = 1, maxAttempts = 500 } = {}) {
  const logInterval = 5;

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    const response = await fetch(`${emailServiceUrl}/messages`);
    const emailList = await response.json();

    if (emailList.length >= n) {
      if (attempt >= logInterval) process.stdout.write('\n');
      const nthEmail = emailList[n - 1];
      await setEmailTextHtml(nthEmail);
      return nthEmail;
    }

    if (attempt < maxAttempts) {
      if (attempt === logInterval) {
        process.stdout.write(`⏳ Waiting for email #${n}`);
      } else if (attempt % logInterval === 0) {
        process.stdout.write('.');
      }

      await delay(intervalMs);
    }
  }

  process.stdout.write('\n⚠️ Failed to get email after max attempts.\n');
  return null;
}

async function getEmails(minCount = 1, { maxAttempts = 500, intervalMs = 1 } = {}) {
  const logInterval = 5;
  let emailList = [];

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    const response = await fetch(`${emailServiceUrl}/messages`);
    emailList = await response.json();

    if (emailList.length >= minCount) {
      if (attempt >= logInterval) process.stdout.write('\n');
      break;
    }

    if (attempt === maxAttempts) {
      process.stdout.write(`\n⚠️ Reached max attempts (${maxAttempts}). Proceeding with available emails.\n`);
      break;
    }

    if (attempt === logInterval) {
      process.stdout.write(`⏳ Waiting for at least ${minCount} email(s)...`);
    } else if (attempt % logInterval === 0) {
      process.stdout.write('.');
    }

    await delay(intervalMs);
  }

  const parsed = await Promise.allSettled(emailList.map(setEmailTextHtml));
  return parsed.map((p) => p.value);
}

async function hasEmailsAfterDelay(delayMs = 10) {
  await delay(delayMs);

  const response = await fetch(`${emailServiceUrl}/messages`);
  const emailList = await response.json();

  return emailList.length > 0;
}

function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function setEmailTextHtml(email) {
  const emailTextResponse = await fetch(`${emailServiceUrl}/messages/${email.id}.plain`);
  const emailText = await emailTextResponse.text();
  email.text = emailText;

  const emailHtmlResponse = await fetch(`${emailServiceUrl}/messages/${email.id}.html`);
  const emailHtml = await emailHtmlResponse.text();
  email.html = emailHtml;

  return email;
}

const usedFakeUsernames = new Set();
const usedFakeEmails = new Set();

async function createUser(userObject) {
  let username = userObject?.username;
  let email = userObject?.email;

  while (!username) {
    username = faker.internet.username().replace(/[_.-]/g, '').substring(0, 30);

    if (usedFakeUsernames.has(username)) {
      username = undefined;
    } else {
      usedFakeUsernames.add(username);
    }
  }

  while (!email) {
    email = faker.internet.email();

    if (usedFakeEmails.has(email)) {
      email = undefined;
    } else {
      usedFakeEmails.add(email);
    }
  }

  const createdUser = await user.create({
    username,
    email,
    password: userObject?.password || 'password',
    description: userObject?.description || '',
  });
  await activation.create(createdUser);

  return createdUser;
}

async function addFeaturesToUser(userObject, features) {
  return await user.addFeatures(userObject.id, features);
}

async function removeFeaturesFromUser(userObject, features) {
  return await user.removeFeatures(userObject.id, features);
}

async function activateUser(userObject) {
  const findTokenQuery = {
    text: `
      SELECT
        id
      FROM activate_account_tokens
      WHERE user_id = $1
        AND used = false
        AND expires_at >= now()
      ORDER BY created_at DESC
      LIMIT 1;
    `,
    values: [userObject.id],
  };
  const results = await database.query(findTokenQuery);
  const token = results.rows[0];

  await activation.activateUserUsingTokenId(token.id);

  return await user.findOneById(userObject.id);
}

async function nukeUser(userObject) {
  return await ban.nuke(userObject.id);
}

async function createSession(userObject) {
  return await session.create(userObject.id);
}

async function findSessionByToken(token) {
  return await session.findOneValidByToken(token);
}

async function createContent(contentObject) {
  const contentId = contentObject?.id || randomUUID();

  const currentEvent = await event.create({
    type: contentObject?.parent_id ? 'create:content:text_child' : 'create:content:text_root',
    originator_user_id: contentObject?.owner_id,
    metadata: {
      id: contentId,
    },
  });

  const createdContent = await content.create(
    {
      id: contentId,
      parent_id: contentObject?.parent_id || undefined,
      owner_id: contentObject?.owner_id || undefined,
      title: contentObject?.title || undefined,
      slug: contentObject?.slug || undefined,
      body: contentObject?.body || faker.lorem.paragraphs(5),
      status: contentObject?.status || 'draft',
      type: contentObject?.type || 'content',
      source_url: contentObject?.source_url || undefined,
    },
    {
      eventId: currentEvent.id,
    },
  );

  return createdContent;
}

async function updateContent(contentId, contentObject) {
  return await content.update(contentId, {
    parent_id: contentObject?.parent_id || undefined,
    owner_id: contentObject?.owner_id || undefined,
    title: contentObject?.title || undefined,
    slug: contentObject?.slug || undefined,
    body: contentObject?.body || undefined,
    status: contentObject?.status || undefined,
    source_url: contentObject?.source_url || undefined,
  });
}

async function createBalance(balanceObject) {
  return await balance.create({
    balanceType: balanceObject.balanceType,
    recipientId: balanceObject.recipientId,
    amount: balanceObject.amount,
    originatorType: balanceObject.originatorType || 'orchestrator',
    originatorId: balanceObject.originatorId || balanceObject.recipientId,
  });
}

async function createRate(contentObject, amount, fromUserId) {
  const tabCoinsRequiredAmount = 2;
  const originator_ip = faker.internet.ip();
  const transactionType = amount < 0 ? 'debit' : 'credit';

  if (!fromUserId) {
    fromUserId = randomUUID();

    await createBalance({
      balanceType: 'user:tabcoin',
      recipientId: fromUserId,
      amount: tabCoinsRequiredAmount * Math.abs(amount),
      originatorType: 'orchestrator',
      originatorId: fromUserId,
    });
  }

  for (let i = 0; i < Math.abs(amount); i++) {
    const currentEvent = await event.create({
      type: 'update:content:tabcoins',
      originator_user_id: fromUserId,
      originator_ip,
      metadata: {
        transaction_type: transactionType,
        from_user_id: fromUserId,
        content_owner_id: contentObject.owner_id,
        content_id: contentObject.id,
        amount: tabCoinsRequiredAmount,
      },
    });

    await balance.rateContent(
      {
        contentId: contentObject.id,
        contentOwnerId: contentObject.owner_id,
        fromUserId: fromUserId,
        transactionType,
      },
      {
        eventId: currentEvent.id,
      },
    );
  }
}

async function createRecoveryToken(userObject) {
  return await recovery.create(userObject);
}

async function createActivateAccountToken(userObject) {
  return await activation.create(userObject);
}

async function updateActivateAccountTokenByUserId(userId, tokenBody) {
  const query = {
    text: `
      UPDATE
        activate_account_tokens
      SET
        expires_at = $2
      WHERE
        user_id = $1
      RETURNING
        *
    ;`,
    values: [userId, tokenBody.expires_at],
  };

  const results = await database.query(query);
  return results.rows[0];
}

async function updateEmailConfirmationToken(tokenId, tokenBody) {
  const query = {
    text: `
      UPDATE
        email_confirmation_tokens
      SET
        expires_at = $2
      WHERE
        id = $1
      RETURNING
        *
    ;`,
    values: [tokenId, tokenBody.expires_at],
  };

  const results = await database.query(query);
  return results.rows[0];
}

async function createFirewallTestFunctions() {
  const procedures = fs.readdirSync('infra/stored-procedures');

  for (const procedureFile of procedures) {
    const procedureQuery = fs.readFileSync(`infra/stored-procedures/${procedureFile}`, 'utf8');
    await database.query(procedureQuery);
  }
}

// Prestige does not have to be an integer, so it can be given as a fraction.
// If the denominator is 0, the respective prestige will not be created.
async function createPrestige(
  userId,
  {
    rootPrestigeNumerator = 1,
    rootPrestigeDenominator = 4,
    childPrestigeNumerator = 0,
    childPrestigeDenominator = 1,
  } = {},
) {
  if (
    rootPrestigeDenominator < 0 ||
    childPrestigeDenominator < 0 ||
    rootPrestigeDenominator > 20 ||
    childPrestigeDenominator > 20
  ) {
    throw new Error('rootPrestigeDenominator and childPrestigeDenominator must be between 0 and 20');
  }

  const rootContents = [];
  const childContents = [];

  vi.useFakeTimers({
    now: new Date(Date.now() - 1000 * 60 * 60 * 24 * 3), // 3 days ago
  });

  for (let i = 0; i < rootPrestigeDenominator; i++) {
    rootContents.push(
      await createContent({
        owner_id: userId,
        title: faker.lorem.words(3),
        body: faker.lorem.paragraphs(1),
        status: 'published',
      }),
    );

    vi.advanceTimersByTime(10);
  }

  let parentId = rootContents[0]?.id;

  if (childPrestigeDenominator && !parentId) {
    const parent = await createContent({
      owner_id: userId,
      title: faker.lorem.words(3),
      body: faker.lorem.paragraphs(1),
      status: 'draft',
    });

    parentId = parent.id;
  }

  for (let i = 0; i < childPrestigeDenominator; i++) {
    childContents.push(
      await createContent({
        parent_id: parentId,
        owner_id: userId,
        body: faker.lorem.paragraphs(1),
        status: 'published',
      }),
    );
  }

  vi.useRealTimers();

  if (rootContents.length) {
    await createBalance({
      balanceType: rootPrestigeNumerator > 0 ? 'content:tabcoin:credit' : 'content:tabcoin:debit',
      recipientId: rootContents[0].id,
      amount: rootPrestigeNumerator,
      originatorType: 'orchestrator',
      originatorId: rootContents[0].id,
    });
  }

  if (childContents.length) {
    await createBalance({
      balanceType:
        childPrestigeNumerator + childPrestigeDenominator > 0 ? 'content:tabcoin:credit' : 'content:tabcoin:debit',
      recipientId: childContents[0].id,
      amount: childPrestigeNumerator + childPrestigeDenominator,
      originatorType: 'orchestrator',
      originatorId: childContents[0].id,
    });
  }

  return [...rootContents, ...childContents];
}

async function updateRewardedAt(userId, rewardedAt) {
  const query = {
    text: `
      UPDATE
        users
      SET
        rewarded_at = $1
      WHERE
        id = $2
      RETURNING
        *
    ;`,
    values: [rewardedAt, userId],
  };

  return await database.query(query);
}

async function getLastEvent() {
  const results = await database.query('SELECT * FROM events ORDER BY created_at DESC LIMIT 1;');
  return results.rows[0];
}

async function updateEventCreatedAt(id, createdAt) {
  const query = {
    text: 'UPDATE events SET created_at = $1 WHERE id = $2;',
    values: [createdAt, id],
  };
  const results = await database.query(query);
  return results.rows[0];
}

function parseSetCookies(response) {
  const setCookieHeaderValues = response.headers.get('set-cookie');
  const parsedCookies = setCookieParser.parse(setCookieHeaderValues, { map: true });
  return parsedCookies;
}

const orchestrator = {
  activateUser,
  addFeaturesToUser,
  createActivateAccountToken,
  createBalance,
  createContent,
  createFirewallTestFunctions,
  createPrestige,
  createRate,
  createRecoveryToken,
  createSession,
  createUser,
  deleteAllEmails,
  dropAllTables,
  findSessionByToken,
  getEmails,
  getLastEvent,
  hasEmailsAfterDelay,
  nukeUser,
  parseSetCookies,
  removeFeaturesFromUser,
  runPendingMigrations,
  updateActivateAccountTokenByUserId,
  updateContent,
  updateEmailConfirmationToken,
  updateEventCreatedAt,
  updateRewardedAt,
  waitForAllServices,
  waitForFirstEmail,
  waitForNthEmail,
  webserverUrl,
};

export default orchestrator;
</file>

<file path="tests/request-builder.js">
import orchestrator from './orchestrator';

export default class RequestBuilder {
  baseUrl = '';
  sessionObject;
  headers;

  constructor(urlSegments = '') {
    this.baseUrl = urlSegments.startsWith('http') ? urlSegments : `${orchestrator.webserverUrl}${urlSegments}`;
  }

  async buildUser(features = { with: [], without: [] }) {
    let userObject = await orchestrator.createUser();
    userObject = await orchestrator.activateUser(userObject);

    if (features.with?.length) {
      userObject = await orchestrator.addFeaturesToUser(userObject, features.with);
    }
    if (features.without?.length) {
      userObject = await orchestrator.removeFeaturesFromUser(userObject, features.without);
    }

    await this.setUser(userObject);

    return userObject;
  }

  async setUser(userObject) {
    this.sessionObject = await orchestrator.createSession(userObject);

    if (this.headers) {
      this.headers.cookie = `session_id=${this.sessionObject.token}`;
    }
  }

  buildHeaders(customHeaders) {
    const headers = {
      'Content-Type': 'application/json',
    };

    if (this.sessionObject) {
      headers.cookie = `session_id=${this.sessionObject.token}`;
    }

    this.headers = { ...headers, ...customHeaders };
    return this.headers;
  }

  async get(route = '') {
    if (!this.headers) {
      this.buildHeaders();
    }

    const response = await fetch(`${this.baseUrl}${route}`, {
      method: 'GET',
      headers: this.headers,
    });

    const responseBody = await response.json();

    return { response, responseBody };
  }

  async post(routeOrRequestBody, inputRequestBody) {
    const { route, requestBody } = this.getRouteAndRequestBody(routeOrRequestBody, inputRequestBody);

    if (!this.headers) {
      this.buildHeaders();
    }

    const fetchData = {
      method: 'POST',
      headers: this.headers,
    };

    if (requestBody) {
      fetchData.body = typeof requestBody === 'object' ? JSON.stringify(requestBody) : requestBody;
    }

    const response = await fetch(`${this.baseUrl}${route}`, fetchData);

    const responseBody = await response.json();

    return { response, responseBody };
  }

  async patch(routeOrRequestBody, inputRequestBody) {
    const { route, requestBody } = this.getRouteAndRequestBody(routeOrRequestBody, inputRequestBody);

    if (!this.headers) {
      this.buildHeaders();
    }

    const fetchData = {
      method: 'PATCH',
      headers: this.headers,
    };

    if (requestBody) {
      fetchData.body = typeof requestBody === 'object' ? JSON.stringify(requestBody) : requestBody;
    }

    const response = await fetch(`${this.baseUrl}${route}`, fetchData);

    const responseBody = await response.json();

    return { response, responseBody };
  }

  async delete(routeOrRequestBody, inputRequestBody) {
    const { route, requestBody } = this.getRouteAndRequestBody(routeOrRequestBody, inputRequestBody);

    if (!this.headers) {
      this.buildHeaders();
    }

    const fetchData = {
      method: 'DELETE',
      headers: this.headers,
    };

    if (requestBody) {
      fetchData.body = typeof requestBody === 'object' ? JSON.stringify(requestBody) : requestBody;
    }

    const response = await fetch(`${this.baseUrl}${route}`, fetchData);

    const responseBody = await response.json();

    return { response, responseBody };
  }

  getRouteAndRequestBody(routeOrRequestBody = '', inputRequestBody) {
    let route = routeOrRequestBody;
    let requestBody = inputRequestBody;

    if (typeof routeOrRequestBody === 'object') {
      route = '';
      requestBody = routeOrRequestBody;
    }

    return {
      route: route,
      requestBody: requestBody,
    };
  }
}
</file>

<file path="tests/setup.js">
// Mock only in jsdom environment.
if (typeof document !== 'undefined') {
  global.CSS = {
    supports: vi.fn().mockImplementation(() => {
      return false;
    }),
  };
}
</file>

<file path=".editorconfig">
root = true

[*]
indent_style = space
indent_size = 2
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# TypeScript v1 declaration files
typings/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env*.local

# parcel-bundler cache (https://parceljs.org/)
.cache

# Next.js build output
.next

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and *not* Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

.DS_Store

.vscode
/.idea

# Local .terraform directories
**/.terraform/*

# .tfstate files
*.tfstate
*.tfstate.*

# Crash log files
crash.log
crash.*.log

# Exclude all .tfvars files, which are likely to contain sensitive data, such as
# password, private keys, and other secrets. These should not be part of version
# control as they are data points which are potentially sensitive and subject
# to change depending on the environment.
*.tfvars
*.tfvars.json

# Ignore override files as they are usually used to override resources locally and so
# are not checked in
override.tf
override.tf.json
*_override.tf
*_override.tf.json

# Ignore CLI configuration files
.terraformrc
terraform.rc
.terraform.lock.hcl

yarn.*
.tool-versions
</file>

<file path=".gitpod.yml">
tasks:
  - name: Run Dev Server
    init: nvm install && npm install
ports:
  - port: 3000
    onOpen: notify
    visibility: private
  - port: 1080
    onOpen: ignore
    visibility: private
  - port: 1025
    onOpen: ignore
    visibility: private
</file>

<file path=".nvmrc">
lts/iron
</file>

<file path=".prettierignore">
public/museu
</file>

<file path="commitlint.config.js">
module.exports = {
  extends: ['@commitlint/config-conventional'],
};
</file>

<file path="CONTRIBUTING.md">
# Contribuindo com o TabNews

Primeiramente, agradecemos por dedicar seu tempo para contribuir com o projeto! 🎉

A seguir, temos um guia para lhe ajudar a contribuir com o TabNews através de _issues_ e _pull requests_. Se você ficar com alguma dúvida sobre o processo, [faça uma pergunta](https://github.com/filipedeschamps/tabnews.com.br/issues/new?labels=dúvida&projects=&template=3_question.yml) na parte de issues deste repositório.

**Conteúdo**

- [Reportar privadamente problemas de segurança](#reportar-privadamente-problemas-de-segurança)
- [Participar de debates em issues do repositório](#participar-de-debates-em-issues-do-repositório)
- [Participar de revisões de Pull Requests (PRs)](#participar-de-revisões-de-pull-requests-prs)
- [Desenvolver o código-fonte](#desenvolver-o-código-fonte)
  - [Rodar o lint do código](#rodar-o-lint-do-código)
  - [Criar novas Migrations](#criar-novas-migrations)
  - [Commit das alterações](#commit-das-alterações)
  - [Enviar pull requests](#enviar-pull-requests)

## Reportar privadamente problemas de segurança

Caso tenha encontrado alguma falha de segurança, pedimos que [reporte de forma privada pelo GitHub](https://github.com/filipedeschamps/tabnews.com.br/security/advisories/new). Isso permite discutir detalhes da vulnerabilidade de modo privado com os mantenedores do repositório sem o vazamento da vulnerabilidade ou de informações confidenciais.

Você pode seguir [o tutorial do GitHub](https://docs.github.com/pt/code-security/security-advisories/guidance-on-reporting-and-writing-information-about-vulnerabilities/privately-reporting-a-security-vulnerability#privately-reporting-a-security-vulnerability) sobre como fazer esse tipo de relato.

## Participar de debates em issues do repositório

Sugestões e reportes de bugs são feitos através de issues. Antes de criar um novo, [pesquise se o assunto já está sendo abordado](https://github.com/filipedeschamps/tabnews.com.br/issues) e complemente o debate com o seu ponto de vista ou com uma sugestão de implementação, se necessário.

Para abrir um issue, utilize os templates disponíveis clicando em [novo issue](https://github.com/filipedeschamps/tabnews.com.br/issues/new/choose).

O título, descrição e comentários devem ser feitos em português.

## Participar de revisões de Pull Requests (PRs)

Mesmo não sendo um mantenedor do repositório, você também pode revisar os pull requests, apontando erros que encontrou enquanto lia o código ou testava a implementação. Isso ajudará quem criou o PR e a pessoa que for avaliar o código antes de realizar o merge, possibilitando um processo de integração mais rápido.

Se você não possui certeza sobre algo, deixe claro no seu comentário para que um mantenedor possa responder suas dúvidas.

## Desenvolver o código-fonte

Se o problema que você quer resolver ainda não estiver documentado em um issue, então [leia o tópico sobre issues](#participar-de-debates-em-issues-do-repositório) e primeiro exponha o problema, depois proponha a solução (no próprio issue e sem preocupação com a implementação). Isso evitará que você invista seu tempo realizando uma modificação no código que não será aceita por não ser algo desejado ou que o comportamento esperado ainda não foi bem definido.

Se você está procurando algo para desenvolver como sendo a sua primeira interação com o código do repositório, você pode procurar por [issues com o label _"good first issue"_](https://github.com/filipedeschamps/tabnews.com.br/contribute), que são tarefas que não exigem conhecimento aprofundado sobre o código do TabNews, e que são possíveis até para quem nunca fez uma contribuição para um projeto de código aberto.

As alterações no código devem estar em inglês (nomes de funções, variáveis etc.) e seguir o padrão do projeto. Para entender como rodar o projeto e realizar suas alterações, leia as seções relacionadas no [README](/README.md#instalar-e-rodar-o-projeto).

### Rodar o lint do código

O seu código deve estar de acordo com o padrão do projeto. Para verificar se existe algum erro de lint, você pode usar o comando:

```bash
npm run lint
```

Alguns erros podem ser corrigidos automaticamente usando o comando abaixo, mas outros precisarão ser corrigidos de forma manual.

```bash
npm run lint:fix
```

Este processo será realizado automaticamente quando você commitar suas alterações.

### Criar novas Migrations

Se você está desenvolvendo algo que envolve uma alteração no banco de dados, você pode utilizar o script `migration:create` para criar uma nova migração, por exemplo:

```
npm run migration:create alter table users add tabcoins
```

Isto irá resultar em:

```
Created migration -- ./infra/migrations/1655399502254_alter-table-users-add-tabcoins.js
```

Caso esta nova migração esteja válida, ela será automaticamente executada na próxima vez que você rodar o comando `npm run dev`. Caso contrário, o serviço não irá subir e os logs de erro estarão registrados no arquivo `migrations.log` encontrado na raiz do projeto.

### Templates de email

Os templates de email estão localizados em `models/transactional/emails`, eles utilizam o [react-email](https://react.email/) para a composição do layout e renderização.

Para visualizar e testar os templates, você pode utilizar o comando:

```bash
npm run email
```

### Commit das alterações

Após finalizar suas alterações e se certificar que todos os testes estão passando com o comando geral `npm test`, chegou a hora de fazer o commit das suas alterações.

Para ser auxiliado no padrão de commit que utilizamos, rode o comando abaixo e siga as instruções. **A mensagem de commit deve estar em inglês.**

```bash
npm run commit
```

### Enviar pull requests

Após realizar as alterações, você pode [criar um novo pull request](https://github.com/filipedeschamps/tabnews.com.br/compare). A descrição estará pré-preenchida com comentários, que servem para te guiar a criar a descrição adequada, contendo as modificações realizadas no código e qual o impacto delas. Isso irá facilitar a revisão do PR por colaboradores do repositório. O título e a descrição do PR devem estar em português, e os commits em inglês. Para mais detalhes sobre a criação de um pull request, consulte a [documentação do GitHub](https://docs.github.com/pt/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork).

Se você percebeu que alguma verificação não está passando no PR, pode corrigir localmente e realizar um novo commit. Caso tudo esteja passando, basta aguardar a revisão do código por outros colaboradores do projeto. Depois de revisado, você pode precisar realizar alguma modificação. Durante o processo de revisão, um mantenedor do repositório poderá liberar a implantação na Vercel para criar uma versão no ambiente de homologação com o código do seu PR, gerando um link exclusivo para esse ambiente.

Quando as revisões forem feitas e aceitarem seu código, um mantenedor do repositório poderá realizar o merge, e então as suas modificações estarão rodando em produção 🎉.
</file>

<file path="eslint.config.js">
const defaultConfig = require('@tabnews/config/eslint');

const config = [
  ...defaultConfig,
  {
    rules: {
      '@typescript-eslint/no-unused-vars': [
        'warn',
        {
          argsIgnorePattern: '^_',
          destructuredArrayIgnorePattern: '^_',
          ignoreRestSiblings: true,
          args: 'after-used',
          caughtErrors: 'none',
        },
      ],
    },
  },
];

module.exports = config;
</file>

<file path="jsconfig.json">
{
  "compilerOptions": {
    "module": "NodeNext",
    "baseUrl": ".",
    "types": ["vitest/globals"],
    "paths": {
      "@/*": ["pages/interface/components/*"]
    }
  }
}
</file>

<file path="LICENSE">
MIT License

tabnews.com.br Copyright  (C) 2021-present  Filipe Deschamps Tech Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="lint-staged.config.js">
const { npm } = require('@tabnews/config/lint-staged');

module.exports = npm;
</file>

<file path="middleware.public.js">
import { NextResponse } from 'next/server';
import snakeize from 'snakeize';

import { UnauthorizedError } from 'errors';
import logger from 'infra/logger.js';
import rateLimit from 'infra/rate-limit.js';
import underMaintenance from 'infra/under-maintenance';
import webserver from 'infra/webserver.js';
import ip from 'models/ip.js';

export const config = {
  matcher: ['/((?!_next/static|va/|favicon|manifest).*)'],
};

export async function middleware(request) {
  if (webserver.isProduction && !ip.isRequestFromCloudflare(request)) {
    const publicErrorObject = new UnauthorizedError({
      message: 'Host não autorizado. Por favor, acesse https://www.tabnews.com.br.',
      action: 'Não repita esta requisição.',
    });

    const privateErrorObject = {
      ...publicErrorObject,
      context: {
        clientIp: ip.extractFromRequest(request),
      },
    };
    logger.info(snakeize(privateErrorObject));

    return new NextResponse(JSON.stringify(publicErrorObject), {
      status: 401,
      headers: {
        'content-type': 'application/json',
      },
    });
  }

  const isUnderMaintenance = underMaintenance.check(request);

  if (isUnderMaintenance) {
    return new NextResponse(isUnderMaintenance.body, {
      status: isUnderMaintenance.status,
      headers: {
        'content-type': 'application/json',
      },
    });
  }

  const url = request.nextUrl;

  try {
    const rateLimitResult = await rateLimit.check(request);

    if (!rateLimitResult.success && url.pathname === '/api/v1/sessions') {
      url.pathname = '/api/v1/_responses/rate-limit-reached-sessions'; // Fake response.
      return NextResponse.rewrite(url);
    }

    if (!rateLimitResult.success) {
      url.pathname = '/api/v1/_responses/rate-limit-reached';
      return NextResponse.rewrite(url);
    }

    if (url.pathname === '/api/v1/swr') {
      return new NextResponse(JSON.stringify({ timestamp: Date.now() }), {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    return NextResponse.next();
  } catch (error) {
    logger.error(snakeize({ message: error.message, ...error }));
    return NextResponse.next();
  }
}
</file>

<file path="next.config.js">
module.exports = {
  transpilePackages: ['@primer/react', '@tabnews/ui', '@tabnews/forms'],
  experimental: {
    scrollRestoration: true,
  },
  // Workaround: https://github.com/vercel/next.js/issues/51478#issuecomment-2095745187
  pageExtensions: ['public.js', 'workaround.js'],
  eslint: {
    ignoreDuringBuilds: true,
  },
  compiler: {
    styledComponents: true,
  },
  redirects() {
    return [
      {
        source: '/rss',
        destination: '/recentes/rss',
        permanent: true,
      },
      {
        source: '/rss.xml',
        destination: '/recentes/rss',
        permanent: true,
      },
      {
        source: '/pagina/1',
        destination: '/',
        permanent: true,
      },
      {
        source: '/recentes',
        destination: '/recentes/pagina/1',
        permanent: true,
      },
      {
        source: '/recentes/comentarios',
        destination: '/recentes/comentarios/1',
        permanent: true,
      },
      {
        source: '/recentes/classificados',
        destination: '/recentes/classificados/1',
        permanent: true,
      },
      {
        source: '/recentes/todos',
        destination: '/recentes/todos/1',
        permanent: true,
      },
    ];
  },
  rewrites() {
    return [
      {
        source: '/recentes/rss',
        destination: '/api/v1/contents/rss',
      },
      {
        source: '/api/v1/analytics',
        destination: `${process.env.NEXT_PUBLIC_UMAMI_ENDPOINT}/api/send`,
      },
    ];
  },
  headers() {
    // Security Headers based on: https://nextjs.org/docs/advanced-features/security-headers
    // TODO: implement "Content-Security-Policy" section
    const securityHeaders = [
      {
        key: 'X-DNS-Prefetch-Control',
        value: 'on',
      },
      {
        key: 'Strict-Transport-Security',
        value: 'max-age=63072000; includeSubDomains; preload',
      },
      {
        key: 'X-XSS-Protection',
        value: '1; mode=block',
      },
      {
        key: 'X-Frame-Options',
        value: 'SAMEORIGIN',
      },
      {
        key: 'Permissions-Policy',
        value: 'camera=(), microphone=(), geolocation=()',
      },
      {
        key: 'X-Content-Type-Options',
        value: 'nosniff',
      },
      {
        key: 'Referrer-Policy',
        value: 'origin-when-cross-origin',
      },
    ];

    return [
      {
        source: '/:path*',
        headers: securityHeaders,
      },

      // ENABLES CORS
      {
        source: '/api/:path*',
        headers: [
          { key: 'Access-Control-Allow-Credentials', value: 'true' },
          { key: 'Access-Control-Allow-Origin', value: '*' },
          { key: 'Access-Control-Allow-Methods', value: 'GET,OPTIONS,PATCH,DELETE,POST,PUT' },
          {
            key: 'Access-Control-Allow-Headers',
            value:
              'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version',
          },
        ],
      },
    ];
  },
};
</file>

<file path="package.json">
{
  "dependencies": {
    "@react-email/components": "0.0.19",
    "@react-email/render": "0.0.15",
    "@resvg/resvg-js": "2.6.2",
    "@tabnews/forms": "0.4.0",
    "@tabnews/helpers": "0.4.0",
    "@tabnews/infra": "0.0.6",
    "@tabnews/ui": "0.6.0",
    "@upstash/ratelimit": "2.0.5",
    "@upstash/redis": "1.34.9",
    "async-retry": "1.3.3",
    "bcryptjs": "3.0.2",
    "cookie": "0.6.0",
    "date-fns": "4.1.0",
    "feed": "4.2.2",
    "is-in-subnet": "4.0.1",
    "joi": "17.13.3",
    "next": "15.3.2",
    "next-connect": "1.0.0",
    "next-swr": "0.2.0-canary.0",
    "node-pg-migrate": "7.9.1",
    "nodemailer": "7.0.3",
    "nprogress": "0.2.0",
    "parse-link-header": "2.0.0",
    "pg": "8.15.6",
    "react": "18.3.1",
    "react-confetti": "6.4.0",
    "react-content-loader": "7.0.2",
    "react-dom": "18.3.1",
    "react-icons": "5.5.0",
    "react-rewards": "2.1.0",
    "recharts": "2.15.3",
    "remove-markdown": "0.6.2",
    "resend": "4.5.1",
    "satori": "0.10.13",
    "slug": "11.0.0",
    "snakeize": "0.1.0",
    "swr": "2.3.3",
    "vis-network": "9.1.10"
  },
  "devDependencies": {
    "@commitlint/cli": "19.8.1",
    "@commitlint/config-conventional": "19.8.1",
    "@faker-js/faker": "9.8.0",
    "@tabnews/config": "0.6.0",
    "@testing-library/dom": "10.4.0",
    "@testing-library/react": "16.3.0",
    "concurrently": "9.1.2",
    "cz-conventional-changelog": "3.3.0",
    "dotenv": "16.5.0",
    "dotenv-expand": "12.0.2",
    "husky": "9.1.7",
    "kill-port": "1.6.1",
    "lint-staged": "16.0.0",
    "react-email": "4.0.15",
    "set-cookie-parser": "2.7.1",
    "uuid": "9.0.1"
  },
  "scripts": {
    "dev": "npm run services:seed && npm run next && npm run services:stop",
    "next": "next dev",
    "build": "next build",
    "build:local": "npm run services:seed && next build",
    "start": "next start",
    "start:local": "npm run services:seed && next start && npm run services:stop",
    "email": "email dev --dir models/transactional/emails --port 3001",
    "services:seed": "kill-port 3000 && npm run services:up && npm run migration:run && npm run migration:seed && npm run umami:config",
    "services:up": "npm run docker:compose -- up -d",
    "services:stop": "npm run docker:compose -- stop",
    "services:down": "npm run docker:compose -- down",
    "docker:compose": "docker compose --env-file .env -f infra/docker-compose.development.yml",
    "preconcurrently": "kill-port 3000 && npm run services:up",
    "concurrently": "concurrently -s first -P -k -n next,vitest \"npm run next\" \"vitest {@}\"",
    "postconcurrently": "npm run services:stop",
    "test": "npm run concurrently -- --hide next -- run",
    "test:watch": "vitest watch",
    "test:watch:services": "npm run concurrently -- -- watch",
    "lint": "npm run lint:eslint && npm run lint:prettier",
    "lint:eslint": "eslint . --max-warnings 0",
    "lint:prettier": "prettier --check .",
    "lint:fix": "eslint --fix . && prettier --write .",
    "commit": "cz",
    "migration:create": "node-pg-migrate --migrations-dir ./infra/migrations create",
    "migration:run": "node -r dotenv-expand/config infra/scripts/wait-for-db-connection-ready.js && node-pg-migrate up --envPath ./.env -m infra/migrations/ 2>migrations.log",
    "migration:dry-run": "node-pg-migrate up --dry-run --envPath ./.env -m infra/migrations",
    "migration:seed": "node -r dotenv-expand/config infra/scripts/seed-database.js",
    "umami:config": "node -r dotenv-expand/config infra/scripts/config-umami.js",
    "prepare": "husky",
    "pre-commit": "lint-staged"
  },
  "engines": {
    "node": "20"
  },
  "name": "tabnews.com.br",
  "description": "Conteúdos para quem vive de programação e tecnologia.",
  "version": "1.0.0",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/filipedeschamps/tabnews.com.br.git"
  },
  "keywords": [
    "news"
  ],
  "author": "Filipe Deschamps",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/filipedeschamps/tabnews.com.br/issues"
  },
  "homepage": "https://www.tabnews.com.br/",
  "config": {
    "commitizen": {
      "path": "./node_modules/cz-conventional-changelog"
    }
  }
}
</file>

<file path="prettier.config.js">
module.exports = require('@tabnews/config/prettier');
</file>

<file path="README.md">
# [tabnews.com.br](https://www.tabnews.com.br/)

O [TabNews](https://www.tabnews.com.br/) é um site focado na comunidade da área de tecnologia, destinado a debates e troca de conhecimentos por meio de publicações e comentários criados pelos próprios usuários.

Esse repositório contém o código-fonte do site e da API do TabNews.

O TabNews disponibiliza APIs públicas que você pode utilizar para construir outros projetos relacionados, desde que respeite os [Termos de Uso](https://www.tabnews.com.br/termos-de-uso).

**Conteúdo**

- [Instalar e rodar o projeto](#instalar-e-rodar-o-projeto)
  - [Dependências globais](#dependências-globais)
  - [Dependências locais](#dependências-locais)
  - [Rodar o projeto](#rodar-o-projeto)
  - [Cadastro e Login de usuários](#cadastro-e-login-de-usuários)
    - [Criar um usuário manualmente](#criar-um-usuário-manualmente)
    - [Utilizar usuários pré-cadastrados](#utilizar-usuários-pré-cadastrados)
- [Rodar os testes](#rodar-os-testes)
- [Formas de contribuir](#formas-de-contribuir)
- [Histórico do desenvolvimento](#histórico-de-desenvolvimento)
  - [Início do projeto](#início-do-projeto)
  - [Milestones](#milestones)
- [Contribuidores](#contribuidores)

## Instalar e rodar o projeto

Rodar o TabNews em sua máquina local é uma tarefa extremamente simples.

### Dependências globais

Você precisa ter duas principais dependências instaladas:

- Node.js LTS v20 (ou qualquer versão superior)
- Docker Engine v17.12.0 com Docker Compose v1.29.2 (ou qualquer versão superior)

### Dependências locais

Com o repositório clonado e as dependências globais instaladas, você pode instalar as dependências locais do projeto:

```bash
npm install
```

### Rodar o projeto

Para rodar o projeto localmente, basta executar o comando abaixo:

```bash
npm run dev
```

Isto irá automaticamente rodar serviços como Banco de dados (incluindo as Migrations), Servidor de Email e irá expor um Serviço Web (Frontend e API) no seguinte endereço:

```bash
http://localhost:3000/
http://localhost:3000/api/v1/status
```

Observações:

- Para derrubar todos os serviços, basta utilizar as teclas `CTRL+C`, que é o padrão dos terminais para matar processos.
- Você pode conferir o endereço dos outros serviços dentro do arquivo `.env` encontrado na raiz do projeto, como por exemplo o endereço e credenciais do Banco de Dados local ou o Frontend do Serviço de Email.

### Cadastro e Login de usuários

No ambiente de desenvolvimento você poderá tanto criar usuários manualmente (inclusive para receber e testar o email de ativação), quanto utilizar usuários pré-cadastrados e que já foram ativados para sua conveniência.

#### Criar um usuário manualmente

1. Após subir os serviços, acesse http://localhost:3000/cadastro
2. Preencha os dados e utilize **qualquer email** com formato válido, mesmo que este email não exista, por exemplo: `teste@teste.com`
3. O backend irá enviar um email para o servidor **local** de emails e que pode ser acessado pelo endereço http://localhost:1080/
4. Abra o email de Ativação e acesse o link para ativar sua conta de fato.
5. Com a conta ativa, realize o login: http://localhost:3000/login

#### Utilizar usuários pré-cadastrados

Por padrão, ao rodar o comando `npm run dev` será injetado dois usuários ativados, um com features padrões e outro com features administrativas, como a habilidade de rodar as Migrations usando a API ou alterar o conteúdo de outros usuários. Segue abaixo as credenciais destes dois usuários (`"email"` + `"senha"`):

- **Usuário Admin**: `"admin@admin.com"` + `"password"`
- **Usuário padrão**: `"user@user.com"` + `"password"`

## Rodar os testes

Há várias formas de rodar os testes dependendo do que você deseja fazer, mas o primeiro passo antes de fazer qualquer alteração no projeto é rodar os testes de forma geral para se certificar que tudo está passando como esperado. O comando abaixo irá rodar todos os serviços necessários, rodar os testes e em seguida derrubar todos os serviços.

```bash
npm test
```

Caso queira manter os serviços e testes rodando enquanto desenvolve (e rodando novamente a cada alteração salva), use o modo `watch` com o comando abaixo:

```bash
npm run test:watch:services
```

Os logs do Serviço Web e Vitest (dos testes) irão se misturar, então caso queira rodar eles de forma separada, abra dois terminais separados e rode o seguinte:

```bash
# Terminal 1
npm run dev

# Terminal 2
npm run test:watch
```

Caso não queira executar (ou dar `watch`) em todos os testes e queira isolar arquivos específicos de teste, você pode filtrar pelo caminho. Não é necessário digitar o caminho inteiro para o arquivo e você também pode fornecer mais de um caminho, veja alguns exemplos abaixo:

```bash
# Rodar todos os testes de "users" e "status" da api "v1"
npm run test -- v1/users/ v1/status/

# Rodar apenas o arquivo tests/integration/api/v1/_use-cases/registration-flow.test.js
npm run test -- registration-flow

# Rodar apenas o arquivo tests/integration/api/v1/contents/[username]/patch.test.js
npm run test:watch:services -- username]/patch

# Rodar apenas o arquivo tests/integration/api/v1/contents/[username]/[slug]/get.test.js
npm run test:watch -- contents/[username]/[slug]/get
```

Observações:

- A forma como é tratado o caminho dos arquivos pode mudar dependendo do seu sistema operacional.
- A forma como o seu terminal interpreta caracteres especiais como `/` ou `[` pode mudar.

## Formas de contribuir

Você pode contribuir com o projeto de várias formas diferentes:

- **Criar conteúdos no site:** você pode criar publicações ou comentários no [TabNews](https://www.tabnews.com.br/) com conteúdo de valor para outros leitores. Para entender mais sobre isso, leia [sobre a plataforma](https://www.tabnews.com.br/filipedeschamps/tentando-construir-um-pedaco-de-internet-mais-massa) e veja as [perguntas mais frequentes](https://www.tabnews.com.br/faq).
- **[Reportar privadamente problemas de segurança](/CONTRIBUTING.md#reportar-privadamente-problemas-de-segurança):** problemas que envolvem falhas de segurança devem ser reportados de forma privada para possibilitar a discussão das vulnerabilidades diretamente com os mantenedores do repositório.
- **[Participar de debates em issues do repositório](/CONTRIBUTING.md#participar-de-debates-em-issues-do-repositório):** mesmo sem implementar algo no código, você pode contribuir com detalhes para a resolução de algum problema ou com ideias de implementação de algum recurso.
- **[Enviar PRs com soluções previamente debatidas](/CONTRIBUTING.md#enviar-prs-com-soluções-previamente-debatidas):** se você encontrou um issue que foi debatido e deseja implementá-lo, pode abrir um PR com a solução para ser avaliada e incorporada no TabNews.

## Histórico de Desenvolvimento

### Início do projeto

No início do projeto foram feitas 40 publicações no [Wiki](https://github.com/filipedeschamps/tabnews.com.br/wiki) do repositório. Lá você encontrará informações desde como a ideia do TabNews surgiu e como foram as contribuições no início do projeto, até as definições do layout e outras tomadas de decisão.

### Milestones

Milestones são marcos históricos do projeto para ajudar a guiar o desenvolvimento numa direção específica. Pelo GitHub é possível ver [a Milestone em andamento](https://github.com/filipedeschamps/tabnews.com.br/milestones?state=open) e [as Milestones encerradas](https://github.com/filipedeschamps/tabnews.com.br/milestones?state=closed).

## Contribuidores

<a href="https://github.com/filipedeschamps/tabnews.com.br/graphs/contributors">
  <img src="https://contributors-img.web.app/image?repo=filipedeschamps/tabnews.com.br&max=500" alt="Lista de contribuidores" width="100%"/>
</a>
</file>

<file path="vercel.json">
{
  "functions": {
    "pages/**/*.js": {
      "memory": 1769
    }
  },
  "regions": ["gru1"]
}
</file>

<file path="vitest.config.mjs">
import defineConfig from '@tabnews/config/vitest';
import { config } from 'dotenv';
import { defaultExclude } from 'vitest/config';

config();

export default defineConfig({
  test: {
    server: { deps: { inline: ['@tabnews/ui'] } },
    isolate: false,
    setupFiles: ['tests/setup.js'],
    workspace: [
      {
        extends: true,
        test: {
          name: 'integration',
          include: ['**/integration/**/*.{test,spec}.{js,ts}'],
        },
      },
      {
        extends: true,
        test: {
          name: 'unit',
          exclude: ['**/integration/**', '**/interface/**', ...defaultExclude],
        },
      },
      {
        extends: true,
        test: {
          name: 'ui',
          environment: 'jsdom',
          include: ['**/interface/**/*.{test,spec}.{js,ts}'],
        },
      },
    ],
  },
});
</file>

</files>
